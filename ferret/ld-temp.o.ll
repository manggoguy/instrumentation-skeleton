; ModuleID = 'ld-temp.o'
source_filename = "ld-temp.o"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.queue = type { i32, i32, i8**, i32, i32, i32, %union.pthread_mutex_t, %union.pthread_cond_t, %union.pthread_cond_t }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.anon, %union.anon, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.anon = type { i64 }
%struct._cass_table = type { i32, i8*, i8*, %struct._cass_env_t*, i32, i32, i32, i32, %struct.anon.5, %struct._cass_table_opr*, i32, i32, i8*, %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t*, %struct.cass_map_t*, %struct.anon.8 }
%struct._cass_env_t = type { i32, i8*, %struct.cass_reg_t, %struct.cass_reg_t, %struct.cass_reg_t, %struct.cass_reg_t, %struct.cass_reg_t }
%struct.cass_reg_t = type { i32, i32, i32, %struct.cass_reg_entry_t* }
%struct.cass_reg_entry_t = type { i8*, i8* }
%struct.anon.5 = type { i32, i32, i32, i32* }
%struct._cass_table_opr = type { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table*, i8*)*, i32 (%struct._cass_table*, i8*)*, i32 (%struct._cass_table*, %struct.cass_dataset_t*, i32, i32)*, {}*, i32 (%struct._cass_table*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table*)*, i32 (%struct._cass_table*)*, i32 (%struct._cass_table*, %struct._IO_FILE*)*, i32 (%struct._cass_table*, %struct._IO_FILE*)*, i32 (%struct._cass_table*)*, i32 (%struct._cass_table_opr*, %struct._IO_FILE*)* }
%struct.cass_dataset_t = type { i32, i32, i32, i32, i32, i32, i8*, i32, i32, %struct._cass_vecset_t* }
%struct._cass_vecset_t = type { i32, i32 }
%struct.cass_query_t = type { i32, %struct.cass_dataset_t*, i32, i32, float, i8*, %struct.cass_result_t*, i32, i32 }
%struct.cass_result_t = type { i32, %union.anon.2 }
%union.anon.2 = type { %struct.cass_list_t }
%struct.cass_list_t = type { i32, i32, i32, %struct.cass_list_entry_t* }
%struct.cass_list_entry_t = type { i32, float }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct._cass_vecset_cfg_t = type { i32, i8*, i32, i32, i32, i32, i32 }
%struct.cass_map_t = type { i32, i32, i8*, %struct._cass_env_t*, i32, %struct.anon.5, i32, i32, %struct.anon.7, %struct.CKHash_Table_* }
%struct.anon.7 = type { i32, i32, i32, i8** }
%struct.CKHash_Table_ = type { i32, i32, i32, i32, i32, i32, %struct.CKHash_Cell*, %struct.CKHash_Cell*, i32, i32*, i32*, %struct.anon.7* }
%struct.CKHash_Cell = type { i32, i8*, i32 }
%struct.anon.8 = type { i32, i32, i32, %struct._cass_table** }
%struct._cass_table.91 = type { i32, i8*, i8*, %struct._cass_env_t*, i32, i32, i32, i32, %struct.anon.5, %struct._cass_table_opr.86*, i32, i32, i8*, %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t*, %struct.cass_map_t*, %struct.anon.4.90 }
%struct._cass_table_opr.86 = type { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, {}*, {}*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, {}*, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* }
%struct.anon.4.90 = type { i32, i32, i32, %struct._cass_table.91** }
%struct.gsl_rng_type = type { i8*, i64, i64, i64, void (i8*, i64)*, i64 (i8*)*, double (i8*)* }
%struct._cass_table.157 = type { i32, i8*, i8*, %struct._cass_env_t*, i32, i32, i32, i32, %struct.anon.5, %struct._cass_table_opr.152*, i32, i32, i8*, %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t*, %struct.cass_map_t*, %struct.anon.4.156 }
%struct._cass_table_opr.152 = type { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.157*, i8*)*, {}*, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* }
%struct.anon.4.156 = type { i32, i32, i32, %struct._cass_table.157** }
%struct._cass_vec_dist_class = type { i8*, i32, i32, float (i32, i8*, i8*, i8*)*, i32 (i8*, %struct._IO_FILE*)*, i32 (i8**, i8*)*, i32 (i8*, %struct._IO_FILE*)*, i32 (i8**, %struct._IO_FILE*)*, void (i8*)* }
%struct._cass_vecset_dist_class = type { i8*, i32, i32, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, i32 (i8*, %struct._IO_FILE*)*, i32 (i8**, i8*)*, i32 (i8*, %struct._IO_FILE*)*, i32 (i8**, %struct._IO_FILE*)*, void (i8*)* }
%struct.cass_vec_dist_t = type { i32, i8*, %struct._cass_vec_dist_class* }
%struct.__dirstream = type opaque
%struct.dirent = type { i64, i64, i16, i8, [256 x i8] }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.load_data = type { i32, i32, i8*, i8*, i8* }
%struct.seg_data = type { i32, i32, i32, i8*, i8*, i8* }
%struct.extract_data = type { %struct.cass_dataset_t, i8* }
%struct._cass_table.19 = type { i32, i8*, i8*, %struct._cass_env_t*, i32, i32, i32, i32, %struct.anon.5, %struct._cass_table_opr.16*, i32, i32, i8*, %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t*, %struct.cass_map_t*, %struct.anon.4 }
%struct._cass_table_opr.16 = type { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.19*, i8*)*, i32 (%struct._cass_table.19*, i8*)*, i32 (%struct._cass_table.19*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.19*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.19*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.19*)*, i32 (%struct._cass_table.19*)*, i32 (%struct._cass_table.19*, %struct._IO_FILE*)*, i32 (%struct._cass_table.19*, %struct._IO_FILE*)*, i32 (%struct._cass_table.19*)*, i32 (%struct._cass_table_opr.16*, %struct._IO_FILE*)* }
%struct.anon.4 = type { i32, i32, i32, %struct._cass_table.19** }
%struct.vec_query_data = type { i8*, %struct.cass_dataset_t*, %struct.cass_result_t }
%struct.stimer_t = type { %struct.timespec, %struct.timespec, float }
%struct.tdesc_s = type { %union.pthread_attr_t*, i8* (i8*)*, i8* }
%union.pthread_attr_t = type { i64, [48 x i8] }
%struct.tpool_s = type { i32, i64*, i32 }
%struct.cass_vecset_dist_t = type { i32, i8*, i32, %struct._cass_vecset_dist_class* }
%union.pthread_mutexattr_t = type { i32 }
%struct._cass_table_opr.69 = type { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.59*, i8*)*, i32 (%struct._cass_table.59*, i8*)*, i32 (%struct._cass_table.59*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.59*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.59*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.59*)*, i32 (%struct._cass_table.59*)*, i32 (%struct._cass_table.59*, %struct._IO_FILE*)*, i32 (%struct._cass_table.59*, %struct._IO_FILE*)*, i32 (%struct._cass_table.59*)*, i32 (%struct._cass_table_opr.69*, %struct._IO_FILE*)* }
%struct._cass_table.59 = type { i32, i8*, i8*, %struct._cass_env_t*, i32, i32, i32, i32, %struct.anon.5, %struct._cass_table_opr.69*, i32, i32, i8*, %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t*, %struct.cass_map_t*, %struct.anon.2 }
%struct.anon.2 = type { i32, i32, i32, %struct._cass_table.59** }
%struct.raw_private = type { %struct.cass_dataset_t }
%struct.bitmap_t = type { i32, i32, i8* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.gsl_rng = type { %struct.gsl_rng_type*, i8* }
%struct.LSH_est_t = type { i32, i32, double, double, double, double, double, double, double**, double** }
%struct.LSH_recall_t = type { i32, i32, float, float, float** }
%struct.LSH_t = type { i32, i32, i32, i32, i32, float*, float**, float*, i32**, %struct.ohash_t*, i32**, i32*, %struct.LSH_est_t*, %struct.LSH_recall_t }
%struct.ohash_t = type { i32, %struct.anon.5* }
%struct.LSH_query_t = type { %struct.LSH_t*, %struct.cass_dataset_t*, i32, i32, i32, %struct.bitmap_t*, i32**, i32*, %struct.ptb_vec_t**, i32*, %struct.ptb_vec_t*, %struct.ptb_vec_t**, %struct.cass_list_entry_t*, %struct.cass_list_entry_t**, i32*, i32*, float*, i32, float, float, float }
%struct.ptb_vec_t = type { i64, float, i32, i32, float }
%struct.signature_t = type { i32, i8**, float* }
%struct.sol = type { i32, i32, float, i32, i32, float, %struct.sol*, %struct.sol* }
%struct.U = type { i32, float, %struct.U* }
%struct.b2s = type { i32, i32, i32, %struct.b2s* }
%struct.anon.212 = type { i32, i32, i32, %struct._cass_vecset_t* }
%struct.emd_state_t = type { i32, i32, float**, [514 x %struct.emd_node2_t], %struct.emd_node2_t*, %struct.emd_node2_t*, [257 x [257 x i8]], [257 x %struct.emd_node2_t*], [257 x %struct.emd_node2_t*], double, float, double, i32 }
%struct.emd_node2_t = type { i32, i32, double, %struct.emd_node2_t*, %struct.emd_node2_t* }
%struct.emd_node1_t = type { i32, double, %struct.emd_node1_t* }
%struct.jpeg_decompress_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i8*, i32, i32, %struct.jpeg_source_mgr*, i32, i32, i32, i32, i32, i32, i32, double, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8**, i32, i32, i32, i32, i32, [64 x i32]*, [4 x %struct.JQUANT_TBL*], [4 x %struct.JHUFF_TBL*], [4 x %struct.JHUFF_TBL*], i32, %struct.jpeg_component_info*, i32, i32, i32, [16 x i8], [16 x i8], [16 x i8], i32, i32, i8, i8, i8, i16, i16, i32, i8, i32, %struct.jpeg_marker_struct*, i32, i32, i32, i32, i32, i8*, i32, [4 x %struct.jpeg_component_info*], i32, i32, i32, [10 x i32], i32, i32, i32, i32, i32, i32*, i32, i32, %struct.jpeg_decomp_master*, %struct.jpeg_d_main_controller*, %struct.jpeg_d_coef_controller*, %struct.jpeg_d_post_controller*, %struct.jpeg_input_controller*, %struct.jpeg_marker_reader*, %struct.jpeg_entropy_decoder*, %struct.jpeg_inverse_dct*, %struct.jpeg_upsampler*, %struct.jpeg_color_deconverter*, %struct.jpeg_color_quantizer* }
%struct.jpeg_error_mgr = type { void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i32)*, void (%struct.jpeg_common_struct*)*, void (%struct.jpeg_common_struct*, i8*)*, void (%struct.jpeg_common_struct*)*, i32, %union.anon.221, i32, i64, i8**, i32, i8**, i32, i32 }
%struct.jpeg_common_struct = type { %struct.jpeg_error_mgr*, %struct.jpeg_memory_mgr*, %struct.jpeg_progress_mgr*, i8*, i32, i32 }
%union.anon.221 = type { [8 x i32], [48 x i8] }
%struct.jpeg_memory_mgr = type { i8* (%struct.jpeg_common_struct*, i32, i64)*, i8* (%struct.jpeg_common_struct*, i32, i64)*, i8** (%struct.jpeg_common_struct*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, i32, i32, i32)*, %struct.jvirt_sarray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, %struct.jvirt_barray_control* (%struct.jpeg_common_struct*, i32, i32, i32, i32, i32)*, {}*, i8** (%struct.jpeg_common_struct*, %struct.jvirt_sarray_control*, i32, i32, i32)*, [64 x i16]** (%struct.jpeg_common_struct*, %struct.jvirt_barray_control*, i32, i32, i32)*, void (%struct.jpeg_common_struct*, i32)*, {}*, i64, i64 }
%struct.jvirt_sarray_control = type opaque
%struct.jvirt_barray_control = type opaque
%struct.jpeg_progress_mgr = type { {}*, i64, i64, i32, i32 }
%struct.jpeg_source_mgr = type { i8*, i64, void (%struct.jpeg_decompress_struct*)*, i32 (%struct.jpeg_decompress_struct*)*, void (%struct.jpeg_decompress_struct*, i64)*, i32 (%struct.jpeg_decompress_struct*, i32)*, void (%struct.jpeg_decompress_struct*)* }
%struct.JQUANT_TBL = type { [64 x i16], i32 }
%struct.JHUFF_TBL = type { [17 x i8], [256 x i8], i32 }
%struct.jpeg_component_info = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.JQUANT_TBL*, i8* }
%struct.jpeg_marker_struct = type { %struct.jpeg_marker_struct*, i8, i32, i32, i8* }
%struct.jpeg_decomp_master = type opaque
%struct.jpeg_d_main_controller = type opaque
%struct.jpeg_d_coef_controller = type opaque
%struct.jpeg_d_post_controller = type opaque
%struct.jpeg_input_controller = type opaque
%struct.jpeg_marker_reader = type opaque
%struct.jpeg_entropy_decoder = type opaque
%struct.jpeg_inverse_dct = type opaque
%struct.jpeg_upsampler = type opaque
%struct.jpeg_color_deconverter = type opaque
%struct.jpeg_color_quantizer = type opaque
%struct._cass_vec_t = type { float, i32, %union.anon.33 }
%union.anon.33 = type { [1 x i32] }
%struct.box_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.box_set_t = type { i32, i32, %struct.box_t** }
%struct.img_map_t = type { i32, i32, i32, i32, i8**, %struct.box_set_t*, i32*, [3 x [3 x float*]] }
%struct.RegionPair = type { i32, i32, i32 }

@.str.1 = private unnamed_addr constant [7 x i8] c"Error:\00", align 1
@path = internal global [8192 x i8] zeroinitializer, align 16
@.str.2 = private unnamed_addr constant [13 x i8] c"data != NULL\00", align 1
@.str.3 = private unnamed_addr constant [84 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/benchmark/ferret-pthreads.c\00", align 1
@__PRETTY_FUNCTION__.file_helper = private unnamed_addr constant [30 x i8] c"int file_helper(const char *)\00", align 1
@.str.4 = private unnamed_addr constant [7 x i8] c"r == 0\00", align 1
@cnt_enqueue = internal unnamed_addr global i32 0, align 4
@q_load_seg = internal global %struct.queue zeroinitializer, align 8
@.str.6 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"load != NULL\00", align 1
@__PRETTY_FUNCTION__.t_seg = private unnamed_addr constant [20 x i8] c"void *t_seg(void *)\00", align 1
@q_seg_extract = internal global %struct.queue zeroinitializer, align 8
@.str.8 = private unnamed_addr constant [12 x i8] c"seg != NULL\00", align 1
@__PRETTY_FUNCTION__.t_extract = private unnamed_addr constant [24 x i8] c"void *t_extract(void *)\00", align 1
@q_extract_vec = internal global %struct.queue zeroinitializer, align 8
@.str.9 = private unnamed_addr constant [16 x i8] c"extract != NULL\00", align 1
@__PRETTY_FUNCTION__.t_vec = private unnamed_addr constant [20 x i8] c"void *t_vec(void *)\00", align 1
@vec_dist_id = internal unnamed_addr global i32 0, align 4
@vecset_dist_id = internal unnamed_addr global i32 0, align 4
@top_K = internal unnamed_addr global i32 10, align 4
@table = internal unnamed_addr global %struct._cass_table* null, align 8
@q_vec_rank = internal global %struct.queue zeroinitializer, align 8
@.str = private unnamed_addr constant [12 x i8] c"-L 8 - T 20\00", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"vec != NULL\00", align 1
@__PRETTY_FUNCTION__.t_rank = private unnamed_addr constant [21 x i8] c"void *t_rank(void *)\00", align 1
@query_table = internal unnamed_addr global %struct._cass_table* null, align 8
@q_rank_out = internal global %struct.queue zeroinitializer, align 8
@.str.11 = private unnamed_addr constant [13 x i8] c"rank != NULL\00", align 1
@__PRETTY_FUNCTION__.t_out = private unnamed_addr constant [20 x i8] c"void *t_out(void *)\00", align 1
@fout = internal unnamed_addr global %struct._IO_FILE* null, align 8
@.str.13 = private unnamed_addr constant [12 x i8] c"obj != NULL\00", align 1
@.str.14 = private unnamed_addr constant [7 x i8] c"\09%s:%g\00", align 1
@cnt_dequeue = internal unnamed_addr global i32 0, align 4
@stderr = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.16 = private unnamed_addr constant [9 x i8] c"(%d,%d)\0A\00", align 1
@.str.17 = private unnamed_addr constant [27 x i8] c"cnt_enqueue == cnt_dequeue\00", align 1
@.str.19 = private unnamed_addr constant [61 x i8] c"%s <database> <table> <query dir> <top K> <depth> <n> <out>\0A\00", align 1
@db_dir = internal unnamed_addr global i8* null, align 8
@table_name = internal unnamed_addr global i8* null, align 8
@query_dir = internal unnamed_addr global i8* null, align 8
@DEPTH = internal unnamed_addr global i32 25, align 4
@NTHREAD_SEG = internal unnamed_addr global i32 1, align 4
@NTHREAD_EXTRACT = internal unnamed_addr global i32 1, align 4
@NTHREAD_VEC = internal unnamed_addr global i32 1, align 4
@NTHREAD_RANK = internal unnamed_addr global i32 1, align 4
@output_path = internal unnamed_addr global i8* null, align 8
@__PRETTY_FUNCTION__.main = private unnamed_addr constant [23 x i8] c"int main(int, char **)\00", align 1
@env = internal unnamed_addr global %struct._cass_env_t* null, align 8
@.str.22 = private unnamed_addr constant [11 x i8] c"ERROR: %s\0A\00", align 1
@.str.24 = private unnamed_addr constant [17 x i8] c"vec_dist_id >= 0\00", align 1
@.str.26 = private unnamed_addr constant [20 x i8] c"vecset_dist_id >= 0\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"QUERY TIME\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"pool!=NULL\00", align 1
@.str.1.29 = private unnamed_addr constant [68 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/tpool.c\00", align 1
@__PRETTY_FUNCTION__.tpool_destroy = private unnamed_addr constant [30 x i8] c"void tpool_destroy(tpool_t *)\00", align 1
@.str.2.30 = private unnamed_addr constant [32 x i8] c"pool->state!=POOL_STATE_RUNNING\00", align 1
@__PRETTY_FUNCTION__.tpool_join = private unnamed_addr constant [35 x i8] c"int tpool_join(tpool_t *, void **)\00", align 1
@.str.3.33 = private unnamed_addr constant [32 x i8] c"pool->state==POOL_STATE_RUNNING\00", align 1
@.str.36 = private unnamed_addr constant [7 x i8] c"__cass\00", align 1
@.str.1.37 = private unnamed_addr constant [4 x i8] c"env\00", align 1
@.str.3.39 = private unnamed_addr constant [10 x i8] c"t != NULL\00", align 1
@.str.4.40 = private unnamed_addr constant [66 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/env.c\00", align 1
@__PRETTY_FUNCTION__.cass_env_open = private unnamed_addr constant [51 x i8] c"int cass_env_open(cass_env_t **, char *, uint32_t)\00", align 1
@.str.17.43 = private unnamed_addr constant [19 x i8] c"table->cfg != NULL\00", align 1
@__PRETTY_FUNCTION__.__cass_table_ref = private unnamed_addr constant [37 x i8] c"int __cass_table_ref(cass_table_t *)\00", align 1
@.str.19.45 = private unnamed_addr constant [19 x i8] c"table->map != NULL\00", align 1
@.str.20.46 = private unnamed_addr constant [31 x i8] c"(table->children).data != NULL\00", align 1
@.str.70 = private unnamed_addr constant [20 x i8] c"(*reg).data != NULL\00", align 1
@.str.1.71 = private unnamed_addr constant [71 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/cass_reg.c\00", align 1
@__PRETTY_FUNCTION__.cass_reg_init_size = private unnamed_addr constant [50 x i8] c"int cass_reg_init_size(cass_reg_t *, cass_size_t)\00", align 1
@__PRETTY_FUNCTION__.cass_reg_add = private unnamed_addr constant [53 x i8] c"int cass_reg_add(cass_reg_t *, const char *, void *)\00", align 1
@.str.84 = private unnamed_addr constant [17 x i8] c"CASS_ERR_UNKNOWN\00", align 1
@.str.1.85 = private unnamed_addr constant [18 x i8] c"CASS_ERR_OUTOFMEM\00", align 1
@.str.2.86 = private unnamed_addr constant [22 x i8] c"CASS_ERR_MALFORMATVEC\00", align 1
@.str.3.87 = private unnamed_addr constant [19 x i8] c"CASS_ERR_PARAMETER\00", align 1
@.str.4.88 = private unnamed_addr constant [12 x i8] c"CASS_ERR_IO\00", align 1
@.str.5.89 = private unnamed_addr constant [19 x i8] c"CASS_ERR_CORRUPTED\00", align 1
@.str.6.90 = private unnamed_addr constant [3 x i8] c"-1\00", align 1
@.str.7.91 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.124 = private unnamed_addr constant [11 x i8] c"ds->loaded\00", align 1
@.str.1.125 = private unnamed_addr constant [70 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/dataset.c\00", align 1
@__PRETTY_FUNCTION__.cass_dataset_merge = private unnamed_addr constant [129 x i8] c"int cass_dataset_merge(cass_dataset_t *, const cass_dataset_t *, cass_vecset_id_t, cass_vecset_id_t, cass_dataset_map_t, void *)\00", align 1
@.str.2.126 = private unnamed_addr constant [12 x i8] c"src->loaded\00", align 1
@.str.3.127 = private unnamed_addr constant [33 x i8] c"src->flags & CASS_DATASET_VECSET\00", align 1
@.str.4.134 = private unnamed_addr constant [12 x i8] c"!ds->loaded\00", align 1
@__PRETTY_FUNCTION__.cass_dataset_load = private unnamed_addr constant [70 x i8] c"int cass_dataset_load(cass_dataset_t *, CASS_FILE *, cass_vec_type_t)\00", align 1
@.str.5.135 = private unnamed_addr constant [16 x i8] c"ds->vec == NULL\00", align 1
@.str.6.136 = private unnamed_addr constant [19 x i8] c"ds->vecset == NULL\00", align 1
@__PRETTY_FUNCTION__.cass_dataset_dump = private unnamed_addr constant [53 x i8] c"int cass_dataset_dump(cass_dataset_t *, CASS_FILE *)\00", align 1
@.str.6.142 = private unnamed_addr constant [14 x i8] c"table != NULL\00", align 1
@.str.2.143 = private unnamed_addr constant [68 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/table.c\00", align 1
@__PRETTY_FUNCTION__.cass_table_free = private unnamed_addr constant [36 x i8] c"int cass_table_free(cass_table_t *)\00", align 1
@.str.7.144 = private unnamed_addr constant [14 x i8] c"!table->dirty\00", align 1
@.str.3.146 = private unnamed_addr constant [32 x i8] c"(table->child_ids).data != NULL\00", align 1
@__PRETTY_FUNCTION__.cass_table_restore = private unnamed_addr constant [67 x i8] c"int cass_table_restore(cass_table_t **, cass_env_t *, CASS_FILE *)\00", align 1
@.str.8.153 = private unnamed_addr constant [19 x i8] c"table->opr != NULL\00", align 1
@.str.23.181 = private unnamed_addr constant [32 x i8] c"table->opr->batch_query != NULL\00", align 1
@__PRETTY_FUNCTION__.cass_table_query = private unnamed_addr constant [70 x i8] c"int cass_table_query(cass_table_t *, cass_query_t *, cass_result_t *)\00", align 1
@cass_vecset_dist_class_reg = internal global %struct.cass_reg_t zeroinitializer, align 8
@cass_vec_dist_class_reg = internal global %struct.cass_reg_t zeroinitializer, align 8
@cass_table_opr_reg = internal global %struct.cass_reg_t zeroinitializer, align 8
@.str.1.194 = private unnamed_addr constant [66 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/raw.c\00", align 1
@__PRETTY_FUNCTION__.raw_dump = private unnamed_addr constant [29 x i8] c"int raw_dump(cass_table_t *)\00", align 1
@.str.3.196 = private unnamed_addr constant [15 x i8] c"!table->loaded\00", align 1
@__PRETTY_FUNCTION__.raw_load = private unnamed_addr constant [29 x i8] c"int raw_load(cass_table_t *)\00", align 1
@opr_raw = internal global { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.200, i32 0, i32 0), i32 513, i32 4, i32 -1, i32 -1, i32 -1, %struct._cass_vecset_cfg_t* (i8*)* null, i8* (%struct._cass_table.91*, i8*)* @raw_tune, i32 (%struct._cass_table.91*, i8*)* @raw_init_private, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)* @raw_batch_insert, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)* @raw_query, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)* null, i32 (%struct._cass_table.91*)* @raw_load, i32 (%struct._cass_table.91*)* @raw_release, i32 (%struct._cass_table.91*, %struct._IO_FILE*)* @raw_checkpoint_private, i32 (%struct._cass_table.91*, %struct._IO_FILE*)* @raw_restore_private, i32 (%struct._cass_table.91*)* @raw_free_private, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* null }, align 8
@.str.5.200 = private unnamed_addr constant [4 x i8] c"raw\00", align 1
@.str.6.201 = private unnamed_addr constant [3 x i8] c"-R\00", align 1
@__PRETTY_FUNCTION__.raw_query = private unnamed_addr constant [63 x i8] c"int raw_query(cass_table_t *, cass_query_t *, cass_result_t *)\00", align 1
@.str.8.203 = private unnamed_addr constant [40 x i8] c"(query->flags & CASS_RESULT_LISTS) == 0\00", align 1
@.str.10.205 = private unnamed_addr constant [20 x i8] c"vecset_dist != NULL\00", align 1
@.str.12.207 = private unnamed_addr constant [38 x i8] c"User allocated bitmap not supported.\0A\00", align 1
@.str.14.209 = private unnamed_addr constant [35 x i8] c"result->u.list.size >= query->topk\00", align 1
@.str.213 = private unnamed_addr constant [11 x i8] c"%s:%d: %s:\00", align 1
@.str.1.216 = private unnamed_addr constant [9 x i8] c"%s/%s.%s\00", align 1
@.str.3.218 = private unnamed_addr constant [67 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/util.c\00", align 1
@__PRETTY_FUNCTION__.mkpath = private unnamed_addr constant [61 x i8] c"int mkpath(char *, const char *, const char *, const char *)\00", align 1
@.str.4.234 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.5.237 = private unnamed_addr constant [30 x i8] c"(result->u.list).data != NULL\00", align 1
@__PRETTY_FUNCTION__.cass_result_alloc_list = private unnamed_addr constant [70 x i8] c"int cass_result_alloc_list(cass_result_t *, cass_size_t, cass_size_t)\00", align 1
@.str.13.247 = private unnamed_addr constant [40 x i8] c"cass_result_free: unsupported formate.\0A\00", align 1
@.str.14.250 = private unnamed_addr constant [40 x i8] c"(src->flags & CASS_RESULT_BITMAPS) == 0\00", align 1
@__PRETTY_FUNCTION__.cass_result_merge_lists = private unnamed_addr constant [83 x i8] c"cass_result_t *cass_result_merge_lists(cass_result_t *, cass_dataset_t *, int32_t)\00", align 1
@.str.15.251 = private unnamed_addr constant [39 x i8] c"(src->flags & CASS_RESULT_BITMAP) == 0\00", align 1
@.str.16.252 = private unnamed_addr constant [37 x i8] c"(src->flags & CASS_RESULT_LIST) == 0\00", align 1
@.str.17.253 = private unnamed_addr constant [31 x i8] c"src->flags & CASS_RESULT_LISTS\00", align 1
@.str.3.268 = private unnamed_addr constant [17 x i8] c"item < map->size\00", align 1
@.str.4.269 = private unnamed_addr constant [69 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/bitmap.c\00", align 1
@__PRETTY_FUNCTION__.bitmap_insert = private unnamed_addr constant [40 x i8] c"int bitmap_insert(bitmap_t *, uint32_t)\00", align 1
@.str.276 = private unnamed_addr constant [27 x i8] c"(map->vtable).data != NULL\00", align 1
@.str.1.277 = private unnamed_addr constant [66 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/map.c\00", align 1
@__PRETTY_FUNCTION__.cass_map_private_init = private unnamed_addr constant [50 x i8] c"int cass_map_private_init(cass_map_t *, uint32_t)\00", align 1
@.str.2.278 = private unnamed_addr constant [28 x i8] c"map->magic == MAP_MAGIC_SIG\00", align 1
@.str.3.279 = private unnamed_addr constant [30 x i8] c"(map->table_ids).data != NULL\00", align 1
@__PRETTY_FUNCTION__.cass_map_insert = private unnamed_addr constant [62 x i8] c"int cass_map_insert(cass_map_t *, cass_vecset_id_t *, char *)\00", align 1
@.str.4.280 = private unnamed_addr constant [12 x i8] c"!map->dirty\00", align 1
@__PRETTY_FUNCTION__.cass_map_release = private unnamed_addr constant [35 x i8] c"int cass_map_release(cass_map_t *)\00", align 1
@.str.14.283 = private unnamed_addr constant [13 x i8] c"!map->loaded\00", align 1
@__PRETTY_FUNCTION__.cass_map_load_private = private unnamed_addr constant [40 x i8] c"int cass_map_load_private(cass_map_t *)\00", align 1
@.str.15.284 = private unnamed_addr constant [10 x i8] c"%s/%s.map\00", align 1
@.str.17.287 = private unnamed_addr constant [10 x i8] c"vid == ix\00", align 1
@local_buf = internal global [8192 x i8] zeroinitializer, align 16
@.str.5.291 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@__PRETTY_FUNCTION__.cass_map_restore = private unnamed_addr constant [63 x i8] c"int cass_map_restore(cass_map_t **, cass_env_t *, CASS_FILE *)\00", align 1
@.str.13.306 = private unnamed_addr constant [12 x i8] c"map != NULL\00", align 1
@__PRETTY_FUNCTION__.cass_map_free = private unnamed_addr constant [32 x i8] c"int cass_map_free(cass_map_t *)\00", align 1
@.str.320 = private unnamed_addr constant [18 x i8] c"%s: %.3f seconds\0A\00", align 1
@.str.321 = private unnamed_addr constant [26 x i8] c"table->parent_cfg != NULL\00", align 1
@.str.1.322 = private unnamed_addr constant [70 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/lsh/LSH.c\00", align 1
@__PRETTY_FUNCTION__.LSH_init_private = private unnamed_addr constant [51 x i8] c"int LSH_init_private(cass_table_t *, const char *)\00", align 1
@.str.2.323 = private unnamed_addr constant [3 x i8] c"-M\00", align 1
@.str.3.324 = private unnamed_addr constant [26 x i8] c"M <= sizeof(uint32_t) * 8\00", align 1
@.str.4.325 = private unnamed_addr constant [3 x i8] c"-L\00", align 1
@.str.5.326 = private unnamed_addr constant [3 x i8] c"-H\00", align 1
@.str.6.327 = private unnamed_addr constant [3 x i8] c"-w\00", align 1
@.str.7.328 = private unnamed_addr constant [3 x i8] c"-W\00", align 1
@.str.8.329 = private unnamed_addr constant [8 x i8] c"-recall\00", align 1
@.str.9.330 = private unnamed_addr constant [9 x i8] c"__func__\00", align 1
@.str.10.331 = private unnamed_addr constant [27 x i8] c"-W and -recall conflicts.\0A\00", align 1
@gsl_rng_default = external local_unnamed_addr global %struct.gsl_rng_type*, align 8
@.str.11.332 = private unnamed_addr constant [8 x i8] c"-d_step\00", align 1
@.str.12.333 = private unnamed_addr constant [7 x i8] c"-T_max\00", align 1
@.str.13.334 = private unnamed_addr constant [7 x i8] c"-d_min\00", align 1
@.str.14.335 = private unnamed_addr constant [7 x i8] c"-d_max\00", align 1
@.str.25.336 = private unnamed_addr constant [18 x i8] c"lsh->hash != NULL\00", align 1
@__PRETTY_FUNCTION__.LSH_dump = private unnamed_addr constant [29 x i8] c"int LSH_dump(cass_table_t *)\00", align 1
@.str.26.337 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.27.339 = private unnamed_addr constant [13 x i8] c"fout != NULL\00", align 1
@.str.52 = private unnamed_addr constant [49 x i8] c"(ohash->bucket[hash % ohash->size]).data != NULL\00", align 1
@.str.53 = private unnamed_addr constant [76 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/include/cass_hash.h\00", align 1
@__PRETTY_FUNCTION__.ohash_insert = private unnamed_addr constant [39 x i8] c"void ohash_insert(ohash_t *, int, int)\00", align 1
@.str.54 = private unnamed_addr constant [48 x i8] c"len <= (ohash->bucket[hash % ohash->size]).size\00", align 1
@.str.15.343 = private unnamed_addr constant [9 x i8] c"ret == 5\00", align 1
@__PRETTY_FUNCTION__.LSH_restore_private = private unnamed_addr constant [53 x i8] c"int LSH_restore_private(cass_table_t *, CASS_FILE *)\00", align 1
@.str.16.345 = private unnamed_addr constant [14 x i8] c"ret == lsh->L\00", align 1
@.str.17.346 = private unnamed_addr constant [17 x i8] c"ret == L * M * D\00", align 1
@.str.18.347 = private unnamed_addr constant [13 x i8] c"ret == L * M\00", align 1
@.str.22.357 = private unnamed_addr constant [18 x i8] c"lsh->hash == NULL\00", align 1
@__PRETTY_FUNCTION__.LSH_load = private unnamed_addr constant [29 x i8] c"int LSH_load(cass_table_t *)\00", align 1
@.str.23.358 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.56 = private unnamed_addr constant [22 x i8] c"ohash->bucket != NULL\00", align 1
@__PRETTY_FUNCTION__.ohash_init = private unnamed_addr constant [40 x i8] c"void ohash_init(ohash_t *, cass_size_t)\00", align 1
@.str.29 = private unnamed_addr constant [14 x i8] c"table->loaded\00", align 1
@__PRETTY_FUNCTION__.__LSH_query = private unnamed_addr constant [65 x i8] c"int __LSH_query(cass_table_t *, cass_query_t *, cass_result_t *)\00", align 1
@.str.30 = private unnamed_addr constant [17 x i8] c"vec_dist != NULL\00", align 1
@.str.31 = private unnamed_addr constant [43 x i8] c"LSH only works for L2 distance for float.\0A\00", align 1
@.str.32 = private unnamed_addr constant [28 x i8] c"LSH query requires parent.\0A\00", align 1
@.str.33 = private unnamed_addr constant [15 x i8] c"parent != NULL\00", align 1
@.str.34 = private unnamed_addr constant [41 x i8] c"LSH query requires parent to be loaded.\0A\00", align 1
@.str.35 = private unnamed_addr constant [30 x i8] c"LSH only works on CASS_DATA.\0A\00", align 1
@.str.36.360 = private unnamed_addr constant [33 x i8] c"LSH only works for KNN queries.\0A\00", align 1
@.str.37 = private unnamed_addr constant [3 x i8] c"-T\00", align 1
@.str.38 = private unnamed_addr constant [42 x i8] c"(query->flags & CASS_RESULT_BITMAPS) == 0\00", align 1
@.str.39 = private unnamed_addr constant [41 x i8] c"(query->flags & CASS_RESULT_BITMAP) == 0\00", align 1
@.str.40 = private unnamed_addr constant [39 x i8] c"(query->flags & CASS_RESULT_LIST) == 0\00", align 1
@.str.41 = private unnamed_addr constant [33 x i8] c"query->flags & CASS_RESULT_LISTS\00", align 1
@.str.42 = private unnamed_addr constant [25 x i8] c"query->candidate == NULL\00", align 1
@.str.43 = private unnamed_addr constant [43 x i8] c"result->u.lists.len >= vecset->num_regions\00", align 1
@.str.44 = private unnamed_addr constant [31 x i8] c"(result->u.lists).data != NULL\00", align 1
@.str.45 = private unnamed_addr constant [44 x i8] c"result->u.lists.data[i].size >= query->topk\00", align 1
@.str.46 = private unnamed_addr constant [39 x i8] c"(result->u.lists.data[i]).data != NULL\00", align 1
@__PRETTY_FUNCTION__.__LSH_batch_query = private unnamed_addr constant [83 x i8] c"int __LSH_batch_query(cass_table_t *, uint32_t, cass_query_t **, cass_result_t **)\00", align 1
@.str.47 = private unnamed_addr constant [44 x i8] c"result->u.lists.data[j].size >= query->topk\00", align 1
@.str.48 = private unnamed_addr constant [39 x i8] c"(result->u.lists.data[j]).data != NULL\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"k == vec_count\00", align 1
@.str.50 = private unnamed_addr constant [4 x i8] c"-ca\00", align 1
@opr_lsh = internal global { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.51, i32 0, i32 0), i32 2, i32 -1, i32 2, i32 -1, i32 16, %struct._cass_vecset_cfg_t* (i8*)* null, i8* (%struct._cass_table.157*, i8*)* null, i32 (%struct._cass_table.157*, i8*)* @LSH_init_private, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)* @LSH_batch_insert, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)* @__LSH_query, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)* @__LSH_batch_query, i32 (%struct._cass_table.157*)* @LSH_load, i32 (%struct._cass_table.157*)* @LSH_release, i32 (%struct._cass_table.157*, %struct._IO_FILE*)* @LSH_checkpoint_private, i32 (%struct._cass_table.157*, %struct._IO_FILE*)* @LSH_restore_private, i32 (%struct._cass_table.157*)* @LSH_free_private, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* null }, align 8
@.str.51 = private unnamed_addr constant [4 x i8] c"lsh\00", align 1
@.str.365 = private unnamed_addr constant [18 x i8] c"ptb_score != NULL\00", align 1
@.str.1.366 = private unnamed_addr constant [73 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/lsh/recall.c\00", align 1
@__PRETTY_FUNCTION__.LSH_recall_init = private unnamed_addr constant [77 x i8] c"int LSH_recall_init(LSH_recall_t *, int, float, float, int, int, int, float)\00", align 1
@.str.2.367 = private unnamed_addr constant [16 x i8] c"ptb_set != NULL\00", align 1
@.str.3.368 = private unnamed_addr constant [6 x i8] c"l > 0\00", align 1
@.str.4.381 = private unnamed_addr constant [25 x i8] c"___size == sizeof(float)\00", align 1
@__PRETTY_FUNCTION__.LSH_recall_load = private unnamed_addr constant [49 x i8] c"int LSH_recall_load(LSH_recall_t *, CASS_FILE *)\00", align 1
@.str.5.382 = private unnamed_addr constant [20 x i8] c"row == recall->T +1\00", align 1
@.str.6.383 = private unnamed_addr constant [22 x i8] c"col == recall->d_step\00", align 1
@chunk_cnt = internal unnamed_addr constant [257 x i32] [i32 0, i32 1, i32 1, i32 2, i32 1, i32 2, i32 2, i32 3, i32 1, i32 2, i32 2, i32 3, i32 2, i32 3, i32 3, i32 4, i32 1, i32 2, i32 2, i32 3, i32 2, i32 3, i32 3, i32 4, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 1, i32 2, i32 2, i32 3, i32 2, i32 3, i32 3, i32 4, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 1, i32 2, i32 2, i32 3, i32 2, i32 3, i32 3, i32 4, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 4, i32 5, i32 5, i32 6, i32 5, i32 6, i32 6, i32 7, i32 1, i32 2, i32 2, i32 3, i32 2, i32 3, i32 3, i32 4, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 4, i32 5, i32 5, i32 6, i32 5, i32 6, i32 6, i32 7, i32 2, i32 3, i32 3, i32 4, i32 3, i32 4, i32 4, i32 5, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 4, i32 5, i32 5, i32 6, i32 5, i32 6, i32 6, i32 7, i32 3, i32 4, i32 4, i32 5, i32 4, i32 5, i32 5, i32 6, i32 4, i32 5, i32 5, i32 6, i32 5, i32 6, i32 6, i32 7, i32 4, i32 5, i32 5, i32 6, i32 5, i32 6, i32 6, i32 7, i32 5, i32 6, i32 6, i32 7, i32 6, i32 7, i32 7, i32 8, i32 0], align 16
@.str.8.385 = private unnamed_addr constant [29 x i8] c"ds1->vec_dim == ds2->vec_dim\00", align 1
@.str.9.386 = private unnamed_addr constant [67 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/dist.c\00", align 1
@__PRETTY_FUNCTION__.sdist_emd = private unnamed_addr constant [121 x i8] c"cass_dist_t sdist_emd(cass_dataset_t *, cass_vecset_id_t, cass_dataset_t *, cass_vecset_id_t, cass_vec_dist_t *, void *)\00", align 1
@__PRETTY_FUNCTION__.sdist_myemd = private unnamed_addr constant [123 x i8] c"cass_dist_t sdist_myemd(cass_dataset_t *, cass_vecset_id_t, cass_dataset_t *, cass_vecset_id_t, cass_vec_dist_t *, void *)\00", align 1
@vec_dist_trivial = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.389, i32 0, i32 0), i32 -1, i32 2, float (i32, i8*, i8*, i8*)* @dist_trivial_dist, i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_trivial_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_trivial_restore, void (i8*)* @dist_simple_free }, align 8
@.str.389 = private unnamed_addr constant [8 x i8] c"trivial\00", align 1
@.str.12.390 = private unnamed_addr constant [10 x i8] c"NAME:\09%s\0A\00", align 1
@.str.13.391 = private unnamed_addr constant [11 x i8] c"CLASS:\09%s\0A\00", align 1
@vec_dist_L1_int = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.394, i32 0, i32 0), i32 1, i32 8, float (i32, i8*, i8*, i8*)* bitcast (float (i32, i32*, i32*)* @__dist_L1_int32 to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_L1_int_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_L1_int_restore, void (i8*)* @dist_simple_free }, align 8
@.str.1.394 = private unnamed_addr constant [7 x i8] c"L1_int\00", align 1
@vec_dist_L2_int = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2.397, i32 0, i32 0), i32 1, i32 16, float (i32, i8*, i8*, i8*)* bitcast (float (i32, i32*, i32*)* @__dist_L2_int32 to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_L2_int_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_L2_int_restore, void (i8*)* @dist_simple_free }, align 8
@.str.2.397 = private unnamed_addr constant [7 x i8] c"L2_int\00", align 1
@vec_dist_L1_float = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.3.400, i32 0, i32 0), i32 2, i32 8, float (i32, i8*, i8*, i8*)* bitcast (float (i32, float*, float*)* @dist_L1_float to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_L1_float_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_L1_float_restore, void (i8*)* @dist_simple_free }, align 8
@.str.3.400 = private unnamed_addr constant [9 x i8] c"L1_float\00", align 1
@vec_dist_L2_float = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.4.403, i32 0, i32 0), i32 2, i32 8, float (i32, i8*, i8*, i8*)* bitcast (float (i32, float*, float*)* @dist_L2_float to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_L2_float_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_L2_float_restore, void (i8*)* @dist_simple_free }, align 8
@.str.4.403 = private unnamed_addr constant [9 x i8] c"L2_float\00", align 1
@vec_dist_cos_float = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.5.406, i32 0, i32 0), i32 2, i32 128, float (i32, i8*, i8*, i8*)* bitcast (float (i32, float*, float*)* @dist_cos_float to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_cos_float_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_cos_float_restore, void (i8*)* @dist_simple_free }, align 8
@.str.5.406 = private unnamed_addr constant [7 x i8] c"cosine\00", align 1
@vec_dist_hamming = internal global %struct._cass_vec_dist_class { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6.409, i32 0, i32 0), i32 4, i32 64, float (i32, i8*, i8*, i8*)* bitcast (float (i32, i8*, i8*)* @__dist_hamming to float (i32, i8*, i8*, i8*)*), i32 (i8*, %struct._IO_FILE*)* @dist_simple_describe, i32 (i8**, i8*)* @dist_hamming_construct, i32 (i8*, %struct._IO_FILE*)* @dist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @dist_hamming_restore, void (i8*)* @dist_simple_free }, align 8
@.str.6.409 = private unnamed_addr constant [8 x i8] c"hamming\00", align 1
@vecset_dist_trivial = internal global %struct._cass_vecset_dist_class { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.389, i32 0, i32 0), i32 -1, i32 1, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)* @sdist_trivial, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_describe, i32 (i8**, i8*)* @sdist_trivial_construct, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @sdist_trivial_restore, void (i8*)* @sdist_simple_free }, align 8
@.str.14.412 = private unnamed_addr constant [16 x i8] c"CLASS:\09trivial\0A\00", align 1
@vecset_dist_single = internal global %struct._cass_vecset_dist_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.415, i32 0, i32 0), i32 -1, i32 2, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)* @sdist_single, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_describe, i32 (i8**, i8*)* @sdist_single_construct, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @sdist_single_restore, void (i8*)* @sdist_simple_free }, align 8
@.str.7.415 = private unnamed_addr constant [7 x i8] c"single\00", align 1
@vecset_dist_emd = internal global %struct._cass_vecset_dist_class { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.418, i32 0, i32 0), i32 -1, i32 4, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)* @sdist_emd, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_describe, i32 (i8**, i8*)* @sdist_emd_construct, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @sdist_emd_restore, void (i8*)* @sdist_simple_free }, align 8
@.str.10.418 = private unnamed_addr constant [4 x i8] c"emd\00", align 1
@vecset_dist_myemd = internal global %struct._cass_vecset_dist_class { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11.421, i32 0, i32 0), i32 -1, i32 4, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)* @sdist_myemd, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_describe, i32 (i8**, i8*)* @sdist_myemd_construct, i32 (i8*, %struct._IO_FILE*)* @sdist_simple_checkpoint, i32 (i8**, %struct._IO_FILE*)* @sdist_myemd_restore, void (i8*)* @sdist_simple_free }, align 8
@.str.11.421 = private unnamed_addr constant [6 x i8] c"myemd\00", align 1
@.str.15.430 = private unnamed_addr constant [19 x i8] c"cnt == nrow + ncol\00", align 1
@.str.7.431 = private unnamed_addr constant [65 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/tp.c\00", align 1
@__PRETTY_FUNCTION__.tp_update = private unnamed_addr constant [73 x i8] c"int tp_update(int, int, float **, struct sol **, struct U *, struct U *)\00", align 1
@.str.16.432 = private unnamed_addr constant [10 x i8] c"min->flow\00", align 1
@.str.6.433 = private unnamed_addr constant [12 x i8] c"m1_idx >= 0\00", align 1
@__PRETTY_FUNCTION__.tp_init_vogel = private unnamed_addr constant [73 x i8] c"void tp_init_vogel(int, float *, int, float *, float **, struct sol ***)\00", align 1
@.str.8.434 = private unnamed_addr constant [10 x i8] c"mrow >= 0\00", align 1
@.str.9.435 = private unnamed_addr constant [10 x i8] c"mcol >= 0\00", align 1
@.str.10.436 = private unnamed_addr constant [23 x i8] c"!SET_TEST(r_del, mrow)\00", align 1
@.str.11.437 = private unnamed_addr constant [23 x i8] c"!SET_TEST(c_del, mcol)\00", align 1
@.str.12.438 = private unnamed_addr constant [7 x i8] c"lc > 1\00", align 1
@.str.13.439 = private unnamed_addr constant [8 x i8] c"lc == 1\00", align 1
@.str.14.440 = private unnamed_addr constant [8 x i8] c"lr == 1\00", align 1
@.str.443 = private unnamed_addr constant [68 x i8] c"MALLOC ERROR: In function `%s': could not allocate memory for `%s'\0A\00", align 1
@.str.1.444 = private unnamed_addr constant [13 x i8] c"__FUNCTION__\00", align 1
@.str.2.445 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@.str.3.446 = private unnamed_addr constant [6 x i8] c"D->T1\00", align 1
@.str.4.447 = private unnamed_addr constant [6 x i8] c"D->T2\00", align 1
@.str.5.448 = private unnamed_addr constant [6 x i8] c"D->a1\00", align 1
@.str.6.449 = private unnamed_addr constant [6 x i8] c"D->a2\00", align 1
@.str.1.461 = private unnamed_addr constant [9 x i8] c"ret == 1\00", align 1
@.str.2.462 = private unnamed_addr constant [67 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/hash.c\00", align 1
@__PRETTY_FUNCTION__.ohash_init_with_stream = private unnamed_addr constant [51 x i8] c"int ohash_init_with_stream(ohash_t *, CASS_FILE *)\00", align 1
@.str.3.463 = private unnamed_addr constant [32 x i8] c"(ohash->bucket[i]).data != NULL\00", align 1
@.str.4.465 = private unnamed_addr constant [13 x i8] c"ret == bsize\00", align 1
@.str.5.466 = private unnamed_addr constant [33 x i8] c"bsize <= (ohash->bucket[i]).size\00", align 1
@.str.1.490 = private unnamed_addr constant [69 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/matrix.c\00", align 1
@.str.4.493 = private unnamed_addr constant [12 x i8] c"idx != NULL\00", align 1
@__PRETTY_FUNCTION__.__array2matrix = private unnamed_addr constant [69 x i8] c"void **__array2matrix(cass_size_t, cass_size_t, cass_size_t, void *)\00", align 1
@.str.5.494 = private unnamed_addr constant [15 x i8] c"idx[0] != NULL\00", align 1
@__PRETTY_FUNCTION__.__matrix_alloc = private unnamed_addr constant [61 x i8] c"void **__matrix_alloc(cass_size_t, cass_size_t, cass_size_t)\00", align 1
@.str.6.497 = private unnamed_addr constant [38 x i8] c"idx[row] - idx[0] == row * col * size\00", align 1
@.str.7.503 = private unnamed_addr constant [9 x i8] c"ret == 3\00", align 1
@__PRETTY_FUNCTION__.matrix_load_stream = private unnamed_addr constant [86 x i8] c"int matrix_load_stream(FILE *, cass_size_t *, cass_size_t *, cass_size_t *, void ***)\00", align 1
@.str.8.504 = private unnamed_addr constant [16 x i8] c"_matrix != NULL\00", align 1
@.str.9.506 = private unnamed_addr constant [13 x i8] c"ret == nmemb\00", align 1
@.str.17.509 = private unnamed_addr constant [76 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/include/cass_file.h\00", align 1
@__PRETTY_FUNCTION__.cass_read.510 = private unnamed_addr constant [69 x i8] c"cass_size_t cass_read(void *, cass_size_t, cass_size_t, CASS_FILE *)\00", align 1
@__PRETTY_FUNCTION__.cass_write.515 = private unnamed_addr constant [76 x i8] c"cass_size_t cass_write(const void *, cass_size_t, cass_size_t, CASS_FILE *)\00", align 1
@__PRETTY_FUNCTION__.cass_write_uint32.516 = private unnamed_addr constant [55 x i8] c"int cass_write_uint32(uint32_t *, size_t, CASS_FILE *)\00", align 1
@.str.15.522 = private unnamed_addr constant [15 x i8] c"ret[i] != NULL\00", align 1
@__PRETTY_FUNCTION__.__matrix3_alloc = private unnamed_addr constant [76 x i8] c"void ***__matrix3_alloc(cass_size_t, cass_size_t, cass_size_t, cass_size_t)\00", align 1
@.str.525 = private unnamed_addr constant [19 x i8] c"query->tmp != NULL\00", align 1
@.str.1.526 = private unnamed_addr constant [76 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/lsh/LSH_query.c\00", align 1
@__PRETTY_FUNCTION__.LSH_query_init = private unnamed_addr constant [101 x i8] c"void LSH_query_init(LSH_query_t *, LSH_t *, cass_dataset_t *, cass_size_t, cass_size_t, cass_size_t)\00", align 1
@.str.2.527 = private unnamed_addr constant [20 x i8] c"query->tmp2 != NULL\00", align 1
@.str.3.528 = private unnamed_addr constant [19 x i8] c"query->ptb != NULL\00", align 1
@.str.4.529 = private unnamed_addr constant [12 x i8] c"scr != NULL\00", align 1
@.str.5.530 = private unnamed_addr constant [23 x i8] c"query->ptb_set != NULL\00", align 1
@.str.6.531 = private unnamed_addr constant [23 x i8] c"query->ptb_vec != NULL\00", align 1
@.str.7.532 = private unnamed_addr constant [24 x i8] c"query->ptb_step != NULL\00", align 1
@.str.8.533 = private unnamed_addr constant [20 x i8] c"query->topk != NULL\00", align 1
@.str.9.534 = private unnamed_addr constant [21 x i8] c"query->_topk != NULL\00", align 1
@.str.10.535 = private unnamed_addr constant [17 x i8] c"query->C != NULL\00", align 1
@.str.11.536 = private unnamed_addr constant [17 x i8] c"query->H != NULL\00", align 1
@.str.12.537 = private unnamed_addr constant [17 x i8] c"query->S != NULL\00", align 1
@.str.1.548 = private unnamed_addr constant [82 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/lsh/LSH_query_batch.c\00", align 1
@__PRETTY_FUNCTION__.LSH_query_batch_ca = private unnamed_addr constant [88 x i8] c"void LSH_query_batch_ca(const LSH_query_t *, int, const float **, cass_list_entry_t **)\00", align 1
@.str.2.552 = private unnamed_addr constant [27 x i8] c"(_2scan[tid]).data != NULL\00", align 1
@.str.557 = private unnamed_addr constant [20 x i8] c"(heap).data != NULL\00", align 1
@.str.1.558 = private unnamed_addr constant [74 x i8] c"/home/mok/tool/delta_v2/instrumentation-skeleton/ferret/src/lsh/perturb.c\00", align 1
@__PRETTY_FUNCTION__.gen_perturb_set = private unnamed_addr constant [62 x i8] c"int gen_perturb_set(const ptb_vec_t *, ptb_vec_t *, int, int)\00", align 1
@.str.2.559 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.4.563 = private unnamed_addr constant [32 x i8] c"(vec.set & mapping[j].set) == 0\00", align 1
@__PRETTY_FUNCTION__.map_perturb_vector = private unnamed_addr constant [84 x i8] c"int map_perturb_vector(const ptb_vec_t *, ptb_vec_t *, const ptb_vec_t *, int, int)\00", align 1
@C = internal thread_local unnamed_addr global double** null, align 8
@.str.568 = private unnamed_addr constant [57 x i8] c"emd: Maximum number of iterations has been reached (%d)\0A\00", align 1
@.str.8.569 = private unnamed_addr constant [36 x i8] c"emd: Unexpected error in findLoop!\0A\00", align 1
@.str.9.570 = private unnamed_addr constant [14 x i8] c"emd: findLoop\00", align 1
@.str.6.571 = private unnamed_addr constant [37 x i8] c"emd: Unexpected error in isOptimal.\0A\00", align 1
@.str.7.572 = private unnamed_addr constant [24 x i8] c"emd: error in isOptimal\00", align 1
@.str.2.573 = private unnamed_addr constant [46 x i8] c"emd: Unexpected error in findBasicVariables!\0A\00", align 1
@.str.3.574 = private unnamed_addr constant [52 x i8] c"This typically happens when the EPSILON defined in\0A\00", align 1
@.str.4.575 = private unnamed_addr constant [50 x i8] c"emd.h is not right for the scale of the problem.\0A\00", align 1
@.str.5.576 = private unnamed_addr constant [32 x i8] c"emd: errr in findBasicVariables\00", align 1
@.str.1.577 = private unnamed_addr constant [54 x i8] c"emd: Signature size is limited to %d, n1: %d, n2: %d\0A\00", align 1
@.str.578 = private unnamed_addr constant [14 x i8] c"out of memory\00", align 1
@.str.1.585 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.2.586 = private unnamed_addr constant [15 x i8] c"can't open %s\0A\00", align 1
@dw = internal unnamed_addr constant [14 x float] [float 6.000000e+00, float 3.000000e+00, float 1.500000e+00, float 4.000000e+00, float 2.000000e+00, float 1.000000e+00, float 4.000000e+00, float 2.000000e+00, float 1.000000e+00, float 0x3FC99999A0000000, float 0x3FD99999A0000000, float 0x3FA47AE140000000, float 0x3F7CAC0840000000, float 0x3F7CAC0840000000], align 16
@.str.2.594 = private unnamed_addr constant [17 x i8] c"Error in %s: %s\0A\00", align 1
@image_segment.func_name = internal constant [4 x i8] c"srm\00", align 1
@.str.3.595 = private unnamed_addr constant [22 x i8] c"Insufficient memory !\00", align 1
@str = private unnamed_addr constant [23 x i8] c"PARSEC Benchmark Suite\00"
@0 = private unnamed_addr constant [8 x i8] c"opendir\00"
@1 = private unnamed_addr constant [8 x i8] c"readdir\00"
@2 = private unnamed_addr constant [7 x i8] c"perror\00"
@3 = private unnamed_addr constant [9 x i8] c"closedir\00"
@4 = private unnamed_addr constant [7 x i8] c"strcat\00"
@5 = private unnamed_addr constant [5 x i8] c"stat\00"
@6 = private unnamed_addr constant [7 x i8] c"perror\00"
@7 = private unnamed_addr constant [7 x i8] c"strlen\00"
@8 = private unnamed_addr constant [7 x i8] c"strlen\00"
@9 = private unnamed_addr constant [7 x i8] c"malloc\00"
@10 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@11 = private unnamed_addr constant [7 x i8] c"strdup\00"
@12 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@13 = private unnamed_addr constant [7 x i8] c"strcmp\00"
@14 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@15 = private unnamed_addr constant [7 x i8] c"calloc\00"
@16 = private unnamed_addr constant [5 x i8] c"free\00"
@17 = private unnamed_addr constant [5 x i8] c"free\00"
@18 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@19 = private unnamed_addr constant [7 x i8] c"calloc\00"
@20 = private unnamed_addr constant [5 x i8] c"free\00"
@21 = private unnamed_addr constant [5 x i8] c"free\00"
@22 = private unnamed_addr constant [5 x i8] c"free\00"
@23 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@24 = private unnamed_addr constant [7 x i8] c"calloc\00"
@25 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@26 = private unnamed_addr constant [7 x i8] c"calloc\00"
@27 = private unnamed_addr constant [5 x i8] c"free\00"
@28 = private unnamed_addr constant [5 x i8] c"free\00"
@29 = private unnamed_addr constant [5 x i8] c"free\00"
@30 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@31 = private unnamed_addr constant [6 x i8] c"fputs\00"
@32 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@33 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@34 = private unnamed_addr constant [6 x i8] c"fputc\00"
@35 = private unnamed_addr constant [5 x i8] c"free\00"
@36 = private unnamed_addr constant [5 x i8] c"free\00"
@37 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@38 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@39 = private unnamed_addr constant [5 x i8] c"puts\00"
@40 = private unnamed_addr constant [7 x i8] c"fflush\00"
@41 = private unnamed_addr constant [7 x i8] c"printf\00"
@42 = private unnamed_addr constant [5 x i8] c"atoi\00"
@43 = private unnamed_addr constant [5 x i8] c"atoi\00"
@44 = private unnamed_addr constant [5 x i8] c"atoi\00"
@45 = private unnamed_addr constant [5 x i8] c"atoi\00"
@46 = private unnamed_addr constant [5 x i8] c"atoi\00"
@47 = private unnamed_addr constant [5 x i8] c"atoi\00"
@48 = private unnamed_addr constant [6 x i8] c"fopen\00"
@49 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@50 = private unnamed_addr constant [7 x i8] c"printf\00"
@51 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@52 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@53 = private unnamed_addr constant [7 x i8] c"calloc\00"
@54 = private unnamed_addr constant [7 x i8] c"calloc\00"
@55 = private unnamed_addr constant [7 x i8] c"calloc\00"
@56 = private unnamed_addr constant [7 x i8] c"calloc\00"
@57 = private unnamed_addr constant [7 x i8] c"calloc\00"
@58 = private unnamed_addr constant [7 x i8] c"calloc\00"
@59 = private unnamed_addr constant [5 x i8] c"free\00"
@60 = private unnamed_addr constant [5 x i8] c"free\00"
@61 = private unnamed_addr constant [5 x i8] c"free\00"
@62 = private unnamed_addr constant [5 x i8] c"free\00"
@63 = private unnamed_addr constant [5 x i8] c"free\00"
@64 = private unnamed_addr constant [5 x i8] c"free\00"
@65 = private unnamed_addr constant [7 x i8] c"fclose\00"
@66 = private unnamed_addr constant [7 x i8] c"malloc\00"
@67 = private unnamed_addr constant [7 x i8] c"malloc\00"
@68 = private unnamed_addr constant [5 x i8] c"free\00"
@69 = private unnamed_addr constant [15 x i8] c"pthread_create\00"
@70 = private unnamed_addr constant [5 x i8] c"free\00"
@71 = private unnamed_addr constant [5 x i8] c"free\00"
@72 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@73 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@74 = private unnamed_addr constant [5 x i8] c"free\00"
@75 = private unnamed_addr constant [5 x i8] c"free\00"
@76 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@77 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@78 = private unnamed_addr constant [13 x i8] c"pthread_join\00"
@79 = private unnamed_addr constant [7 x i8] c"calloc\00"
@80 = private unnamed_addr constant [7 x i8] c"strdup\00"
@81 = private unnamed_addr constant [7 x i8] c"strdup\00"
@82 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@83 = private unnamed_addr constant [6 x i8] c"fopen\00"
@84 = private unnamed_addr constant [6 x i8] c"fread\00"
@85 = private unnamed_addr constant [7 x i8] c"calloc\00"
@86 = private unnamed_addr constant [7 x i8] c"fclose\00"
@87 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@88 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@89 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@90 = private unnamed_addr constant [7 x i8] c"malloc\00"
@91 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@92 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@93 = private unnamed_addr constant [8 x i8] c"realloc\00"
@94 = private unnamed_addr constant [7 x i8] c"malloc\00"
@95 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@96 = private unnamed_addr constant [5 x i8] c"free\00"
@97 = private unnamed_addr constant [5 x i8] c"free\00"
@98 = private unnamed_addr constant [5 x i8] c"free\00"
@99 = private unnamed_addr constant [5 x i8] c"free\00"
@100 = private unnamed_addr constant [5 x i8] c"free\00"
@101 = private unnamed_addr constant [7 x i8] c"malloc\00"
@102 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@103 = private unnamed_addr constant [5 x i8] c"free\00"
@104 = private unnamed_addr constant [7 x i8] c"strcmp\00"
@105 = private unnamed_addr constant [8 x i8] c"realloc\00"
@106 = private unnamed_addr constant [7 x i8] c"malloc\00"
@107 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@108 = private unnamed_addr constant [19 x i8] c"pthread_mutex_init\00"
@109 = private unnamed_addr constant [18 x i8] c"pthread_cond_init\00"
@110 = private unnamed_addr constant [18 x i8] c"pthread_cond_init\00"
@111 = private unnamed_addr constant [7 x i8] c"malloc\00"
@112 = private unnamed_addr constant [22 x i8] c"pthread_mutex_destroy\00"
@113 = private unnamed_addr constant [21 x i8] c"pthread_cond_destroy\00"
@114 = private unnamed_addr constant [21 x i8] c"pthread_cond_destroy\00"
@115 = private unnamed_addr constant [5 x i8] c"free\00"
@116 = private unnamed_addr constant [19 x i8] c"pthread_mutex_lock\00"
@117 = private unnamed_addr constant [23 x i8] c"pthread_cond_broadcast\00"
@118 = private unnamed_addr constant [21 x i8] c"pthread_mutex_unlock\00"
@119 = private unnamed_addr constant [19 x i8] c"pthread_mutex_lock\00"
@120 = private unnamed_addr constant [18 x i8] c"pthread_cond_wait\00"
@121 = private unnamed_addr constant [23 x i8] c"pthread_cond_broadcast\00"
@122 = private unnamed_addr constant [21 x i8] c"pthread_mutex_unlock\00"
@123 = private unnamed_addr constant [20 x i8] c"pthread_cond_signal\00"
@124 = private unnamed_addr constant [21 x i8] c"pthread_mutex_unlock\00"
@125 = private unnamed_addr constant [19 x i8] c"pthread_mutex_lock\00"
@126 = private unnamed_addr constant [18 x i8] c"pthread_cond_wait\00"
@127 = private unnamed_addr constant [20 x i8] c"pthread_cond_signal\00"
@128 = private unnamed_addr constant [21 x i8] c"pthread_mutex_unlock\00"
@129 = private unnamed_addr constant [5 x i8] c"free\00"
@130 = private unnamed_addr constant [5 x i8] c"free\00"
@131 = private unnamed_addr constant [8 x i8] c"realloc\00"
@132 = private unnamed_addr constant [8 x i8] c"realloc\00"
@133 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@134 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@135 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@136 = private unnamed_addr constant [8 x i8] c"realloc\00"
@137 = private unnamed_addr constant [8 x i8] c"realloc\00"
@138 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@139 = private unnamed_addr constant [6 x i8] c"fread\00"
@140 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@141 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@142 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@143 = private unnamed_addr constant [7 x i8] c"malloc\00"
@144 = private unnamed_addr constant [7 x i8] c"malloc\00"
@145 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@146 = private unnamed_addr constant [6 x i8] c"fread\00"
@147 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@148 = private unnamed_addr constant [6 x i8] c"fread\00"
@149 = private unnamed_addr constant [6 x i8] c"fread\00"
@150 = private unnamed_addr constant [6 x i8] c"fread\00"
@151 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@152 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@153 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@154 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@155 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@156 = private unnamed_addr constant [5 x i8] c"free\00"
@157 = private unnamed_addr constant [5 x i8] c"free\00"
@158 = private unnamed_addr constant [5 x i8] c"free\00"
@159 = private unnamed_addr constant [5 x i8] c"free\00"
@160 = private unnamed_addr constant [7 x i8] c"calloc\00"
@161 = private unnamed_addr constant [7 x i8] c"malloc\00"
@162 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@163 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@164 = private unnamed_addr constant [8 x i8] c"sprintf\00"
@165 = private unnamed_addr constant [7 x i8] c"strdup\00"
@166 = private unnamed_addr constant [6 x i8] c"fread\00"
@167 = private unnamed_addr constant [6 x i8] c"fread\00"
@168 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@169 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@170 = private unnamed_addr constant [6 x i8] c"fopen\00"
@171 = private unnamed_addr constant [7 x i8] c"fclose\00"
@172 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@173 = private unnamed_addr constant [6 x i8] c"fopen\00"
@174 = private unnamed_addr constant [7 x i8] c"fclose\00"
@175 = private unnamed_addr constant [7 x i8] c"calloc\00"
@176 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@177 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@178 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@179 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@180 = private unnamed_addr constant [8 x i8] c"realloc\00"
@181 = private unnamed_addr constant [7 x i8] c"malloc\00"
@182 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@183 = private unnamed_addr constant [7 x i8] c"malloc\00"
@184 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@185 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@186 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@187 = private unnamed_addr constant [5 x i8] c"rand\00"
@188 = private unnamed_addr constant [8 x i8] c"realloc\00"
@189 = private unnamed_addr constant [7 x i8] c"malloc\00"
@190 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@191 = private unnamed_addr constant [8 x i8] c"realloc\00"
@192 = private unnamed_addr constant [7 x i8] c"malloc\00"
@193 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@194 = private unnamed_addr constant [5 x i8] c"rand\00"
@195 = private unnamed_addr constant [8 x i8] c"realloc\00"
@196 = private unnamed_addr constant [7 x i8] c"malloc\00"
@197 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@198 = private unnamed_addr constant [7 x i8] c"calloc\00"
@199 = private unnamed_addr constant [5 x i8] c"free\00"
@200 = private unnamed_addr constant [5 x i8] c"free\00"
@201 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@202 = private unnamed_addr constant [9 x i8] c"vfprintf\00"
@203 = private unnamed_addr constant [9 x i8] c"snprintf\00"
@204 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@205 = private unnamed_addr constant [5 x i8] c"stat\00"
@206 = private unnamed_addr constant [6 x i8] c"lstat\00"
@207 = private unnamed_addr constant [7 x i8] c"malloc\00"
@208 = private unnamed_addr constant [5 x i8] c"free\00"
@209 = private unnamed_addr constant [6 x i8] c"fread\00"
@210 = private unnamed_addr constant [6 x i8] c"fread\00"
@211 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@212 = private unnamed_addr constant [7 x i8] c"strstr\00"
@213 = private unnamed_addr constant [7 x i8] c"strlen\00"
@214 = private unnamed_addr constant [7 x i8] c"strtol\00"
@215 = private unnamed_addr constant [7 x i8] c"strstr\00"
@216 = private unnamed_addr constant [7 x i8] c"strlen\00"
@217 = private unnamed_addr constant [16 x i8] c"__isoc99_sscanf\00"
@218 = private unnamed_addr constant [7 x i8] c"strstr\00"
@219 = private unnamed_addr constant [16 x i8] c"__isoc99_sscanf\00"
@220 = private unnamed_addr constant [7 x i8] c"malloc\00"
@221 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@222 = private unnamed_addr constant [7 x i8] c"malloc\00"
@223 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@224 = private unnamed_addr constant [7 x i8] c"malloc\00"
@225 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@226 = private unnamed_addr constant [5 x i8] c"free\00"
@227 = private unnamed_addr constant [5 x i8] c"free\00"
@228 = private unnamed_addr constant [5 x i8] c"free\00"
@229 = private unnamed_addr constant [5 x i8] c"free\00"
@230 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@231 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@232 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@233 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@234 = private unnamed_addr constant [7 x i8] c"calloc\00"
@235 = private unnamed_addr constant [7 x i8] c"malloc\00"
@236 = private unnamed_addr constant [7 x i8] c"malloc\00"
@237 = private unnamed_addr constant [5 x i8] c"free\00"
@238 = private unnamed_addr constant [5 x i8] c"free\00"
@239 = private unnamed_addr constant [5 x i8] c"free\00"
@240 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@241 = private unnamed_addr constant [7 x i8] c"malloc\00"
@242 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@243 = private unnamed_addr constant [7 x i8] c"strdup\00"
@244 = private unnamed_addr constant [8 x i8] c"realloc\00"
@245 = private unnamed_addr constant [7 x i8] c"malloc\00"
@246 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@247 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@248 = private unnamed_addr constant [5 x i8] c"free\00"
@249 = private unnamed_addr constant [5 x i8] c"free\00"
@250 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@251 = private unnamed_addr constant [9 x i8] c"snprintf\00"
@252 = private unnamed_addr constant [6 x i8] c"fopen\00"
@253 = private unnamed_addr constant [5 x i8] c"free\00"
@254 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@255 = private unnamed_addr constant [7 x i8] c"fclose\00"
@256 = private unnamed_addr constant [6 x i8] c"fread\00"
@257 = private unnamed_addr constant [9 x i8] c"snprintf\00"
@258 = private unnamed_addr constant [7 x i8] c"calloc\00"
@259 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@260 = private unnamed_addr constant [7 x i8] c"malloc\00"
@261 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@262 = private unnamed_addr constant [6 x i8] c"fread\00"
@263 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@264 = private unnamed_addr constant [5 x i8] c"free\00"
@265 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@266 = private unnamed_addr constant [5 x i8] c"free\00"
@267 = private unnamed_addr constant [5 x i8] c"free\00"
@268 = private unnamed_addr constant [13 x i8] c"gettimeofday\00"
@269 = private unnamed_addr constant [13 x i8] c"gettimeofday\00"
@270 = private unnamed_addr constant [7 x i8] c"printf\00"
@271 = private unnamed_addr constant [7 x i8] c"calloc\00"
@272 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@273 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@274 = private unnamed_addr constant [7 x i8] c"calloc\00"
@275 = private unnamed_addr constant [7 x i8] c"strstr\00"
@276 = private unnamed_addr constant [7 x i8] c"strstr\00"
@277 = private unnamed_addr constant [7 x i8] c"malloc\00"
@278 = private unnamed_addr constant [7 x i8] c"calloc\00"
@279 = private unnamed_addr constant [18 x i8] c"gsl_rng_env_setup\00"
@280 = private unnamed_addr constant [14 x i8] c"gsl_rng_alloc\00"
@281 = private unnamed_addr constant [17 x i8] c"gsl_ran_gaussian\00"
@282 = private unnamed_addr constant [16 x i8] c"gsl_rng_uniform\00"
@283 = private unnamed_addr constant [13 x i8] c"gsl_rng_free\00"
@284 = private unnamed_addr constant [6 x i8] c"srand\00"
@285 = private unnamed_addr constant [5 x i8] c"rand\00"
@286 = private unnamed_addr constant [7 x i8] c"strstr\00"
@287 = private unnamed_addr constant [5 x i8] c"free\00"
@288 = private unnamed_addr constant [5 x i8] c"free\00"
@289 = private unnamed_addr constant [5 x i8] c"free\00"
@290 = private unnamed_addr constant [5 x i8] c"free\00"
@291 = private unnamed_addr constant [5 x i8] c"free\00"
@292 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@293 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@294 = private unnamed_addr constant [5 x i8] c"free\00"
@295 = private unnamed_addr constant [5 x i8] c"free\00"
@296 = private unnamed_addr constant [6 x i8] c"fopen\00"
@297 = private unnamed_addr constant [7 x i8] c"fclose\00"
@298 = private unnamed_addr constant [7 x i8] c"floorf\00"
@299 = private unnamed_addr constant [8 x i8] c"realloc\00"
@300 = private unnamed_addr constant [7 x i8] c"malloc\00"
@301 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@302 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@303 = private unnamed_addr constant [7 x i8] c"calloc\00"
@304 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@305 = private unnamed_addr constant [7 x i8] c"calloc\00"
@306 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@307 = private unnamed_addr constant [7 x i8] c"calloc\00"
@308 = private unnamed_addr constant [7 x i8] c"malloc\00"
@309 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@310 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@311 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@312 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@313 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@314 = private unnamed_addr constant [6 x i8] c"fread\00"
@315 = private unnamed_addr constant [6 x i8] c"fread\00"
@316 = private unnamed_addr constant [6 x i8] c"fread\00"
@317 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@318 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@319 = private unnamed_addr constant [7 x i8] c"calloc\00"
@320 = private unnamed_addr constant [7 x i8] c"calloc\00"
@321 = private unnamed_addr constant [7 x i8] c"malloc\00"
@322 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@323 = private unnamed_addr constant [4 x i8] c"pow\00"
@324 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@325 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@326 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@327 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@328 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@329 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@330 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@331 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@332 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@333 = private unnamed_addr constant [7 x i8] c"malloc\00"
@334 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@335 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@336 = private unnamed_addr constant [7 x i8] c"malloc\00"
@337 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@338 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@339 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@340 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@341 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@342 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@343 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@344 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@345 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@346 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@347 = private unnamed_addr constant [7 x i8] c"malloc\00"
@348 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@349 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@350 = private unnamed_addr constant [7 x i8] c"malloc\00"
@351 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@352 = private unnamed_addr constant [7 x i8] c"calloc\00"
@353 = private unnamed_addr constant [7 x i8] c"calloc\00"
@354 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@355 = private unnamed_addr constant [7 x i8] c"strstr\00"
@356 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@357 = private unnamed_addr constant [7 x i8] c"calloc\00"
@358 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@359 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@360 = private unnamed_addr constant [4 x i8] c"pow\00"
@361 = private unnamed_addr constant [4 x i8] c"log\00"
@362 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@363 = private unnamed_addr constant [4 x i8] c"pow\00"
@364 = private unnamed_addr constant [4 x i8] c"log\00"
@365 = private unnamed_addr constant [4 x i8] c"exp\00"
@366 = private unnamed_addr constant [5 x i8] c"free\00"
@367 = private unnamed_addr constant [5 x i8] c"free\00"
@368 = private unnamed_addr constant [20 x i8] c"gsl_cdf_ugaussian_P\00"
@369 = private unnamed_addr constant [4 x i8] c"exp\00"
@370 = private unnamed_addr constant [20 x i8] c"gsl_cdf_ugaussian_P\00"
@371 = private unnamed_addr constant [20 x i8] c"gsl_cdf_ugaussian_P\00"
@372 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@373 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@374 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@375 = private unnamed_addr constant [6 x i8] c"fread\00"
@376 = private unnamed_addr constant [6 x i8] c"fread\00"
@377 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@378 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@379 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@380 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@381 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@382 = private unnamed_addr constant [7 x i8] c"calloc\00"
@383 = private unnamed_addr constant [5 x i8] c"free\00"
@384 = private unnamed_addr constant [5 x i8] c"free\00"
@385 = private unnamed_addr constant [5 x i8] c"free\00"
@386 = private unnamed_addr constant [7 x i8] c"calloc\00"
@387 = private unnamed_addr constant [5 x i8] c"free\00"
@388 = private unnamed_addr constant [7 x i8] c"calloc\00"
@389 = private unnamed_addr constant [5 x i8] c"free\00"
@390 = private unnamed_addr constant [7 x i8] c"calloc\00"
@391 = private unnamed_addr constant [5 x i8] c"free\00"
@392 = private unnamed_addr constant [6 x i8] c"sqrtf\00"
@393 = private unnamed_addr constant [7 x i8] c"calloc\00"
@394 = private unnamed_addr constant [5 x i8] c"free\00"
@395 = private unnamed_addr constant [7 x i8] c"calloc\00"
@396 = private unnamed_addr constant [5 x i8] c"free\00"
@397 = private unnamed_addr constant [7 x i8] c"calloc\00"
@398 = private unnamed_addr constant [5 x i8] c"free\00"
@399 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@400 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@401 = private unnamed_addr constant [7 x i8] c"calloc\00"
@402 = private unnamed_addr constant [5 x i8] c"free\00"
@403 = private unnamed_addr constant [5 x i8] c"free\00"
@404 = private unnamed_addr constant [5 x i8] c"free\00"
@405 = private unnamed_addr constant [7 x i8] c"calloc\00"
@406 = private unnamed_addr constant [5 x i8] c"free\00"
@407 = private unnamed_addr constant [7 x i8] c"calloc\00"
@408 = private unnamed_addr constant [5 x i8] c"free\00"
@409 = private unnamed_addr constant [7 x i8] c"calloc\00"
@410 = private unnamed_addr constant [5 x i8] c"free\00"
@411 = private unnamed_addr constant [7 x i8] c"calloc\00"
@412 = private unnamed_addr constant [7 x i8] c"calloc\00"
@413 = private unnamed_addr constant [5 x i8] c"free\00"
@414 = private unnamed_addr constant [5 x i8] c"free\00"
@415 = private unnamed_addr constant [7 x i8] c"calloc\00"
@416 = private unnamed_addr constant [7 x i8] c"calloc\00"
@417 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@418 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@419 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@420 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@421 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@422 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@423 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@424 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@425 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@426 = private unnamed_addr constant [5 x i8] c"free\00"
@427 = private unnamed_addr constant [5 x i8] c"free\00"
@428 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@429 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@430 = private unnamed_addr constant [7 x i8] c"malloc\00"
@431 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@432 = private unnamed_addr constant [5 x i8] c"exit\00"
@433 = private unnamed_addr constant [4 x i8] c"log\00"
@434 = private unnamed_addr constant [4 x i8] c"log\00"
@435 = private unnamed_addr constant [7 x i8] c"malloc\00"
@436 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@437 = private unnamed_addr constant [5 x i8] c"exit\00"
@438 = private unnamed_addr constant [7 x i8] c"malloc\00"
@439 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@440 = private unnamed_addr constant [5 x i8] c"exit\00"
@441 = private unnamed_addr constant [7 x i8] c"malloc\00"
@442 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@443 = private unnamed_addr constant [5 x i8] c"exit\00"
@444 = private unnamed_addr constant [7 x i8] c"malloc\00"
@445 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@446 = private unnamed_addr constant [5 x i8] c"exit\00"
@447 = private unnamed_addr constant [5 x i8] c"rand\00"
@448 = private unnamed_addr constant [5 x i8] c"rand\00"
@449 = private unnamed_addr constant [5 x i8] c"free\00"
@450 = private unnamed_addr constant [5 x i8] c"free\00"
@451 = private unnamed_addr constant [5 x i8] c"free\00"
@452 = private unnamed_addr constant [5 x i8] c"free\00"
@453 = private unnamed_addr constant [5 x i8] c"free\00"
@454 = private unnamed_addr constant [5 x i8] c"free\00"
@455 = private unnamed_addr constant [5 x i8] c"free\00"
@456 = private unnamed_addr constant [5 x i8] c"free\00"
@457 = private unnamed_addr constant [5 x i8] c"free\00"
@458 = private unnamed_addr constant [5 x i8] c"free\00"
@459 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@460 = private unnamed_addr constant [7 x i8] c"malloc\00"
@461 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@462 = private unnamed_addr constant [7 x i8] c"malloc\00"
@463 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@464 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@465 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@466 = private unnamed_addr constant [6 x i8] c"fread\00"
@467 = private unnamed_addr constant [6 x i8] c"fread\00"
@468 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@469 = private unnamed_addr constant [7 x i8] c"malloc\00"
@470 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@471 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@472 = private unnamed_addr constant [7 x i8] c"malloc\00"
@473 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@474 = private unnamed_addr constant [7 x i8] c"calloc\00"
@475 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@476 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@477 = private unnamed_addr constant [5 x i8] c"free\00"
@478 = private unnamed_addr constant [5 x i8] c"free\00"
@479 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@480 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@481 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@482 = private unnamed_addr constant [6 x i8] c"fread\00"
@483 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@484 = private unnamed_addr constant [6 x i8] c"fread\00"
@485 = private unnamed_addr constant [7 x i8] c"calloc\00"
@486 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@487 = private unnamed_addr constant [5 x i8] c"free\00"
@488 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@489 = private unnamed_addr constant [7 x i8] c"malloc\00"
@490 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@491 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@492 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@493 = private unnamed_addr constant [7 x i8] c"calloc\00"
@494 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@495 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@496 = private unnamed_addr constant [7 x i8] c"calloc\00"
@497 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@498 = private unnamed_addr constant [5 x i8] c"free\00"
@499 = private unnamed_addr constant [7 x i8] c"calloc\00"
@500 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@501 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@502 = private unnamed_addr constant [7 x i8] c"malloc\00"
@503 = private unnamed_addr constant [7 x i8] c"malloc\00"
@504 = private unnamed_addr constant [7 x i8] c"malloc\00"
@505 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@506 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@507 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@508 = private unnamed_addr constant [5 x i8] c"free\00"
@509 = private unnamed_addr constant [5 x i8] c"free\00"
@510 = private unnamed_addr constant [5 x i8] c"free\00"
@511 = private unnamed_addr constant [5 x i8] c"free\00"
@512 = private unnamed_addr constant [5 x i8] c"free\00"
@513 = private unnamed_addr constant [5 x i8] c"free\00"
@514 = private unnamed_addr constant [5 x i8] c"free\00"
@515 = private unnamed_addr constant [7 x i8] c"floorf\00"
@516 = private unnamed_addr constant [6 x i8] c"sqrtf\00"
@517 = private unnamed_addr constant [4 x i8] c"log\00"
@518 = private unnamed_addr constant [4 x i8] c"log\00"
@519 = private unnamed_addr constant [4 x i8] c"exp\00"
@520 = private unnamed_addr constant [7 x i8] c"floorf\00"
@521 = private unnamed_addr constant [6 x i8] c"sqrtf\00"
@522 = private unnamed_addr constant [7 x i8] c"malloc\00"
@523 = private unnamed_addr constant [8 x i8] c"realloc\00"
@524 = private unnamed_addr constant [7 x i8] c"malloc\00"
@525 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@526 = private unnamed_addr constant [5 x i8] c"free\00"
@527 = private unnamed_addr constant [5 x i8] c"free\00"
@528 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@529 = private unnamed_addr constant [7 x i8] c"calloc\00"
@530 = private unnamed_addr constant [7 x i8] c"malloc\00"
@531 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@532 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@533 = private unnamed_addr constant [8 x i8] c"realloc\00"
@534 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@535 = private unnamed_addr constant [8 x i8] c"realloc\00"
@536 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@537 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@538 = private unnamed_addr constant [5 x i8] c"free\00"
@539 = private unnamed_addr constant [14 x i8] c"__assert_fail\00"
@540 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@541 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@542 = private unnamed_addr constant [5 x i8] c"fabs\00"
@543 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@544 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@545 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@546 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@547 = private unnamed_addr constant [5 x i8] c"exit\00"
@548 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@549 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@550 = private unnamed_addr constant [5 x i8] c"exit\00"
@551 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@552 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@553 = private unnamed_addr constant [5 x i8] c"exit\00"
@554 = private unnamed_addr constant [5 x i8] c"fabs\00"
@555 = private unnamed_addr constant [5 x i8] c"fabs\00"
@556 = private unnamed_addr constant [5 x i8] c"fabs\00"
@557 = private unnamed_addr constant [7 x i8] c"malloc\00"
@558 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@559 = private unnamed_addr constant [5 x i8] c"exit\00"
@560 = private unnamed_addr constant [5 x i8] c"free\00"
@561 = private unnamed_addr constant [6 x i8] c"fabsf\00"
@562 = private unnamed_addr constant [4 x i8] c"sin\00"
@563 = private unnamed_addr constant [7 x i8] c"malloc\00"
@564 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@565 = private unnamed_addr constant [5 x i8] c"exit\00"
@566 = private unnamed_addr constant [5 x i8] c"free\00"
@567 = private unnamed_addr constant [7 x i8] c"malloc\00"
@568 = private unnamed_addr constant [7 x i8] c"malloc\00"
@569 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@570 = private unnamed_addr constant [5 x i8] c"exit\00"
@571 = private unnamed_addr constant [7 x i8] c"malloc\00"
@572 = private unnamed_addr constant [7 x i8] c"malloc\00"
@573 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@574 = private unnamed_addr constant [5 x i8] c"exit\00"
@575 = private unnamed_addr constant [5 x i8] c"free\00"
@576 = private unnamed_addr constant [6 x i8] c"fopen\00"
@577 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@578 = private unnamed_addr constant [15 x i8] c"jpeg_std_error\00"
@579 = private unnamed_addr constant [22 x i8] c"jpeg_CreateDecompress\00"
@580 = private unnamed_addr constant [15 x i8] c"jpeg_stdio_src\00"
@581 = private unnamed_addr constant [17 x i8] c"jpeg_read_header\00"
@582 = private unnamed_addr constant [22 x i8] c"jpeg_start_decompress\00"
@583 = private unnamed_addr constant [7 x i8] c"malloc\00"
@584 = private unnamed_addr constant [7 x i8] c"fwrite\00"
@585 = private unnamed_addr constant [5 x i8] c"exit\00"
@586 = private unnamed_addr constant [20 x i8] c"jpeg_read_scanlines\00"
@587 = private unnamed_addr constant [23 x i8] c"jpeg_finish_decompress\00"
@588 = private unnamed_addr constant [24 x i8] c"jpeg_destroy_decompress\00"
@589 = private unnamed_addr constant [7 x i8] c"fclose\00"
@590 = private unnamed_addr constant [7 x i8] c"malloc\00"
@591 = private unnamed_addr constant [5 x i8] c"free\00"
@592 = private unnamed_addr constant [7 x i8] c"calloc\00"
@593 = private unnamed_addr constant [4 x i8] c"log\00"
@594 = private unnamed_addr constant [4 x i8] c"log\00"
@595 = private unnamed_addr constant [7 x i8] c"calloc\00"
@596 = private unnamed_addr constant [7 x i8] c"calloc\00"
@597 = private unnamed_addr constant [5 x i8] c"free\00"
@598 = private unnamed_addr constant [5 x i8] c"free\00"
@599 = private unnamed_addr constant [5 x i8] c"free\00"
@600 = private unnamed_addr constant [7 x i8] c"calloc\00"
@601 = private unnamed_addr constant [5 x i8] c"free\00"
@602 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@603 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@604 = private unnamed_addr constant [7 x i8] c"calloc\00"
@605 = private unnamed_addr constant [7 x i8] c"calloc\00"
@606 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@607 = private unnamed_addr constant [5 x i8] c"cbrt\00"
@608 = private unnamed_addr constant [5 x i8] c"free\00"
@609 = private unnamed_addr constant [5 x i8] c"free\00"
@610 = private unnamed_addr constant [5 x i8] c"free\00"
@611 = private unnamed_addr constant [4 x i8] c"log\00"
@612 = private unnamed_addr constant [7 x i8] c"malloc\00"
@613 = private unnamed_addr constant [7 x i8] c"malloc\00"
@614 = private unnamed_addr constant [7 x i8] c"malloc\00"
@615 = private unnamed_addr constant [7 x i8] c"malloc\00"
@616 = private unnamed_addr constant [7 x i8] c"malloc\00"
@617 = private unnamed_addr constant [7 x i8] c"calloc\00"
@618 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@619 = private unnamed_addr constant [7 x i8] c"fflush\00"
@620 = private unnamed_addr constant [7 x i8] c"calloc\00"
@621 = private unnamed_addr constant [8 x i8] c"fprintf\00"
@622 = private unnamed_addr constant [7 x i8] c"fflush\00"
@623 = private unnamed_addr constant [4 x i8] c"log\00"
@624 = private unnamed_addr constant [4 x i8] c"log\00"
@625 = private unnamed_addr constant [5 x i8] c"sqrt\00"
@626 = private unnamed_addr constant [5 x i8] c"fabs\00"
@627 = private unnamed_addr constant [5 x i8] c"fabs\00"
@628 = private unnamed_addr constant [5 x i8] c"fabs\00"
@629 = private unnamed_addr constant [7 x i8] c"calloc\00"
@630 = private unnamed_addr constant [5 x i8] c"free\00"
@631 = private unnamed_addr constant [5 x i8] c"free\00"
@632 = private unnamed_addr constant [5 x i8] c"free\00"
@633 = private unnamed_addr constant [5 x i8] c"free\00"
@634 = private unnamed_addr constant [5 x i8] c"free\00"
@635 = private unnamed_addr constant [5 x i8] c"free\00"
@636 = private unnamed_addr constant [5 x i8] c"free\00"
@637 = private unnamed_addr constant [5 x i8] c"free\00"
@638 = private unnamed_addr constant [5 x i8] c"free\00"
@639 = private unnamed_addr constant [7 x i8] c"calloc\00"
@640 = private unnamed_addr constant [7 x i8] c"calloc\00"
@641 = private unnamed_addr constant [7 x i8] c"malloc\00"
@642 = private unnamed_addr constant [5 x i8] c"free\00"
@643 = private unnamed_addr constant [5 x i8] c"free\00"

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @dir_helper(i8* nocapture readonly %dir, i8* %head) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @0, i32 0, i32 0))
  %call = call %struct.__dirstream* @opendir(i8* %dir)
  %cmp = icmp eq %struct.__dirstream* %call, null
  br i1 %cmp, label %final.thread, label %for.cond

for.cond:                                         ; preds = %entry, %if.end4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @1, i32 0, i32 0))
  %call1 = call %struct.dirent* @readdir(%struct.__dirstream* nonnull %call) #11
  %cmp2 = icmp eq %struct.dirent* %call1, null
  br i1 %cmp2, label %if.then10, label %if.end4

if.end4:                                          ; preds = %for.cond
  %arraydecay = getelementptr inbounds %struct.dirent, %struct.dirent* %call1, i64 0, i32 4, i64 0
  %call5 = call fastcc i32 @scan_dir(i8* %arraydecay, i8* %head)
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %for.cond, label %return

final.thread:                                     ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i32 0, i32 0))
  call void @perror(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i64 0, i64 0)) #14
  br label %return

if.then10:                                        ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @3, i32 0, i32 0))
  %call11 = call i32 @closedir(%struct.__dirstream* nonnull %call)
  br label %return

return:                                           ; preds = %if.end4, %if.then10, %final.thread
  ret void
}

; Function Attrs: nounwind
declare noalias %struct.__dirstream* @opendir(i8* nocapture readonly) local_unnamed_addr #1

declare %struct.dirent* @readdir(%struct.__dirstream*) local_unnamed_addr #2

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @scan_dir(i8* nocapture readonly %dir, i8* %head) unnamed_addr #0 {
entry:
  %st = alloca %struct.stat, align 8
  %0 = load i8, i8* %dir, align 1
  %cmp = icmp eq i8 %0, 46
  br i1 %cmp, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %arrayidx2 = getelementptr inbounds i8, i8* %dir, i64 1
  %1 = load i8, i8* %arrayidx2, align 1
  switch i8 %1, label %if.end19 [
    i8 0, label %return
    i8 46, label %if.then11
  ]

if.then11:                                        ; preds = %if.then
  %arrayidx12 = getelementptr inbounds i8, i8* %dir, i64 2
  %2 = load i8, i8* %arrayidx12, align 1
  %cmp14 = icmp eq i8 %2, 0
  br i1 %cmp14, label %return, label %if.end19

if.end19:                                         ; preds = %if.then, %if.then11, %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @4, i32 0, i32 0))
  %call = call i8* @strcat(i8* %head, i8* %dir) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @5, i32 0, i32 0))
  %call20 = call i32 @stat(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0), %struct.stat* nonnull %st) #11
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end19
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @6, i32 0, i32 0))
  call void @perror(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i64 0, i64 0)) #14
  br label %return

if.end24:                                         ; preds = %if.end19
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %st, i64 0, i32 3
  %3 = load i32, i32* %st_mode, align 8
  %4 = trunc i32 %3 to i16
  %trunc = and i16 %4, -4096
  switch i16 %trunc, label %if.end39 [
    i16 -32768, label %if.then27
    i16 16384, label %if.then34
  ]

if.then27:                                        ; preds = %if.end24
  call fastcc void @file_helper()
  br label %if.end39

if.then34:                                        ; preds = %if.end24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @7, i32 0, i32 0))
  %strlen = call i64 @strlen(i8* %head)
  %endptr = getelementptr i8, i8* %head, i64 %strlen
  %5 = bitcast i8* %endptr to i16*
  store i16 47, i16* %5, align 1
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @8, i32 0, i32 0))
  %call36 = call i64 @strlen(i8* %head) #15
  %add.ptr = getelementptr inbounds i8, i8* %head, i64 %call36
  call fastcc void @dir_helper(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0), i8* %add.ptr)
  br label %if.end39

if.end39:                                         ; preds = %if.end24, %if.then34, %if.then27
  store i8 0, i8* %head, align 1
  br label %return

return:                                           ; preds = %if.then, %if.then11, %if.end39, %if.then23
  %retval.0 = phi i32 [ -1, %if.then23 ], [ 0, %if.end39 ], [ 0, %if.then ], [ 0, %if.then11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare void @perror(i8* nocapture readonly) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @closedir(%struct.__dirstream* nocapture) local_unnamed_addr #1

; Function Attrs: nounwind
declare i8* @strcat(i8*, i8* nocapture readonly) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @stat(i8* nocapture readonly, %struct.stat* nocapture) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @file_helper() unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @9, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 32) #11
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @10, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.2, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 154, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__PRETTY_FUNCTION__.file_helper, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @11, i32 0, i32 0))
  %call1 = call noalias i8* @strdup(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0)) #11
  %name = getelementptr inbounds i8, i8* %call, i64 8
  %0 = bitcast i8* %name to i8**
  store i8* %call1, i8** %0, align 8
  %width = bitcast i8* %call to i32*
  %height = getelementptr inbounds i8, i8* %call, i64 4
  %1 = bitcast i8* %height to i32*
  %RGB = getelementptr inbounds i8, i8* %call, i64 24
  %2 = bitcast i8* %RGB to i8**
  %HSV = getelementptr inbounds i8, i8* %call, i64 16
  %3 = bitcast i8* %HSV to i8**
  %call2 = call fastcc i32 @image_read_rgb_hsv(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0), i32* %width, i32* %1, i8** %2, i8** %3)
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %if.end6, label %if.else5

if.else5:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @12, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 159, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__PRETTY_FUNCTION__.file_helper, i64 0, i64 0)) #16
  unreachable

if.end6:                                          ; preds = %if.end
  %4 = load i32, i32* @cnt_enqueue, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* @cnt_enqueue, align 4
  call fastcc void @enqueue(%struct.queue* nonnull @q_load_seg, i8* nonnull %call)
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) local_unnamed_addr #3

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) local_unnamed_addr #1

; Function Attrs: noreturn nounwind
declare void @__assert_fail(i8*, i8*, i32, i8*) local_unnamed_addr #4

; Function Attrs: nounwind
declare noalias i8* @strdup(i8* nocapture readonly) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_load(i8* nocapture readonly %dummy) #0 {
entry:
  store i8 0, i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0), align 16
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @13, i32 0, i32 0))
  %call = call i32 @strcmp(i8* %dummy, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0)) #15
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call fastcc void @dir_helper(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0))
  br label %if.end

if.else:                                          ; preds = %entry
  %call2 = call fastcc i32 @scan_dir(i8* %dummy, i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @path, i64 0, i64 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call fastcc void @queue_signal_terminate(%struct.queue* nonnull @q_load_seg)
  ret i8* null
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) local_unnamed_addr #3

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_seg(i8* nocapture readnone %dummy) #0 {
entry:
  %load = alloca %struct.load_data*, align 8
  %0 = bitcast %struct.load_data** %load to i8**
  br label %while.body

while.body:                                       ; preds = %if.end3, %entry
  %call = call fastcc i32 @dequeue(%struct.queue* nonnull @q_load_seg, i8** %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %1 = load %struct.load_data*, %struct.load_data** %load, align 8
  %cmp1 = icmp eq %struct.load_data* %1, null
  br i1 %cmp1, label %if.else, label %if.end3

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @14, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 237, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__PRETTY_FUNCTION__.t_seg, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  %2 = bitcast %struct.load_data* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i32 0, i32 0))
  %call4 = call noalias i8* @calloc(i64 1, i64 40) #11
  %name = getelementptr inbounds %struct.load_data, %struct.load_data* %1, i64 0, i32 2
  %3 = bitcast i8** %name to i64*
  %4 = load i64, i64* %3, align 8
  %name5 = getelementptr inbounds i8, i8* %call4, i64 16
  %5 = bitcast i8* %name5 to i64*
  store i64 %4, i64* %5, align 8
  %width = getelementptr inbounds %struct.load_data, %struct.load_data* %1, i64 0, i32 0
  %6 = load i32, i32* %width, align 8
  %width6 = bitcast i8* %call4 to i32*
  store i32 %6, i32* %width6, align 8
  %height = getelementptr inbounds %struct.load_data, %struct.load_data* %1, i64 0, i32 1
  %7 = load i32, i32* %height, align 4
  %height7 = getelementptr inbounds i8, i8* %call4, i64 4
  %8 = bitcast i8* %height7 to i32*
  store i32 %7, i32* %8, align 4
  %HSV = getelementptr inbounds %struct.load_data, %struct.load_data* %1, i64 0, i32 3
  %9 = bitcast i8** %HSV to i64*
  %10 = load i64, i64* %9, align 8
  %HSV8 = getelementptr inbounds i8, i8* %call4, i64 32
  %11 = bitcast i8* %HSV8 to i64*
  store i64 %10, i64* %11, align 8
  %mask = getelementptr inbounds i8, i8* %call4, i64 24
  %12 = bitcast i8* %mask to i8**
  %nrgn = getelementptr inbounds i8, i8* %call4, i64 8
  %13 = bitcast i8* %nrgn to i32*
  %RGB = getelementptr inbounds %struct.load_data, %struct.load_data* %1, i64 0, i32 4
  %14 = load i8*, i8** %RGB, align 8
  %15 = load i32, i32* %width, align 8
  %16 = load i32, i32* %height, align 4
  call fastcc void @image_segment(i8** %12, i32* %13, i8* %14, i32 %15, i32 %16)
  %17 = load i8*, i8** %RGB, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @16, i32 0, i32 0))
  call void @free(i8* %17) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i32 0, i32 0))
  call void @free(i8* %2) #11
  call fastcc void @enqueue(%struct.queue* nonnull @q_seg_extract, i8* %call4)
  br label %while.body

while.end:                                        ; preds = %while.body
  call fastcc void @queue_signal_terminate(%struct.queue* nonnull @q_seg_extract)
  ret i8* null
}

; Function Attrs: nounwind
declare noalias i8* @calloc(i64, i64) local_unnamed_addr #1

; Function Attrs: nounwind
declare void @free(i8* nocapture) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_extract(i8* nocapture readnone %dummy) #0 {
entry:
  %seg = alloca %struct.seg_data*, align 8
  %0 = bitcast %struct.seg_data** %seg to i8**
  br label %while.body

while.body:                                       ; preds = %if.end3, %entry
  %call = call fastcc i32 @dequeue(%struct.queue* nonnull @q_seg_extract, i8** %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %1 = load %struct.seg_data*, %struct.seg_data** %seg, align 8
  %cmp1 = icmp eq %struct.seg_data* %1, null
  br i1 %cmp1, label %if.else, label %if.end3

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @18, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.8, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 268, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__PRETTY_FUNCTION__.t_extract, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  %2 = bitcast %struct.seg_data* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @19, i32 0, i32 0))
  %call4 = call noalias i8* @calloc(i64 1, i64 56) #11
  %name = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 3
  %3 = bitcast i8** %name to i64*
  %4 = load i64, i64* %3, align 8
  %name5 = getelementptr inbounds i8, i8* %call4, i64 48
  %5 = bitcast i8* %name5 to i64*
  store i64 %4, i64* %5, align 8
  %HSV = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 5
  %6 = load i8*, i8** %HSV, align 8
  %mask = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 4
  %7 = load i8*, i8** %mask, align 8
  %width = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 0
  %8 = load i32, i32* %width, align 8
  %height = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 1
  %9 = load i32, i32* %height, align 4
  %nrgn = getelementptr inbounds %struct.seg_data, %struct.seg_data* %1, i64 0, i32 2
  %10 = load i32, i32* %nrgn, align 8
  %ds = bitcast i8* %call4 to %struct.cass_dataset_t*
  call fastcc void @image_extract_helper(i8* %6, i8* %7, i32 %8, i32 %9, i32 %10, %struct.cass_dataset_t* %ds)
  %11 = load i8*, i8** %mask, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @20, i32 0, i32 0))
  call void @free(i8* %11) #11
  %12 = load i8*, i8** %HSV, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @21, i32 0, i32 0))
  call void @free(i8* %12) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @22, i32 0, i32 0))
  call void @free(i8* %2) #11
  call fastcc void @enqueue(%struct.queue* nonnull @q_extract_vec, i8* %call4)
  br label %while.body

while.end:                                        ; preds = %while.body
  call fastcc void @queue_signal_terminate(%struct.queue* nonnull @q_extract_vec)
  ret i8* null
}

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_vec(i8* nocapture readnone %dummy) #0 {
entry:
  %extract = alloca %struct.extract_data*, align 8
  %query = alloca %struct.cass_query_t, align 8
  %0 = bitcast %struct.extract_data** %extract to i8**
  %1 = bitcast %struct.cass_query_t* %query to i8*
  %flags = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 0
  %dataset = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %vec_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 7
  %vecset_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 8
  %topk = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 3
  %extra_params = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 5
  br label %while.body

while.body:                                       ; preds = %if.end3, %entry
  %call = call fastcc i32 @dequeue(%struct.queue* nonnull @q_extract_vec, i8** %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %2 = load %struct.extract_data*, %struct.extract_data** %extract, align 8
  %cmp1 = icmp eq %struct.extract_data* %2, null
  br i1 %cmp1, label %if.else, label %if.end3

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @23, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 296, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__PRETTY_FUNCTION__.t_vec, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @24, i32 0, i32 0))
  %call4 = call noalias i8* @calloc(i64 1, i64 48) #11
  %name = getelementptr inbounds %struct.extract_data, %struct.extract_data* %2, i64 0, i32 1
  %3 = bitcast i8** %name to i64*
  %4 = load i64, i64* %3, align 8
  %5 = bitcast i8* %call4 to i64*
  store i64 %4, i64* %5, align 8
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 48, i32 8, i1 false)
  store i32 1032, i32* %flags, align 8
  %ds = getelementptr inbounds %struct.extract_data, %struct.extract_data* %2, i64 0, i32 0
  store %struct.cass_dataset_t* %ds, %struct.cass_dataset_t** %dataset, align 8
  %ds6 = getelementptr inbounds i8, i8* %call4, i64 8
  %6 = bitcast i8* %ds6 to %struct.cass_dataset_t**
  store %struct.cass_dataset_t* %ds, %struct.cass_dataset_t** %6, align 8
  store i32 0, i32* %vecset_id, align 8
  %7 = load i32, i32* @vec_dist_id, align 4
  store i32 %7, i32* %vec_dist_id, align 8
  %8 = load i32, i32* @vecset_dist_id, align 4
  store i32 %8, i32* %vecset_dist_id, align 4
  %9 = load i32, i32* @top_K, align 4
  %mul = shl nsw i32 %9, 1
  store i32 %mul, i32* %topk, align 4
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i64 0, i64 0), i8** %extra_params, align 8
  %result = getelementptr inbounds i8, i8* %call4, i64 16
  %10 = bitcast i8* %result to %struct.cass_result_t*
  %vecset = getelementptr inbounds %struct.extract_data, %struct.extract_data* %2, i64 0, i32 0, i32 9
  %11 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %11, i64 0, i32 0
  %12 = load i32, i32* %num_regions, align 4
  call fastcc void @cass_result_alloc_list(%struct.cass_result_t* %10, i32 %12, i32 %mul)
  %13 = load %struct._cass_table.19*, %struct._cass_table.19** bitcast (%struct._cass_table** @table to %struct._cass_table.19**), align 8
  %call11 = call fastcc i32 @cass_table_query(%struct._cass_table.19* %13, %struct.cass_query_t* nonnull %query, %struct.cass_result_t* %10) #11
  call fastcc void @enqueue(%struct.queue* nonnull @q_vec_rank, i8* %call4)
  br label %while.body

while.end:                                        ; preds = %while.body
  call fastcc void @queue_signal_terminate(%struct.queue* nonnull @q_vec_rank)
  ret i8* null
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #5

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_rank(i8* nocapture readnone %dummy) #0 {
entry:
  %vec = alloca %struct.vec_query_data*, align 8
  %query = alloca %struct.cass_query_t, align 8
  %0 = bitcast %struct.vec_query_data** %vec to i8**
  %flags = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 0
  %dataset = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %1 = bitcast %struct.cass_dataset_t** %dataset to i64*
  %vecset_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %vec_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 7
  %vecset_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 8
  %topk = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 3
  %extra_params = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 5
  %candidate7 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 6
  br label %while.body

while.body:                                       ; preds = %if.end3, %entry
  %call = call fastcc i32 @dequeue(%struct.queue* nonnull @q_vec_rank, i8** %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %2 = load %struct.vec_query_data*, %struct.vec_query_data** %vec, align 8
  %cmp1 = icmp eq %struct.vec_query_data* %2, null
  br i1 %cmp1, label %if.else, label %if.end3

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @25, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 338, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__PRETTY_FUNCTION__.t_rank, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  %3 = bitcast %struct.vec_query_data* %2 to i64*
  %4 = bitcast %struct.vec_query_data* %2 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @26, i32 0, i32 0))
  %call4 = call noalias i8* @calloc(i64 1, i64 48) #11
  %5 = load i64, i64* %3, align 8
  %6 = bitcast i8* %call4 to i64*
  store i64 %5, i64* %6, align 8
  store i32 1042, i32* %flags, align 8
  %ds = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %2, i64 0, i32 1
  %7 = bitcast %struct.cass_dataset_t** %ds to i64*
  %8 = load i64, i64* %7, align 8
  store i64 %8, i64* %1, align 8
  store i32 0, i32* %vecset_id, align 8
  %9 = load i32, i32* @vec_dist_id, align 4
  store i32 %9, i32* %vec_dist_id, align 8
  %10 = load i32, i32* @vecset_dist_id, align 4
  store i32 %10, i32* %vecset_dist_id, align 4
  %11 = load i32, i32* @top_K, align 4
  store i32 %11, i32* %topk, align 4
  store i8* null, i8** %extra_params, align 8
  %result = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %2, i64 0, i32 2
  %12 = load %struct._cass_table*, %struct._cass_table** @query_table, align 8
  %__private = getelementptr inbounds %struct._cass_table, %struct._cass_table* %12, i64 0, i32 12
  %13 = bitcast i8** %__private to %struct.cass_dataset_t**
  %14 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %13, align 8
  %call6 = call fastcc %struct.cass_result_t* @cass_result_merge_lists(%struct.cass_result_t* %result, %struct.cass_dataset_t* %14)
  store %struct.cass_result_t* %call6, %struct.cass_result_t** %candidate7, align 8
  %result8 = getelementptr inbounds i8, i8* %call4, i64 16
  %15 = bitcast i8* %result8 to %struct.cass_result_t*
  %16 = load i32, i32* @top_K, align 4
  call fastcc void @cass_result_alloc_list(%struct.cass_result_t* %15, i32 0, i32 %16)
  %17 = load %struct._cass_table.19*, %struct._cass_table.19** bitcast (%struct._cass_table** @query_table to %struct._cass_table.19**), align 8
  %call11 = call fastcc i32 @cass_table_query(%struct._cass_table.19* %17, %struct.cass_query_t* nonnull %query, %struct.cass_result_t* %15) #11
  call fastcc void @cass_result_free(%struct.cass_result_t* %result)
  call fastcc void @cass_result_free(%struct.cass_result_t* %call6)
  %18 = bitcast %struct.cass_result_t* %call6 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @27, i32 0, i32 0))
  call void @free(i8* %18) #11
  %ds15 = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %2, i64 0, i32 1
  %19 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds15, align 8
  call fastcc void @cass_dataset_release(%struct.cass_dataset_t* %19)
  %20 = bitcast %struct.cass_dataset_t** %ds15 to i8**
  %21 = load i8*, i8** %20, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @28, i32 0, i32 0))
  call void @free(i8* %21) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @29, i32 0, i32 0))
  call void @free(i8* %4) #11
  call fastcc void @enqueue(%struct.queue* nonnull @q_rank_out, i8* %call4)
  br label %while.body

while.end:                                        ; preds = %while.body
  call fastcc void @queue_signal_terminate(%struct.queue* nonnull @q_rank_out)
  ret i8* null
}

; Function Attrs: noinline nounwind uwtable
define internal noalias i8* @t_out(i8* nocapture readnone %dummy) #0 {
entry:
  %rank = alloca %struct.vec_query_data*, align 8
  %obj = alloca i8*, align 8
  %0 = bitcast %struct.vec_query_data** %rank to i8**
  br label %while.body

while.body:                                       ; preds = %do.end, %entry
  %call = call fastcc i32 @dequeue(%struct.queue* nonnull @q_rank_out, i8** %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  %1 = load %struct.vec_query_data*, %struct.vec_query_data** %rank, align 8
  %cmp1 = icmp eq %struct.vec_query_data* %1, null
  %2 = bitcast %struct.vec_query_data* %1 to i8*
  br i1 %cmp1, label %if.else, label %do.body

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @30, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 383, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__PRETTY_FUNCTION__.t_out, i64 0, i64 0)) #16
  unreachable

do.body:                                          ; preds = %if.end
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @fout, align 8
  %name = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %1, i64 0, i32 0
  %4 = load i8*, i8** %name, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @31, i32 0, i32 0))
  %fputs = call i32 @fputs(i8* %4, %struct._IO_FILE* %3)
  %len = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %1, i64 0, i32 2, i32 1, i32 0, i32 2
  %data = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %1, i64 0, i32 2, i32 1, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %__array_foreach_index.0 = phi i32 [ 0, %do.body ], [ %inc, %for.inc ]
  %5 = load i32, i32* %len, align 8
  %cmp5 = icmp ult i32 %__array_foreach_index.0, %5
  br i1 %cmp5, label %for.body, label %do.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data, align 8
  %idxprom = zext i32 %__array_foreach_index.0 to i64
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %6, i64 %idxprom, i32 0
  %7 = load i32, i32* %.sroa_idx, align 4
  %.sroa_idx1 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %6, i64 %idxprom, i32 1
  %8 = load float, float* %.sroa_idx1, align 4
  store i8* null, i8** %obj, align 8
  %cmp9 = fcmp oeq float %8, 0x7FF0000000000000
  br i1 %cmp9, label %for.inc, label %if.end12

if.end12:                                         ; preds = %for.body
  %9 = load %struct._cass_table*, %struct._cass_table** @query_table, align 8
  %map = getelementptr inbounds %struct._cass_table, %struct._cass_table* %9, i64 0, i32 15
  %10 = load %struct.cass_map_t*, %struct.cass_map_t** %map, align 8
  call fastcc void @cass_map_id_to_dataobj(%struct.cass_map_t* %10, i32 %7, i8** nonnull %obj)
  %11 = load i8*, i8** %obj, align 8
  %cmp14 = icmp eq i8* %11, null
  br i1 %cmp14, label %if.else17, label %if.end18

if.else17:                                        ; preds = %if.end12
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @32, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 392, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__PRETTY_FUNCTION__.t_out, i64 0, i64 0)) #16
  unreachable

if.end18:                                         ; preds = %if.end12
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @fout, align 8
  %conv20 = fpext float %8 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @33, i32 0, i32 0))
  %call21 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14, i64 0, i64 0), i8* nonnull %11, double %conv20)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end18
  %inc = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.end:                                           ; preds = %for.cond
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** @fout, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @34, i32 0, i32 0))
  %fputc = call i32 @fputc(i32 10, %struct._IO_FILE* %13)
  %result23 = getelementptr inbounds %struct.vec_query_data, %struct.vec_query_data* %1, i64 0, i32 2
  call fastcc void @cass_result_free(%struct.cass_result_t* %result23)
  %14 = load i8*, i8** %name, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @35, i32 0, i32 0))
  call void @free(i8* %14) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @36, i32 0, i32 0))
  call void @free(i8* %2) #11
  %15 = load i32, i32* @cnt_dequeue, align 4
  %inc26 = add nsw i32 %15, 1
  store i32 %inc26, i32* @cnt_dequeue, align 4
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %17 = load i32, i32* @cnt_enqueue, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @37, i32 0, i32 0))
  %call27 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %16, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.16, i64 0, i64 0), i32 %17, i32 %inc26) #14
  br label %while.body

while.end:                                        ; preds = %while.body
  %18 = load i32, i32* @cnt_enqueue, align 4
  %19 = load i32, i32* @cnt_dequeue, align 4
  %cmp28 = icmp eq i32 %18, %19
  br i1 %cmp28, label %if.end32, label %if.else31

if.else31:                                        ; preds = %while.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @38, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.17, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 407, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__PRETTY_FUNCTION__.t_out, i64 0, i64 0)) #16
  unreachable

if.end32:                                         ; preds = %while.end
  ret i8* null
}

; Function Attrs: nounwind
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) local_unnamed_addr #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #5

; Function Attrs: noinline nounwind uwtable
define i32 @main(i32 %argc, i8** nocapture readonly %argv) local_unnamed_addr #0 {
entry:
  %tmr = alloca %struct.stimer_t, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @39, i32 0, i32 0))
  %puts = call i32 @puts(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str, i64 0, i64 0))
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @40, i32 0, i32 0))
  %call1 = call i32 @fflush(%struct._IO_FILE* null)
  %cmp = icmp slt i32 %argc, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load i8*, i8** %argv, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @41, i32 0, i32 0))
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.19, i64 0, i64 0), i8* %0)
  br label %return

if.end:                                           ; preds = %entry
  %arrayidx3 = getelementptr inbounds i8*, i8** %argv, i64 1
  %1 = bitcast i8** %arrayidx3 to i64*
  %2 = load i64, i64* %1, align 8
  store i64 %2, i64* bitcast (i8** @db_dir to i64*), align 8
  %arrayidx4 = getelementptr inbounds i8*, i8** %argv, i64 2
  %3 = bitcast i8** %arrayidx4 to i64*
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* bitcast (i8** @table_name to i64*), align 8
  %arrayidx5 = getelementptr inbounds i8*, i8** %argv, i64 3
  %5 = bitcast i8** %arrayidx5 to i64*
  %6 = load i64, i64* %5, align 8
  store i64 %6, i64* bitcast (i8** @query_dir to i64*), align 8
  %arrayidx6 = getelementptr inbounds i8*, i8** %argv, i64 4
  %7 = load i8*, i8** %arrayidx6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @42, i32 0, i32 0))
  %call7 = call i32 @atoi(i8* %7) #15
  store i32 %call7, i32* @top_K, align 4
  %arrayidx8 = getelementptr inbounds i8*, i8** %argv, i64 5
  %8 = load i8*, i8** %arrayidx8, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @43, i32 0, i32 0))
  %call9 = call i32 @atoi(i8* %8) #15
  store i32 %call9, i32* @DEPTH, align 4
  %arrayidx10 = getelementptr inbounds i8*, i8** %argv, i64 6
  %9 = load i8*, i8** %arrayidx10, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @44, i32 0, i32 0))
  %call11 = call i32 @atoi(i8* %9) #15
  store i32 %call11, i32* @NTHREAD_SEG, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @45, i32 0, i32 0))
  %call13 = call i32 @atoi(i8* %9) #15
  store i32 %call13, i32* @NTHREAD_EXTRACT, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @46, i32 0, i32 0))
  %call15 = call i32 @atoi(i8* %9) #15
  store i32 %call15, i32* @NTHREAD_VEC, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @47, i32 0, i32 0))
  %call17 = call i32 @atoi(i8* %9) #15
  store i32 %call17, i32* @NTHREAD_RANK, align 4
  %arrayidx18 = getelementptr inbounds i8*, i8** %argv, i64 7
  %10 = bitcast i8** %arrayidx18 to i64*
  %11 = load i64, i64* %10, align 8
  store i64 %11, i64* bitcast (i8** @output_path to i64*), align 8
  %.cast = inttoptr i64 %11 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @48, i32 0, i32 0))
  %call19 = call %struct._IO_FILE* @fopen(i8* %.cast, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.26.337, i64 0, i64 0))
  store %struct._IO_FILE* %call19, %struct._IO_FILE** @fout, align 8
  %cmp20 = icmp eq %struct._IO_FILE* %call19, null
  br i1 %cmp20, label %if.else, label %if.end22

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @49, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27.339, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 464, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__PRETTY_FUNCTION__.main, i64 0, i64 0)) #16
  unreachable

if.end22:                                         ; preds = %if.end
  call fastcc void @cass_init()
  %12 = load i8*, i8** @db_dir, align 8
  %call24 = call fastcc i32 @cass_env_open(i8* %12)
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.end29, label %if.then26

if.then26:                                        ; preds = %if.end22
  %call27 = call fastcc i8* @cass_strerror(i32 %call24)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @50, i32 0, i32 0))
  %call28 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i64 0, i64 0), i8* %call27)
  br label %return

if.end29:                                         ; preds = %if.end22
  %13 = load %struct._cass_env_t*, %struct._cass_env_t** @env, align 8
  %vec_dist = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %13, i64 0, i32 6
  %call30 = call fastcc i32 @cass_reg_lookup(%struct.cass_reg_t* %vec_dist, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.4.403, i64 0, i64 0))
  store i32 %call30, i32* @vec_dist_id, align 4
  %cmp31 = icmp sgt i32 %call30, -1
  br i1 %cmp31, label %if.end34, label %if.else33

if.else33:                                        ; preds = %if.end29
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @51, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.24, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 472, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__PRETTY_FUNCTION__.main, i64 0, i64 0)) #16
  unreachable

if.end34:                                         ; preds = %if.end29
  %vecset_dist = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %13, i64 0, i32 5
  %call35 = call fastcc i32 @cass_reg_lookup(%struct.cass_reg_t* %vecset_dist, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.418, i64 0, i64 0))
  store i32 %call35, i32* @vecset_dist_id, align 4
  %cmp36 = icmp sgt i32 %call35, -1
  br i1 %cmp36, label %if.end39, label %if.else38

if.else38:                                        ; preds = %if.end34
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @52, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.26, i64 0, i64 0), i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.3, i64 0, i64 0), i32 475, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__PRETTY_FUNCTION__.main, i64 0, i64 0)) #16
  unreachable

if.end39:                                         ; preds = %if.end34
  %table = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %13, i64 0, i32 2
  %14 = load i8*, i8** @table_name, align 8
  %call40 = call fastcc i32 @cass_reg_lookup(%struct.cass_reg_t* %table, i8* %14)
  %call42 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %table, i32 %call40)
  store i8* %call42, i8** bitcast (%struct._cass_table** @query_table to i8**), align 8
  store i8* %call42, i8** bitcast (%struct._cass_table** @table to i8**), align 8
  %parent_id = getelementptr inbounds i8, i8* %call42, i64 32
  %15 = bitcast i8* %parent_id to i32*
  %16 = load i32, i32* %15, align 8
  %cmp43 = icmp sgt i32 %16, -1
  %17 = bitcast i8* %call42 to %struct._cass_table*
  br i1 %cmp43, label %if.end47, label %if.end51

if.end47:                                         ; preds = %if.end39
  %call46 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %table, i32 %16)
  store i8* %call46, i8** bitcast (%struct._cass_table** @query_table to i8**), align 8
  %18 = bitcast i8* %call46 to %struct._cass_table*
  %cmp48 = icmp eq %struct._cass_table* %18, %17
  br i1 %cmp48, label %if.end51, label %if.then49

if.then49:                                        ; preds = %if.end47
  call fastcc void @cass_table_load(%struct._cass_table* %18)
  %.pre = load %struct._cass_table*, %struct._cass_table** @query_table, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.end39, %if.end47, %if.then49
  %19 = phi %struct._cass_table* [ %18, %if.end47 ], [ %.pre, %if.then49 ], [ %17, %if.end39 ]
  %map = getelementptr inbounds %struct._cass_table, %struct._cass_table* %19, i64 0, i32 15
  %20 = load %struct.cass_map_t*, %struct.cass_map_t** %map, align 8
  call fastcc void @cass_map_load(%struct.cass_map_t* %20)
  %21 = load %struct._cass_table*, %struct._cass_table** @table, align 8
  call fastcc void @cass_table_load(%struct._cass_table* %21)
  call fastcc void @stimer_tick(%struct.stimer_t* nonnull %tmr)
  %22 = load i32, i32* @DEPTH, align 4
  call fastcc void @queue_init(%struct.queue* nonnull @q_load_seg, i32 %22, i32 1)
  %23 = load i32, i32* @DEPTH, align 4
  %24 = load i32, i32* @NTHREAD_SEG, align 4
  call fastcc void @queue_init(%struct.queue* nonnull @q_seg_extract, i32 %23, i32 %24)
  %25 = load i32, i32* @DEPTH, align 4
  %26 = load i32, i32* @NTHREAD_EXTRACT, align 4
  call fastcc void @queue_init(%struct.queue* nonnull @q_extract_vec, i32 %25, i32 %26)
  %27 = load i32, i32* @DEPTH, align 4
  %28 = load i32, i32* @NTHREAD_VEC, align 4
  call fastcc void @queue_init(%struct.queue* nonnull @q_vec_rank, i32 %27, i32 %28)
  %29 = load i32, i32* @DEPTH, align 4
  %30 = load i32, i32* @NTHREAD_RANK, align 4
  call fastcc void @queue_init(%struct.queue* nonnull @q_rank_out, i32 %29, i32 %30)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @53, i32 0, i32 0))
  %call56 = call noalias i8* @calloc(i64 1, i64 24) #11
  %31 = bitcast i8* %call56 to %struct.tdesc_s*
  %32 = load i32, i32* @NTHREAD_SEG, align 4
  %conv57 = sext i32 %32 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @54, i32 0, i32 0))
  %call58 = call noalias i8* @calloc(i64 %conv57, i64 24) #11
  %33 = load i32, i32* @NTHREAD_EXTRACT, align 4
  %conv59 = sext i32 %33 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @55, i32 0, i32 0))
  %call60 = call noalias i8* @calloc(i64 %conv59, i64 24) #11
  %34 = load i32, i32* @NTHREAD_VEC, align 4
  %conv61 = sext i32 %34 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @56, i32 0, i32 0))
  %call62 = call noalias i8* @calloc(i64 %conv61, i64 24) #11
  %35 = load i32, i32* @NTHREAD_RANK, align 4
  %conv63 = sext i32 %35 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @57, i32 0, i32 0))
  %call64 = call noalias i8* @calloc(i64 %conv63, i64 24) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @58, i32 0, i32 0))
  %call66 = call noalias i8* @calloc(i64 1, i64 24) #11
  %start_routine = getelementptr inbounds i8, i8* %call56, i64 8
  %36 = bitcast i8* %start_routine to i8* (i8*)**
  store i8* (i8*)* @t_load, i8* (i8*)** %36, align 8
  %37 = load i64, i64* bitcast (i8** @query_dir to i64*), align 8
  %arg = getelementptr inbounds i8, i8* %call56, i64 16
  %38 = bitcast i8* %arg to i64*
  store i64 %37, i64* %38, align 8
  %39 = bitcast i8* %call58 to %struct.tdesc_s*
  %40 = bitcast i8* %call60 to %struct.tdesc_s*
  %41 = bitcast i8* %call62 to %struct.tdesc_s*
  %42 = bitcast i8* %call64 to %struct.tdesc_s*
  %43 = bitcast i8* %call66 to %struct.tdesc_s*
  %start_routine77 = getelementptr inbounds i8, i8* %call58, i64 8
  %44 = bitcast i8* %start_routine77 to i8* (i8*)**
  store i8* (i8*)* @t_seg, i8* (i8*)** %44, align 8
  %45 = sext i32 %32 to i64
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc87, %if.end51
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc87 ], [ 1, %if.end51 ]
  %cmp81 = icmp slt i64 %indvars.iv8, %45
  br i1 %cmp81, label %for.inc87, label %for.end89

for.inc87:                                        ; preds = %for.cond80
  %arrayidx85 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %39, i64 %indvars.iv8
  %46 = bitcast %struct.tdesc_s* %arrayidx85 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %46, i8* %call58, i64 24, i32 8, i1 false)
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  br label %for.cond80

for.end89:                                        ; preds = %for.cond80
  %start_routine93 = getelementptr inbounds i8, i8* %call60, i64 8
  %47 = bitcast i8* %start_routine93 to i8* (i8*)**
  store i8* (i8*)* @t_extract, i8* (i8*)** %47, align 8
  %48 = sext i32 %33 to i64
  br label %for.cond96

for.cond96:                                       ; preds = %for.inc103, %for.end89
  %indvars.iv6 = phi i64 [ %indvars.iv.next7, %for.inc103 ], [ 1, %for.end89 ]
  %cmp97 = icmp slt i64 %indvars.iv6, %48
  br i1 %cmp97, label %for.inc103, label %for.end105

for.inc103:                                       ; preds = %for.cond96
  %arrayidx101 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %40, i64 %indvars.iv6
  %49 = bitcast %struct.tdesc_s* %arrayidx101 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %49, i8* %call60, i64 24, i32 8, i1 false)
  %indvars.iv.next7 = add nuw nsw i64 %indvars.iv6, 1
  br label %for.cond96

for.end105:                                       ; preds = %for.cond96
  %start_routine109 = getelementptr inbounds i8, i8* %call62, i64 8
  %50 = bitcast i8* %start_routine109 to i8* (i8*)**
  store i8* (i8*)* @t_vec, i8* (i8*)** %50, align 8
  %51 = sext i32 %34 to i64
  br label %for.cond112

for.cond112:                                      ; preds = %for.inc119, %for.end105
  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %for.inc119 ], [ 1, %for.end105 ]
  %cmp113 = icmp slt i64 %indvars.iv4, %51
  br i1 %cmp113, label %for.inc119, label %for.end121

for.inc119:                                       ; preds = %for.cond112
  %arrayidx117 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %41, i64 %indvars.iv4
  %52 = bitcast %struct.tdesc_s* %arrayidx117 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %call62, i64 24, i32 8, i1 false)
  %indvars.iv.next5 = add nuw nsw i64 %indvars.iv4, 1
  br label %for.cond112

for.end121:                                       ; preds = %for.cond112
  %start_routine125 = getelementptr inbounds i8, i8* %call64, i64 8
  %53 = bitcast i8* %start_routine125 to i8* (i8*)**
  store i8* (i8*)* @t_rank, i8* (i8*)** %53, align 8
  %54 = sext i32 %35 to i64
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc135, %for.end121
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc135 ], [ 1, %for.end121 ]
  %cmp129 = icmp slt i64 %indvars.iv2, %54
  br i1 %cmp129, label %for.inc135, label %for.end137

for.inc135:                                       ; preds = %for.cond128
  %arrayidx133 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %42, i64 %indvars.iv2
  %55 = bitcast %struct.tdesc_s* %arrayidx133 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %55, i8* %call64, i64 24, i32 8, i1 false)
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1
  br label %for.cond128

for.end137:                                       ; preds = %for.cond128
  %start_routine141 = getelementptr inbounds i8, i8* %call66, i64 8
  %56 = bitcast i8* %start_routine141 to i8* (i8*)**
  store i8* (i8*)* @t_out, i8* (i8*)** %56, align 8
  store i32 0, i32* @cnt_dequeue, align 4
  store i32 0, i32* @cnt_enqueue, align 4
  %call154 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %31, i32 1)
  %57 = load i32, i32* @NTHREAD_SEG, align 4
  %call155 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %39, i32 %57)
  %58 = load i32, i32* @NTHREAD_EXTRACT, align 4
  %call156 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %40, i32 %58)
  %59 = load i32, i32* @NTHREAD_VEC, align 4
  %call157 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %41, i32 %59)
  %60 = load i32, i32* @NTHREAD_RANK, align 4
  %call158 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %42, i32 %60)
  %call159 = call fastcc %struct.tpool_s* @tpool_create(%struct.tdesc_s* %43, i32 1)
  call fastcc void @tpool_join(%struct.tpool_s* %call159)
  call fastcc void @tpool_join(%struct.tpool_s* %call158)
  call fastcc void @tpool_join(%struct.tpool_s* %call157)
  call fastcc void @tpool_join(%struct.tpool_s* %call156)
  call fastcc void @tpool_join(%struct.tpool_s* %call155)
  call fastcc void @tpool_join(%struct.tpool_s* %call154)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call154)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call155)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call156)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call157)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call158)
  call fastcc void @tpool_destroy(%struct.tpool_s* %call159)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @59, i32 0, i32 0))
  call void @free(i8* %call56) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @60, i32 0, i32 0))
  call void @free(i8* %call58) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @61, i32 0, i32 0))
  call void @free(i8* %call60) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @62, i32 0, i32 0))
  call void @free(i8* %call62) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @63, i32 0, i32 0))
  call void @free(i8* %call64) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @64, i32 0, i32 0))
  call void @free(i8* %call66) #11
  call fastcc void @queue_destroy(%struct.queue* nonnull @q_load_seg)
  call fastcc void @queue_destroy(%struct.queue* nonnull @q_seg_extract)
  call fastcc void @queue_destroy(%struct.queue* nonnull @q_extract_vec)
  call fastcc void @queue_destroy(%struct.queue* nonnull @q_vec_rank)
  call fastcc void @queue_destroy(%struct.queue* nonnull @q_rank_out)
  call fastcc void @stimer_tuck(%struct.stimer_t* nonnull %tmr)
  %61 = load %struct._cass_env_t*, %struct._cass_env_t** @env, align 8
  call fastcc void @cass_env_close(%struct._cass_env_t* %61)
  call fastcc void @cass_cleanup()
  %62 = load %struct._IO_FILE*, %struct._IO_FILE** @fout, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @65, i32 0, i32 0))
  %call176 = call i32 @fclose(%struct._IO_FILE* %62)
  br label %return

return:                                           ; preds = %for.end137, %if.then26, %if.then
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @printf(i8* nocapture readonly, ...) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @fflush(%struct._IO_FILE* nocapture) local_unnamed_addr #1

; Function Attrs: nounwind readonly
declare i32 @atoi(i8* nocapture) local_unnamed_addr #3

; Function Attrs: nounwind
declare noalias %struct._IO_FILE* @fopen(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_table_load(%struct._cass_table* %table) unnamed_addr #0 {
entry:
  %opr = getelementptr inbounds %struct._cass_table, %struct._cass_table* %table, i64 0, i32 9
  %0 = load %struct._cass_table_opr*, %struct._cass_table_opr** %opr, align 8
  %load = getelementptr inbounds %struct._cass_table_opr, %struct._cass_table_opr* %0, i64 0, i32 12
  %1 = load i32 (%struct._cass_table*)*, i32 (%struct._cass_table*)** %load, align 8
  %call = call i32 %1(%struct._cass_table* %table) #11
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %loaded = getelementptr inbounds %struct._cass_table, %struct._cass_table* %table, i64 0, i32 10
  store i32 1, i32* %loaded, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind
declare i32 @fclose(%struct._IO_FILE* nocapture) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.tpool_s* @tpool_create(%struct.tdesc_s* readonly %opts, i32 %nthreads) unnamed_addr #0 {
entry:
  %cmp = icmp eq %struct.tdesc_s* %opts, null
  %cmp1 = icmp slt i32 %nthreads, 1
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %0 = sext i32 %nthreads to i64
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv1 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next2, %for.inc ]
  %cmp2 = icmp slt i64 %indvars.iv1, %0
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %start_routine = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %opts, i64 %indvars.iv1, i32 1
  %1 = load i8* (i8*)*, i8* (i8*)** %start_routine, align 8
  %cmp3 = icmp eq i8* (i8*)* %1, null
  br i1 %cmp3, label %return, label %for.inc

for.inc:                                          ; preds = %for.body
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @66, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 24) #11
  %2 = bitcast i8* %call to %struct.tpool_s*
  %cmp6 = icmp eq i8* %call, null
  br i1 %cmp6, label %return, label %if.end8

if.end8:                                          ; preds = %for.end
  %conv = sext i32 %nthreads to i64
  %mul = shl nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @67, i32 0, i32 0))
  %call9 = call noalias i8* @malloc(i64 %mul) #11
  %threads = getelementptr inbounds i8, i8* %call, i64 8
  %3 = bitcast i8* %threads to i8**
  store i8* %call9, i8** %3, align 8
  %cmp11 = icmp eq i8* %call9, null
  %4 = bitcast i8* %call9 to i64*
  br i1 %cmp11, label %if.then13, label %for.cond15.preheader

for.cond15.preheader:                             ; preds = %if.end8
  %5 = sext i32 %nthreads to i64
  br label %for.cond15

if.then13:                                        ; preds = %if.end8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @68, i32 0, i32 0))
  call void @free(i8* %call) #11
  br label %return

for.cond15:                                       ; preds = %for.cond15.preheader, %for.inc52
  %indvars.iv = phi i64 [ 0, %for.cond15.preheader ], [ %indvars.iv.next, %for.inc52 ]
  %cmp16 = icmp slt i64 %indvars.iv, %5
  br i1 %cmp16, label %for.body18, label %for.end54

for.body18:                                       ; preds = %for.cond15
  %attr21 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %opts, i64 %indvars.iv, i32 0
  %6 = load %union.pthread_attr_t*, %union.pthread_attr_t** %attr21, align 8
  %arg31 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %opts, i64 %indvars.iv, i32 2
  %7 = load i8*, i8** %arg31, align 8
  %arrayidx42 = getelementptr inbounds i64, i64* %4, i64 %indvars.iv
  %start_routine45 = getelementptr inbounds %struct.tdesc_s, %struct.tdesc_s* %opts, i64 %indvars.iv, i32 1
  %8 = load i8* (i8*)*, i8* (i8*)** %start_routine45, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @69, i32 0, i32 0))
  %call46 = call i32 @pthread_create(i64* %arrayidx42, %union.pthread_attr_t* %6, i8* (i8*)* %8, i8* %7) #11
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %for.inc52, label %if.then49

if.then49:                                        ; preds = %for.body18
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @70, i32 0, i32 0))
  call void @free(i8* %call9) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @71, i32 0, i32 0))
  call void @free(i8* %call) #11
  br label %return

for.inc52:                                        ; preds = %for.body18
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond15

for.end54:                                        ; preds = %for.cond15
  %nthreads55 = bitcast i8* %call to i32*
  store i32 %nthreads, i32* %nthreads55, align 8
  %state = getelementptr inbounds i8, i8* %call, i64 16
  %9 = bitcast i8* %state to i32*
  store i32 1, i32* %9, align 8
  br label %return

return:                                           ; preds = %for.body, %for.end, %entry, %for.end54, %if.then49, %if.then13
  %retval.0 = phi %struct.tpool_s* [ null, %if.then13 ], [ null, %if.then49 ], [ %2, %for.end54 ], [ null, %entry ], [ null, %for.end ], [ null, %for.body ]
  ret %struct.tpool_s* %retval.0
}

; Function Attrs: nounwind
declare i32 @pthread_create(i64*, %union.pthread_attr_t*, i8* (i8*)*, i8*) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @tpool_destroy(%struct.tpool_s* %pool) unnamed_addr #0 {
entry:
  %cmp = icmp eq %struct.tpool_s* %pool, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @72, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.1.29, i64 0, i64 0), i32 105, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__PRETTY_FUNCTION__.tpool_destroy, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.tpool_s, %struct.tpool_s* %pool, i64 0, i32 2
  %0 = load i32, i32* %state, align 8
  %cmp1 = icmp eq i32 %0, 1
  br i1 %cmp1, label %if.else3, label %if.end4

if.else3:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @73, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.2.30, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.1.29, i64 0, i64 0), i32 106, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__PRETTY_FUNCTION__.tpool_destroy, i64 0, i64 0)) #16
  unreachable

if.end4:                                          ; preds = %if.end
  %threads = getelementptr inbounds %struct.tpool_s, %struct.tpool_s* %pool, i64 0, i32 1
  %1 = bitcast i64** %threads to i8**
  %2 = load i8*, i8** %1, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @74, i32 0, i32 0))
  call void @free(i8* %2) #11
  %3 = bitcast %struct.tpool_s* %pool to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @75, i32 0, i32 0))
  call void @free(i8* %3) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @tpool_join(%struct.tpool_s* %pool) unnamed_addr #0 {
entry:
  %cmp = icmp eq %struct.tpool_s* %pool, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @76, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.1.29, i64 0, i64 0), i32 125, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__PRETTY_FUNCTION__.tpool_join, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.tpool_s, %struct.tpool_s* %pool, i64 0, i32 2
  %0 = load i32, i32* %state, align 8
  %cmp1 = icmp eq i32 %0, 1
  br i1 %cmp1, label %for.cond.preheader, label %if.else3

for.cond.preheader:                               ; preds = %if.end
  %nthreads = getelementptr inbounds %struct.tpool_s, %struct.tpool_s* %pool, i64 0, i32 0
  %threads = getelementptr inbounds %struct.tpool_s, %struct.tpool_s* %pool, i64 0, i32 1
  br label %for.cond

if.else3:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @77, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3.33, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.1.29, i64 0, i64 0), i32 126, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__PRETTY_FUNCTION__.tpool_join, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %1 = load i32, i32* %nthreads, align 8
  %2 = sext i32 %1 to i64
  %cmp5 = icmp slt i64 %indvars.iv, %2
  br i1 %cmp5, label %if.end9, label %return

if.end9:                                          ; preds = %for.cond
  %3 = load i64*, i64** %threads, align 8
  %arrayidx11 = getelementptr inbounds i64, i64* %3, i64 %indvars.iv
  %4 = load i64, i64* %arrayidx11, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @78, i32 0, i32 0))
  %call = call i32 @pthread_join(i64 %4, i8** null) #11
  %cmp12 = icmp eq i32 %call, 0
  br i1 %cmp12, label %for.inc, label %return

for.inc:                                          ; preds = %if.end9
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

return:                                           ; preds = %for.cond, %if.end9
  %storemerge = phi i32 [ 2, %if.end9 ], [ 0, %for.cond ]
  store i32 %storemerge, i32* %state, align 8
  ret void
}

declare i32 @pthread_join(i64, i8**) local_unnamed_addr #2

; Function Attrs: noreturn nounwind
declare void @exit(i32) local_unnamed_addr #4

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_env_open(i8* %base_dir) unnamed_addr #0 {
entry:
  %buf = alloca [8192 x i8], align 16
  %n = alloca i32, align 4
  %table58 = alloca %struct._cass_table.19*, align 8
  %cfg81 = alloca %struct._cass_vecset_cfg_t*, align 8
  %map108 = alloca %struct.cass_map_t*, align 8
  %dist = alloca %struct.cass_vecset_dist_t*, align 8
  %j = alloca i32, align 4
  %dist170 = alloca %struct.cass_vec_dist_t*, align 8
  %i171 = alloca i32, align 4
  %cmp = icmp eq i8* %base_dir, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call fastcc i32 @dexist(i8* nonnull %base_dir)
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  %arraydecay = getelementptr inbounds [8192 x i8], [8192 x i8]* %buf, i64 0, i64 0
  call fastcc void @mkpath(i8* %arraydecay, i8* nonnull %base_dir)
  %call8 = call fastcc i32 @fexist(i8* %arraydecay)
  %tobool9 = icmp eq i32 %call8, 0
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @79, i32 0, i32 0))
  %call11 = call noalias i8* @calloc(i64 136, i64 1) #11
  %0 = bitcast i8* %call11 to %struct._cass_env_t*
  %cmp12 = icmp eq i8* %call11, null
  br i1 %tobool9, label %if.then10, label %if.end30

if.then10:                                        ; preds = %if.end6
  br i1 %cmp12, label %return, label %if.end14

if.end14:                                         ; preds = %if.then10
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @80, i32 0, i32 0))
  %call15 = call noalias i8* @strdup(i8* %base_dir) #11
  %base_dir16 = getelementptr inbounds i8, i8* %call11, i64 8
  %1 = bitcast i8* %base_dir16 to i8**
  store i8* %call15, i8** %1, align 8
  %cmp18 = icmp eq i8* %call15, null
  br i1 %cmp18, label %if.then202, label %if.end20

if.end20:                                         ; preds = %if.end14
  %table = getelementptr inbounds i8, i8* %call11, i64 16
  %2 = bitcast i8* %table to %struct.cass_reg_t*
  call fastcc void @cass_reg_init(%struct.cass_reg_t* %2)
  %cfg = getelementptr inbounds i8, i8* %call11, i64 40
  %3 = bitcast i8* %cfg to %struct.cass_reg_t*
  call fastcc void @cass_reg_init(%struct.cass_reg_t* %3)
  %map = getelementptr inbounds i8, i8* %call11, i64 64
  %4 = bitcast i8* %map to %struct.cass_reg_t*
  call fastcc void @cass_reg_init(%struct.cass_reg_t* %4)
  %vecset_dist = getelementptr inbounds i8, i8* %call11, i64 88
  %5 = bitcast i8* %vecset_dist to %struct.cass_reg_t*
  call fastcc void @cass_reg_init(%struct.cass_reg_t* %5)
  %vec_dist = getelementptr inbounds i8, i8* %call11, i64 112
  %6 = bitcast i8* %vec_dist to %struct.cass_reg_t*
  call fastcc void @cass_reg_init(%struct.cass_reg_t* %6)
  store i8* %call11, i8** bitcast (%struct._cass_env_t** @env to i8**), align 8
  br label %return

if.end30:                                         ; preds = %if.end6
  br i1 %cmp12, label %return, label %if.end34

if.end34:                                         ; preds = %if.end30
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @81, i32 0, i32 0))
  %call35 = call noalias i8* @strdup(i8* %base_dir) #11
  %base_dir36 = getelementptr inbounds i8, i8* %call11, i64 8
  %7 = bitcast i8* %base_dir36 to i8**
  store i8* %call35, i8** %7, align 8
  %cmp38 = icmp eq i8* %call35, null
  br i1 %cmp38, label %if.then202, label %if.end40

if.end40:                                         ; preds = %if.end34
  %mode = bitcast i8* %call11 to i32*
  store i32 0, i32* %mode, align 8
  %call42 = call fastcc %struct._IO_FILE* @cass_open(i8* %arraydecay)
  %cmp43 = icmp eq %struct._IO_FILE* %call42, null
  br i1 %cmp43, label %if.then202, label %if.end45

if.end45:                                         ; preds = %if.end40
  %call46 = call fastcc i32 @cass_read_uint32(i32* nonnull %n, %struct._IO_FILE* nonnull %call42)
  %cmp47 = icmp eq i32 %call46, 1
  br i1 %cmp47, label %if.end49, label %if.then202

if.end49:                                         ; preds = %if.end45
  %table50 = getelementptr inbounds i8, i8* %call11, i64 16
  %8 = bitcast i8* %table50 to %struct.cass_reg_t*
  %9 = load i32, i32* %n, align 4
  call fastcc void @cass_reg_init_size(%struct.cass_reg_t* %8, i32 %9)
  %cmp52 = icmp eq i32 %9, 0
  br i1 %cmp52, label %for.cond, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end49
  %data = getelementptr inbounds i8, i8* %call11, i64 32
  %10 = bitcast i8* %data to %struct.cass_reg_entry_t**
  %11 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %10, align 8
  %cmp54 = icmp eq %struct.cass_reg_entry_t* %11, null
  br i1 %cmp54, label %if.then202, label %for.cond

for.cond:                                         ; preds = %land.lhs.true, %if.end49, %for.inc
  %ret.0 = phi i32 [ 0, %for.inc ], [ -9995, %if.end49 ], [ -9995, %land.lhs.true ]
  %i.0 = phi i32 [ %inc, %for.inc ], [ 0, %if.end49 ], [ 0, %land.lhs.true ]
  %cmp57 = icmp ult i32 %i.0, %9
  br i1 %cmp57, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call59 = call fastcc i32 @cass_table_restore(%struct._cass_table.19** nonnull %table58, %struct._cass_env_t* %0, %struct._IO_FILE* nonnull %call42)
  %cmp60 = icmp eq i32 %call59, 0
  br i1 %cmp60, label %for.inc, label %err

for.inc:                                          ; preds = %for.body
  %12 = load %struct._cass_table.19*, %struct._cass_table.19** %table58, align 8
  %name = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %12, i64 0, i32 1
  %13 = load i8*, i8** %name, align 8
  %.cast4 = bitcast %struct._cass_table.19* %12 to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* %8, i8* %13, i8* %.cast4)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call65 = call fastcc i32 @cass_read_uint32(i32* nonnull %n, %struct._IO_FILE* nonnull %call42)
  %cmp66 = icmp eq i32 %call65, 1
  br i1 %cmp66, label %if.end68, label %err

if.end68:                                         ; preds = %for.end
  %cfg69 = getelementptr inbounds i8, i8* %call11, i64 40
  %14 = bitcast i8* %cfg69 to %struct.cass_reg_t*
  %15 = load i32, i32* %n, align 4
  call fastcc void @cass_reg_init_size(%struct.cass_reg_t* %14, i32 %15)
  %cmp71 = icmp eq i32 %15, 0
  br i1 %cmp71, label %for.cond78, label %land.lhs.true72

land.lhs.true72:                                  ; preds = %if.end68
  %data74 = getelementptr inbounds i8, i8* %call11, i64 56
  %16 = bitcast i8* %data74 to %struct.cass_reg_entry_t**
  %17 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %16, align 8
  %cmp75 = icmp eq %struct.cass_reg_entry_t* %17, null
  br i1 %cmp75, label %if.then202, label %for.cond78

for.cond78:                                       ; preds = %land.lhs.true72, %if.end68, %for.inc89
  %ret.1 = phi i32 [ 0, %for.inc89 ], [ -9995, %if.end68 ], [ -9995, %land.lhs.true72 ]
  %i.1 = phi i32 [ %inc90, %for.inc89 ], [ 0, %if.end68 ], [ 0, %land.lhs.true72 ]
  %cmp79 = icmp ult i32 %i.1, %15
  br i1 %cmp79, label %for.body80, label %for.end91

for.body80:                                       ; preds = %for.cond78
  %call82 = call fastcc i32 @cass_vecset_cfg_restore(%struct._cass_vecset_cfg_t** nonnull %cfg81, %struct._IO_FILE* nonnull %call42)
  %cmp83 = icmp eq i32 %call82, 0
  br i1 %cmp83, label %for.inc89, label %err

for.inc89:                                        ; preds = %for.body80
  %18 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %cfg81, align 8
  %name87 = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %18, i64 0, i32 1
  %19 = load i8*, i8** %name87, align 8
  %.cast3 = bitcast %struct._cass_vecset_cfg_t* %18 to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* %14, i8* %19, i8* %.cast3)
  %inc90 = add i32 %i.1, 1
  br label %for.cond78

for.end91:                                        ; preds = %for.cond78
  %call92 = call fastcc i32 @cass_read_uint32(i32* nonnull %n, %struct._IO_FILE* nonnull %call42)
  %cmp93 = icmp eq i32 %call92, 1
  br i1 %cmp93, label %if.end95, label %err

if.end95:                                         ; preds = %for.end91
  %map96 = getelementptr inbounds i8, i8* %call11, i64 64
  %20 = bitcast i8* %map96 to %struct.cass_reg_t*
  %21 = load i32, i32* %n, align 4
  call fastcc void @cass_reg_init_size(%struct.cass_reg_t* %20, i32 %21)
  %cmp98 = icmp eq i32 %21, 0
  br i1 %cmp98, label %for.cond105, label %land.lhs.true99

land.lhs.true99:                                  ; preds = %if.end95
  %data101 = getelementptr inbounds i8, i8* %call11, i64 80
  %22 = bitcast i8* %data101 to %struct.cass_reg_entry_t**
  %23 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %22, align 8
  %cmp102 = icmp eq %struct.cass_reg_entry_t* %23, null
  br i1 %cmp102, label %if.then202, label %for.cond105

for.cond105:                                      ; preds = %land.lhs.true99, %if.end95, %for.inc116
  %ret.2 = phi i32 [ 0, %for.inc116 ], [ -9995, %if.end95 ], [ -9995, %land.lhs.true99 ]
  %i.2 = phi i32 [ %inc117, %for.inc116 ], [ 0, %if.end95 ], [ 0, %land.lhs.true99 ]
  %cmp106 = icmp ult i32 %i.2, %21
  br i1 %cmp106, label %for.body107, label %for.end118

for.body107:                                      ; preds = %for.cond105
  %call109 = call fastcc i32 @cass_map_restore(%struct.cass_map_t** nonnull %map108, %struct._cass_env_t* %0, %struct._IO_FILE* nonnull %call42)
  %cmp110 = icmp eq i32 %call109, 0
  br i1 %cmp110, label %for.inc116, label %err

for.inc116:                                       ; preds = %for.body107
  %24 = load %struct.cass_map_t*, %struct.cass_map_t** %map108, align 8
  %name114 = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %24, i64 0, i32 2
  %25 = load i8*, i8** %name114, align 8
  %.cast2 = bitcast %struct.cass_map_t* %24 to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* %20, i8* %25, i8* %.cast2)
  %inc117 = add i32 %i.2, 1
  br label %for.cond105

for.end118:                                       ; preds = %for.cond105
  %call119 = call fastcc i32 @cass_read_uint32(i32* nonnull %n, %struct._IO_FILE* nonnull %call42)
  %cmp120 = icmp eq i32 %call119, 1
  br i1 %cmp120, label %if.end122, label %err

if.end122:                                        ; preds = %for.end118
  %vecset_dist123 = getelementptr inbounds i8, i8* %call11, i64 88
  %26 = bitcast i8* %vecset_dist123 to %struct.cass_reg_t*
  %27 = load i32, i32* %n, align 4
  call fastcc void @cass_reg_init_size(%struct.cass_reg_t* %26, i32 %27)
  %cmp125 = icmp eq i32 %27, 0
  br i1 %cmp125, label %for.cond132.preheader, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %if.end122
  %data128 = getelementptr inbounds i8, i8* %call11, i64 104
  %28 = bitcast i8* %data128 to %struct.cass_reg_entry_t**
  %29 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %28, align 8
  %cmp129 = icmp eq %struct.cass_reg_entry_t* %29, null
  br i1 %cmp129, label %if.then202, label %for.cond132.preheader

for.cond132.preheader:                            ; preds = %if.end122, %land.lhs.true126
  %30 = bitcast %struct.cass_vecset_dist_t** %dist to i8**
  br label %for.cond132

for.cond132:                                      ; preds = %for.cond132.preheader, %for.inc150
  %ret.3 = phi i32 [ 0, %for.inc150 ], [ -9995, %for.cond132.preheader ]
  %i.3 = phi i32 [ %inc151, %for.inc150 ], [ 0, %for.cond132.preheader ]
  %cmp133 = icmp ult i32 %i.3, %27
  br i1 %cmp133, label %for.body134, label %for.end152

for.body134:                                      ; preds = %for.cond132
  %call135 = call fastcc i32 @cass_read_uint32(i32* nonnull %j, %struct._IO_FILE* nonnull %call42)
  %cmp136 = icmp eq i32 %call135, 1
  br i1 %cmp136, label %if.end138, label %err

if.end138:                                        ; preds = %for.body134
  %31 = load i32, i32* %j, align 4
  %call139 = call fastcc %struct._cass_vecset_dist_class* @cass_vecset_dist_class_get(i32 %31)
  %cmp140 = icmp eq %struct._cass_vecset_dist_class* %call139, null
  br i1 %cmp140, label %if.else, label %if.end142

if.else:                                          ; preds = %if.end138
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @82, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3.39, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 155, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.cass_env_open, i64 0, i64 0)) #16
  unreachable

if.end142:                                        ; preds = %if.end138
  %restore = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %call139, i64 0, i32 7
  %32 = load i32 (i8**, %struct._IO_FILE*)*, i32 (i8**, %struct._IO_FILE*)** %restore, align 8
  %call143 = call i32 %32(i8** %30, %struct._IO_FILE* nonnull %call42) #11
  %cmp144 = icmp eq i32 %call143, 0
  br i1 %cmp144, label %for.inc150, label %err

for.inc150:                                       ; preds = %if.end142
  %33 = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %dist, align 8
  %name148 = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %33, i64 0, i32 1
  %34 = load i8*, i8** %name148, align 8
  %.cast1 = bitcast %struct.cass_vecset_dist_t* %33 to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* %26, i8* %34, i8* %.cast1)
  %inc151 = add i32 %i.3, 1
  br label %for.cond132

for.end152:                                       ; preds = %for.cond132
  %call153 = call fastcc i32 @cass_read_uint32(i32* nonnull %n, %struct._IO_FILE* nonnull %call42)
  %cmp154 = icmp eq i32 %call153, 1
  br i1 %cmp154, label %if.end156, label %err

if.end156:                                        ; preds = %for.end152
  %vec_dist157 = getelementptr inbounds i8, i8* %call11, i64 112
  %35 = bitcast i8* %vec_dist157 to %struct.cass_reg_t*
  %36 = load i32, i32* %n, align 4
  call fastcc void @cass_reg_init_size(%struct.cass_reg_t* %35, i32 %36)
  %cmp159 = icmp eq i32 %36, 0
  br i1 %cmp159, label %for.cond166.preheader, label %land.lhs.true160

land.lhs.true160:                                 ; preds = %if.end156
  %data162 = getelementptr inbounds i8, i8* %call11, i64 128
  %37 = bitcast i8* %data162 to %struct.cass_reg_entry_t**
  %38 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %37, align 8
  %cmp163 = icmp eq %struct.cass_reg_entry_t* %38, null
  br i1 %cmp163, label %if.then202, label %for.cond166.preheader

for.cond166.preheader:                            ; preds = %if.end156, %land.lhs.true160
  %39 = bitcast %struct.cass_vec_dist_t** %dist170 to i8**
  br label %for.cond166

for.cond166:                                      ; preds = %for.cond166.preheader, %for.inc185
  %i.4 = phi i32 [ %inc186, %for.inc185 ], [ 0, %for.cond166.preheader ]
  %cmp167 = icmp ult i32 %i.4, %36
  br i1 %cmp167, label %for.body168, label %do.body

for.body168:                                      ; preds = %for.cond166
  %call172 = call fastcc i32 @cass_read_uint32(i32* nonnull %i171, %struct._IO_FILE* nonnull %call42)
  %cmp173 = icmp eq i32 %call172, 1
  br i1 %cmp173, label %if.end175, label %err

if.end175:                                        ; preds = %for.body168
  %40 = load i32, i32* %i171, align 4
  %call176 = call fastcc %struct._cass_vec_dist_class* @cass_vec_dist_class_get(i32 %40)
  %restore177 = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %call176, i64 0, i32 7
  %41 = load i32 (i8**, %struct._IO_FILE*)*, i32 (i8**, %struct._IO_FILE*)** %restore177, align 8
  %call178 = call i32 %41(i8** %39, %struct._IO_FILE* nonnull %call42) #11
  %cmp179 = icmp eq i32 %call178, 0
  br i1 %cmp179, label %for.inc185, label %err

for.inc185:                                       ; preds = %if.end175
  %42 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %dist170, align 8
  %name183 = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %42, i64 0, i32 1
  %43 = load i8*, i8** %name183, align 8
  %.cast = bitcast %struct.cass_vec_dist_t* %42 to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* %35, i8* %43, i8* %.cast)
  %inc186 = add i32 %i.4, 1
  br label %for.cond166

do.body:                                          ; preds = %for.cond166
  call fastcc void @cass_close(%struct._IO_FILE* nonnull %call42)
  %len = getelementptr inbounds i8, i8* %call11, i64 24
  %44 = bitcast i8* %len to i32*
  %data193 = getelementptr inbounds i8, i8* %call11, i64 32
  %45 = bitcast i8* %data193 to %struct.cass_reg_entry_t**
  br label %for.cond188

for.cond188:                                      ; preds = %for.inc198, %do.body
  %__array_foreach_index.0 = phi i32 [ 0, %do.body ], [ %inc199, %for.inc198 ]
  %46 = load i32, i32* %44, align 8
  %cmp190 = icmp ult i32 %__array_foreach_index.0, %46
  br i1 %cmp190, label %for.body191, label %do.end

for.body191:                                      ; preds = %for.cond188
  %47 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %45, align 8
  %idxprom = zext i32 %__array_foreach_index.0 to i64
  %arrayidx = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %47, i64 %idxprom
  %ref.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx to %struct._cass_table.19**
  %ref.sroa.0.0.copyload = load %struct._cass_table.19*, %struct._cass_table.19** %ref.sroa.0.0..sroa_cast, align 8
  %call194 = call fastcc i32 @__cass_table_ref(%struct._cass_table.19* %ref.sroa.0.0.copyload)
  %cmp195 = icmp eq i32 %call194, 0
  br i1 %cmp195, label %for.inc198, label %if.then202

for.inc198:                                       ; preds = %for.body191
  %inc199 = add i32 %__array_foreach_index.0, 1
  br label %for.cond188

do.end:                                           ; preds = %for.cond188
  store i8* %call11, i8** bitcast (%struct._cass_env_t** @env to i8**), align 8
  br label %return

err:                                              ; preds = %for.body, %for.body80, %for.body107, %if.end142, %for.body134, %if.end175, %for.body168, %for.end152, %for.end118, %for.end91, %for.end
  %in.0 = phi %struct._IO_FILE* [ %call42, %for.end ], [ %call42, %for.end91 ], [ %call42, %for.end118 ], [ %call42, %for.end152 ], [ %call42, %for.body168 ], [ %call42, %if.end175 ], [ %call42, %for.body134 ], [ %call42, %if.end142 ], [ %call42, %for.body107 ], [ %call42, %for.body80 ], [ %call42, %for.body ]
  %ret.4 = phi i32 [ %ret.0, %for.end ], [ %ret.1, %for.end91 ], [ %ret.2, %for.end118 ], [ %ret.3, %for.end152 ], [ -9995, %for.body168 ], [ %call178, %if.end175 ], [ -9995, %for.body134 ], [ %call143, %if.end142 ], [ %call109, %for.body107 ], [ %call82, %for.body80 ], [ %call59, %for.body ]
  %cmp201 = icmp eq i8* %call11, null
  br i1 %cmp201, label %if.end204, label %if.then202

if.then202:                                       ; preds = %for.body191, %land.lhs.true160, %land.lhs.true126, %land.lhs.true99, %land.lhs.true72, %land.lhs.true, %if.end45, %if.end40, %if.end34, %if.end14, %err
  %ret.48 = phi i32 [ %ret.4, %err ], [ -9998, %land.lhs.true160 ], [ -9998, %land.lhs.true126 ], [ -9998, %land.lhs.true99 ], [ -9998, %land.lhs.true72 ], [ -9998, %land.lhs.true ], [ -9995, %if.end45 ], [ -9995, %if.end40 ], [ -9998, %if.end34 ], [ -9998, %if.end14 ], [ %call194, %for.body191 ]
  %in.06 = phi %struct._IO_FILE* [ %in.0, %err ], [ %call42, %land.lhs.true160 ], [ %call42, %land.lhs.true126 ], [ %call42, %land.lhs.true99 ], [ %call42, %land.lhs.true72 ], [ %call42, %land.lhs.true ], [ %call42, %if.end45 ], [ null, %if.end40 ], [ null, %if.end34 ], [ null, %if.end14 ], [ null, %for.body191 ]
  call fastcc void @cass_env_close(%struct._cass_env_t* nonnull %0)
  br label %if.end204

if.end204:                                        ; preds = %err, %if.then202
  %ret.49 = phi i32 [ %ret.4, %err ], [ %ret.48, %if.then202 ]
  %in.07 = phi %struct._IO_FILE* [ %in.0, %err ], [ %in.06, %if.then202 ]
  %cmp205 = icmp eq %struct._IO_FILE* %in.07, null
  br i1 %cmp205, label %return, label %if.then206

if.then206:                                       ; preds = %if.end204
  call fastcc void @cass_close(%struct._IO_FILE* nonnull %in.07)
  br label %return

return:                                           ; preds = %if.end30, %if.then10, %if.then206, %if.end204, %if.end, %entry, %do.end, %if.end20
  %retval.0 = phi i32 [ 0, %do.end ], [ 0, %if.end20 ], [ -9996, %entry ], [ -9996, %if.end ], [ %ret.49, %if.end204 ], [ %ret.49, %if.then206 ], [ -9998, %if.then10 ], [ -9998, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct._IO_FILE* @cass_open(i8* nocapture readonly %p) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @83, i32 0, i32 0))
  %call = call %struct._IO_FILE* @fopen(i8* %p, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23.358, i64 0, i64 0))
  ret %struct._IO_FILE* %call
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @84, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_vecset_cfg_restore(%struct._cass_vecset_cfg_t** nocapture %_cfg, %struct._IO_FILE* nocapture %out) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @85, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 40, i64 1) #11
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %out)
  %name = getelementptr inbounds i8, i8* %call, i64 8
  %0 = bitcast i8* %name to i8**
  store i8* %call1, i8** %0, align 8
  %cmp3 = icmp eq i8* %call1, null
  br i1 %cmp3, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %vecset_type = getelementptr inbounds i8, i8* %call, i64 16
  %1 = bitcast i8* %vecset_type to i32*
  %call6 = call fastcc i32 @cass_read_uint32(i32* %1, %struct._IO_FILE* %out)
  %cmp7 = icmp eq i32 %call6, 1
  br i1 %cmp7, label %if.end9, label %return

if.end9:                                          ; preds = %if.end5
  %vec_type = getelementptr inbounds i8, i8* %call, i64 20
  %2 = bitcast i8* %vec_type to i32*
  %call10 = call fastcc i32 @cass_read_uint32(i32* %2, %struct._IO_FILE* %out)
  %cmp11 = icmp eq i32 %call10, 1
  br i1 %cmp11, label %if.end13, label %return

if.end13:                                         ; preds = %if.end9
  %vec_size = getelementptr inbounds i8, i8* %call, i64 28
  %3 = bitcast i8* %vec_size to i32*
  %call14 = call fastcc i32 @cass_read_uint32(i32* %3, %struct._IO_FILE* %out)
  %cmp15 = icmp eq i32 %call14, 1
  br i1 %cmp15, label %if.end17, label %return

if.end17:                                         ; preds = %if.end13
  %vec_dim = getelementptr inbounds i8, i8* %call, i64 24
  %4 = bitcast i8* %vec_dim to i32*
  %call18 = call fastcc i32 @cass_read_uint32(i32* %4, %struct._IO_FILE* %out)
  %cmp19 = icmp eq i32 %call18, 1
  br i1 %cmp19, label %if.end21, label %return

if.end21:                                         ; preds = %if.end17
  %flag = getelementptr inbounds i8, i8* %call, i64 32
  %5 = bitcast i8* %flag to i32*
  %call22 = call fastcc i32 @cass_read_uint32(i32* %5, %struct._IO_FILE* %out)
  %cmp23 = icmp eq i32 %call22, 1
  br i1 %cmp23, label %if.end25, label %return

if.end25:                                         ; preds = %if.end21
  %6 = bitcast %struct._cass_vecset_cfg_t** %_cfg to i8**
  store i8* %call, i8** %6, align 8
  br label %return

return:                                           ; preds = %if.end21, %if.end17, %if.end13, %if.end9, %if.end5, %if.end, %entry, %if.end25
  %retval.0 = phi i32 [ 0, %if.end25 ], [ -9998, %entry ], [ -9995, %if.end ], [ -9995, %if.end5 ], [ -9995, %if.end9 ], [ -9995, %if.end13 ], [ -9995, %if.end17 ], [ -9995, %if.end21 ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc %struct._cass_vecset_dist_class* @cass_vecset_dist_class_get(i32 %i) unnamed_addr #6 {
entry:
  %call = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* nonnull @cass_vecset_dist_class_reg, i32 %i)
  %0 = bitcast i8* %call to %struct._cass_vecset_dist_class*
  ret %struct._cass_vecset_dist_class* %0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc %struct._cass_vec_dist_class* @cass_vec_dist_class_get(i32 %i) unnamed_addr #6 {
entry:
  %call = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* nonnull @cass_vec_dist_class_reg, i32 %i)
  %0 = bitcast i8* %call to %struct._cass_vec_dist_class*
  ret %struct._cass_vec_dist_class* %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_close(%struct._IO_FILE* nocapture %h) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @86, i32 0, i32 0))
  %call = call i32 @fclose(%struct._IO_FILE* %h)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @__cass_table_ref(%struct._cass_table.19* %table) unnamed_addr #0 {
entry:
  %env1 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 3
  %0 = load %struct._cass_env_t*, %struct._cass_env_t** %env1, align 8
  %cfg_id = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 5
  %1 = load i32, i32* %cfg_id, align 4
  %len = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 3, i32 2
  %2 = load i32, i32* %len, align 8
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %cmp3 = icmp sgt i32 %1, -1
  br i1 %cmp3, label %if.then4, label %if.end13

if.then4:                                         ; preds = %if.end
  %data = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 3, i32 3
  %3 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %idxprom = sext i32 %1 to i64
  %p = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %3, i64 %idxprom, i32 0
  %4 = bitcast i8** %p to i64*
  %5 = load i64, i64* %4, align 8
  %cfg7 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 13
  %6 = bitcast %struct._cass_vecset_cfg_t** %cfg7 to i64*
  store i64 %5, i64* %6, align 8
  %cmp9 = icmp eq i64 %5, 0
  br i1 %cmp9, label %if.else, label %if.end11

if.else:                                          ; preds = %if.then4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @87, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.17.43, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 415, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

if.end11:                                         ; preds = %if.then4
  %7 = inttoptr i64 %5 to %struct._cass_vecset_cfg_t*
  %refcnt = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %7, i64 0, i32 0
  %8 = load i32, i32* %refcnt, align 8
  %inc = add i32 %8, 1
  store i32 %inc, i32* %refcnt, align 8
  %.pre = load i32, i32* %len, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.end11, %if.end
  %9 = phi i32 [ %.pre, %if.end11 ], [ %2, %if.end ]
  %parent_cfg_id = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 6
  %10 = load i32, i32* %parent_cfg_id, align 8
  %cmp16 = icmp slt i32 %10, %9
  br i1 %cmp16, label %if.end18, label %return

if.end18:                                         ; preds = %if.end13
  %cmp20 = icmp sgt i32 %10, -1
  br i1 %cmp20, label %if.then21, label %if.end36

if.then21:                                        ; preds = %if.end18
  %data23 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 3, i32 3
  %11 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data23, align 8
  %idxprom25 = sext i32 %10 to i64
  %p27 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %11, i64 %idxprom25, i32 0
  %12 = bitcast i8** %p27 to i64*
  %13 = load i64, i64* %12, align 8
  %parent_cfg = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 14
  %14 = bitcast %struct._cass_vecset_cfg_t** %parent_cfg to i64*
  store i64 %13, i64* %14, align 8
  %cmp29 = icmp eq i64 %13, 0
  br i1 %cmp29, label %if.else31, label %if.end32

if.else31:                                        ; preds = %if.then21
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @88, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.321, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 423, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

if.end32:                                         ; preds = %if.then21
  %15 = inttoptr i64 %13 to %struct._cass_vecset_cfg_t*
  %refcnt34 = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %15, i64 0, i32 0
  %16 = load i32, i32* %refcnt34, align 8
  %inc35 = add i32 %16, 1
  store i32 %inc35, i32* %refcnt34, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end32, %if.end18
  %map_id = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 7
  %17 = load i32, i32* %map_id, align 4
  %len37 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 4, i32 2
  %18 = load i32, i32* %len37, align 8
  %cmp38 = icmp slt i32 %17, %18
  br i1 %cmp38, label %if.end40, label %return

if.end40:                                         ; preds = %if.end36
  %cmp42 = icmp sgt i32 %17, -1
  br i1 %cmp42, label %if.then43, label %do.body

if.then43:                                        ; preds = %if.end40
  %data45 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 4, i32 3
  %19 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data45, align 8
  %idxprom47 = sext i32 %17 to i64
  %p49 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %19, i64 %idxprom47, i32 0
  %20 = bitcast i8** %p49 to i64*
  %21 = load i64, i64* %20, align 8
  %map50 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 15
  %22 = bitcast %struct.cass_map_t** %map50 to i64*
  store i64 %21, i64* %22, align 8
  %cmp52 = icmp eq i64 %21, 0
  br i1 %cmp52, label %if.else54, label %if.end55

if.else54:                                        ; preds = %if.then43
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @89, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.19.45, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 431, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

if.end55:                                         ; preds = %if.then43
  %23 = inttoptr i64 %21 to %struct.cass_map_t*
  %refcnt57 = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %23, i64 0, i32 1
  %24 = load i32, i32* %refcnt57, align 4
  %inc58 = add i32 %24, 1
  store i32 %inc58, i32* %refcnt57, align 4
  br label %do.body

do.body:                                          ; preds = %if.end40, %if.end55
  %inc60 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 0
  store i32 256, i32* %inc60, align 8
  %len61 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 8, i32 2
  %25 = load i32, i32* %len61, align 8
  %size = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 1
  store i32 %25, i32* %size, align 4
  %len64 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 2
  store i32 0, i32* %len64, align 8
  %data66 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 3
  store %struct._cass_table.19** null, %struct._cass_table.19*** %data66, align 8
  %cmp69 = icmp eq i32 %25, 0
  br i1 %cmp69, label %for.cond.preheader, label %if.then70

if.then70:                                        ; preds = %do.body
  %conv = zext i32 %25 to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @90, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %26 = bitcast %struct._cass_table.19*** %data66 to i8**
  store i8* %call, i8** %26, align 8
  %cmp77 = icmp eq i8* %call, null
  %27 = bitcast i8* %call to %struct._cass_table.19**
  br i1 %cmp77, label %if.else80, label %do.end

if.else80:                                        ; preds = %if.then70
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @91, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.20.46, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 435, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

do.end:                                           ; preds = %if.then70
  %28 = phi %struct._cass_table.19** [ %27, %if.then70 ]
  %cmp69.not = xor i1 %cmp69, true
  %cmp89 = icmp eq %struct._cass_table.19** %28, null
  %or.cond = and i1 %cmp89, %cmp69.not
  br i1 %or.cond, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %do.body, %do.end
  %data99 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 8, i32 3
  %data103 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %0, i64 0, i32 2, i32 3
  %29 = bitcast %struct._cass_table.19*** %data66 to i8**
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %30 = phi i32 [ %.pre1, %for.inc ], [ %25, %for.cond.preheader ]
  %__array_foreach_index.0 = phi i32 [ %inc179, %for.inc ], [ 0, %for.cond.preheader ]
  %cmp96 = icmp ult i32 %__array_foreach_index.0, %30
  br i1 %cmp96, label %for.body, label %return

for.body:                                         ; preds = %for.cond
  %31 = load i32*, i32** %data99, align 8
  %idxprom100 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx101 = getelementptr inbounds i32, i32* %31, i64 %idxprom100
  %32 = load i32, i32* %arrayidx101, align 4
  %33 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data103, align 8
  %idxprom104 = zext i32 %32 to i64
  %p106 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %33, i64 %idxprom104, i32 0
  %34 = bitcast i8** %p106 to %struct._cass_table.19**
  %35 = load %struct._cass_table.19*, %struct._cass_table.19** %34, align 8
  %cmp107 = icmp eq %struct._cass_table.19* %35, null
  br i1 %cmp107, label %if.else110, label %do.body121

if.else110:                                       ; preds = %for.body
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @92, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3.39, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 440, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

do.body121:                                       ; preds = %for.body
  %refcnt112 = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %35, i64 0, i32 0
  %36 = load i32, i32* %refcnt112, align 8
  %inc113 = add i32 %36, 1
  store i32 %inc113, i32* %refcnt112, align 8
  %37 = load i32, i32* %len64, align 8
  %inc120 = add i32 %37, 1
  store i32 %inc120, i32* %len64, align 8
  %38 = load i32, i32* %size, align 4
  %cmp126 = icmp ult i32 %38, %inc120
  br i1 %cmp126, label %if.end129, label %do.body121.for.inc_crit_edge

do.body121.for.inc_crit_edge:                     ; preds = %do.body121
  %.pre2 = load %struct._cass_table.19**, %struct._cass_table.19*** %data66, align 8
  br label %for.inc

if.end129:                                        ; preds = %do.body121
  %39 = load i32, i32* %inc60, align 8
  %add = add i32 %37, %39
  %neg = sub i32 0, %39
  %and = and i32 %add, %neg
  store i32 %and, i32* %size, align 4
  %40 = load %struct._cass_table.19**, %struct._cass_table.19*** %data66, align 8
  %cmp145 = icmp eq %struct._cass_table.19** %40, null
  br i1 %cmp145, label %if.else157, label %if.then147

if.then147:                                       ; preds = %if.end129
  %41 = bitcast %struct._cass_table.19** %40 to i8*
  %conv152 = zext i32 %and to i64
  %mul153 = shl nuw nsw i64 %conv152, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @93, i32 0, i32 0))
  %call154 = call i8* @realloc(i8* %41, i64 %mul153) #11
  br label %if.end165

if.else157:                                       ; preds = %if.end129
  %conv160 = zext i32 %and to i64
  %mul161 = shl nuw nsw i64 %conv160, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @94, i32 0, i32 0))
  %call162 = call noalias i8* @malloc(i64 %mul161) #11
  br label %if.end165

if.end165:                                        ; preds = %if.else157, %if.then147
  %call162.sink = phi i8* [ %call162, %if.else157 ], [ %call154, %if.then147 ]
  %42 = bitcast i8* %call162.sink to %struct._cass_table.19**
  store i8* %call162.sink, i8** %29, align 8
  %cmp168 = icmp eq i8* %call162.sink, null
  br i1 %cmp168, label %if.else171, label %for.inc

if.else171:                                       ; preds = %if.end165
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @95, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.20.46, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.4.40, i64 0, i64 0), i32 442, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__PRETTY_FUNCTION__.__cass_table_ref, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %do.body121.for.inc_crit_edge, %if.end165
  %43 = phi %struct._cass_table.19** [ %.pre2, %do.body121.for.inc_crit_edge ], [ %42, %if.end165 ]
  %idxprom176 = sext i32 %37 to i64
  %arrayidx177 = getelementptr inbounds %struct._cass_table.19*, %struct._cass_table.19** %43, i64 %idxprom176
  store %struct._cass_table.19* %35, %struct._cass_table.19** %arrayidx177, align 8
  %inc179 = add i32 %__array_foreach_index.0, 1
  %.pre1 = load i32, i32* %len61, align 8
  br label %for.cond

return:                                           ; preds = %for.cond, %do.end, %if.end36, %if.end13, %entry
  %retval.0 = phi i32 [ -9994, %entry ], [ -9994, %if.end13 ], [ -9994, %if.end36 ], [ -9998, %do.end ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_env_close(%struct._cass_env_t* nocapture %env) unnamed_addr #0 {
do.body:
  %len = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 2, i32 2
  %data = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 2, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %__array_foreach_index.0 = phi i32 [ 0, %do.body ], [ %inc, %for.inc ]
  %0 = load i32, i32* %len, align 8
  %cmp = icmp ult i32 %__array_foreach_index.0, %0
  br i1 %cmp, label %for.inc, label %do.body4

for.inc:                                          ; preds = %for.cond
  %1 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %idxprom = zext i32 %__array_foreach_index.0 to i64
  %arrayidx = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %1, i64 %idxprom
  %reg.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx to %struct._cass_table.19**
  %reg.sroa.0.0.copyload = load %struct._cass_table.19*, %struct._cass_table.19** %reg.sroa.0.0..sroa_cast, align 8
  call fastcc void @cass_table_free(%struct._cass_table.19* %reg.sroa.0.0.copyload)
  %inc = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.body4:                                         ; preds = %for.cond
  %table2 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 2
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* %table2)
  %len7 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 3, i32 2
  %data12 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 3, i32 3
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc17, %do.body4
  %__array_foreach_index5.0 = phi i32 [ 0, %do.body4 ], [ %inc18, %for.inc17 ]
  %2 = load i32, i32* %len7, align 8
  %cmp8 = icmp ult i32 %__array_foreach_index5.0, %2
  br i1 %cmp8, label %for.inc17, label %do.body23

for.inc17:                                        ; preds = %for.cond6
  %3 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data12, align 8
  %idxprom13 = zext i32 %__array_foreach_index5.0 to i64
  %arrayidx14 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %3, i64 %idxprom13
  %reg10.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx14 to %struct._cass_vecset_cfg_t**
  %reg10.sroa.0.0.copyload = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %reg10.sroa.0.0..sroa_cast, align 8
  call fastcc void @cass_vecset_cfg_free(%struct._cass_vecset_cfg_t* %reg10.sroa.0.0.copyload)
  %inc18 = add i32 %__array_foreach_index5.0, 1
  br label %for.cond6

do.body23:                                        ; preds = %for.cond6
  %cfg21 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 3
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* %cfg21)
  %len26 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 4, i32 2
  %data31 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 4, i32 3
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc36, %do.body23
  %__array_foreach_index24.0 = phi i32 [ 0, %do.body23 ], [ %inc37, %for.inc36 ]
  %4 = load i32, i32* %len26, align 8
  %cmp27 = icmp ult i32 %__array_foreach_index24.0, %4
  br i1 %cmp27, label %for.inc36, label %do.body42

for.inc36:                                        ; preds = %for.cond25
  %5 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data31, align 8
  %idxprom32 = zext i32 %__array_foreach_index24.0 to i64
  %arrayidx33 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %5, i64 %idxprom32
  %reg29.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx33 to %struct.cass_map_t**
  %reg29.sroa.0.0.copyload = load %struct.cass_map_t*, %struct.cass_map_t** %reg29.sroa.0.0..sroa_cast, align 8
  call fastcc void @cass_map_free(%struct.cass_map_t* %reg29.sroa.0.0.copyload)
  %inc37 = add i32 %__array_foreach_index24.0, 1
  br label %for.cond25

do.body42:                                        ; preds = %for.cond25
  %map40 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 4
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* %map40)
  %len45 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 5, i32 2
  %data50 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 5, i32 3
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc55, %do.body42
  %__array_foreach_index43.0 = phi i32 [ 0, %do.body42 ], [ %inc56, %for.inc55 ]
  %6 = load i32, i32* %len45, align 8
  %cmp46 = icmp ult i32 %__array_foreach_index43.0, %6
  br i1 %cmp46, label %for.inc55, label %do.body61

for.inc55:                                        ; preds = %for.cond44
  %7 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data50, align 8
  %idxprom51 = zext i32 %__array_foreach_index43.0 to i64
  %arrayidx52 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %7, i64 %idxprom51
  %reg48.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx52 to %struct.cass_vecset_dist_t**
  %reg48.sroa.0.0.copyload = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %reg48.sroa.0.0..sroa_cast, align 8
  %__class = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %reg48.sroa.0.0.copyload, i64 0, i32 3
  %8 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %__class, align 8
  %free = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %8, i64 0, i32 8
  %9 = load void (i8*)*, void (i8*)** %free, align 8
  %.cast1 = bitcast %struct.cass_vecset_dist_t* %reg48.sroa.0.0.copyload to i8*
  call void %9(i8* %.cast1) #11
  %inc56 = add i32 %__array_foreach_index43.0, 1
  br label %for.cond44

do.body61:                                        ; preds = %for.cond44
  %vecset_dist59 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 5
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* %vecset_dist59)
  %len64 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 6, i32 2
  %data69 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 6, i32 3
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc76, %do.body61
  %__array_foreach_index62.0 = phi i32 [ 0, %do.body61 ], [ %inc77, %for.inc76 ]
  %10 = load i32, i32* %len64, align 8
  %cmp65 = icmp ult i32 %__array_foreach_index62.0, %10
  br i1 %cmp65, label %for.inc76, label %do.end79

for.inc76:                                        ; preds = %for.cond63
  %11 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data69, align 8
  %idxprom70 = zext i32 %__array_foreach_index62.0 to i64
  %arrayidx71 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %11, i64 %idxprom70
  %reg67.sroa.0.0..sroa_cast = bitcast %struct.cass_reg_entry_t* %arrayidx71 to %struct.cass_vec_dist_t**
  %reg67.sroa.0.0.copyload = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %reg67.sroa.0.0..sroa_cast, align 8
  %__class73 = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %reg67.sroa.0.0.copyload, i64 0, i32 2
  %12 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %__class73, align 8
  %free74 = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %12, i64 0, i32 8
  %13 = load void (i8*)*, void (i8*)** %free74, align 8
  %.cast = bitcast %struct.cass_vec_dist_t* %reg67.sroa.0.0.copyload to i8*
  call void %13(i8* %.cast) #11
  %inc77 = add i32 %__array_foreach_index62.0, 1
  br label %for.cond63

do.end79:                                         ; preds = %for.cond63
  %vec_dist80 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 6
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* %vec_dist80)
  %base_dir = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 1
  %14 = load i8*, i8** %base_dir, align 8
  %cmp82 = icmp eq i8* %14, null
  br i1 %cmp82, label %if.end, label %if.then

if.then:                                          ; preds = %do.end79
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @96, i32 0, i32 0))
  call void @free(i8* %14) #11
  br label %if.end

if.end:                                           ; preds = %do.end79, %if.then
  %15 = bitcast %struct._cass_env_t* %env to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @97, i32 0, i32 0))
  call void @free(i8* %15) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_vecset_cfg_free(%struct._cass_vecset_cfg_t* nocapture %cfg) unnamed_addr #0 {
entry:
  %refcnt = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %cfg, i64 0, i32 0
  %0 = load i32, i32* %refcnt, align 8
  %dec = add i32 %0, -1
  store i32 %dec, i32* %refcnt, align 8
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %name = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %cfg, i64 0, i32 1
  %1 = load i8*, i8** %name, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @98, i32 0, i32 0))
  call void @free(i8* %1) #11
  %2 = bitcast %struct._cass_vecset_cfg_t* %cfg to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @99, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind
declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr #1

; Function Attrs: nounwind
declare i64 @fread(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #1

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @__cass_table_unref(%struct._cass_table.19* nocapture %table) unnamed_addr #0 {
entry:
  %cfg = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 13
  %0 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %cfg, align 8
  %cmp = icmp eq %struct._cass_vecset_cfg_t* %0, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call fastcc void @cass_vecset_cfg_free(%struct._cass_vecset_cfg_t* nonnull %0)
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %parent_cfg = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 14
  %1 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %parent_cfg, align 8
  %cmp2 = icmp eq %struct._cass_vecset_cfg_t* %1, null
  br i1 %cmp2, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  call fastcc void @cass_vecset_cfg_free(%struct._cass_vecset_cfg_t* nonnull %1)
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then3
  %map = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 15
  %2 = load %struct.cass_map_t*, %struct.cass_map_t** %map, align 8
  %cmp7 = icmp eq %struct.cass_map_t* %2, null
  br i1 %cmp7, label %for.cond.preheader, label %if.then8

if.then8:                                         ; preds = %if.end6
  call fastcc void @cass_map_free(%struct.cass_map_t* nonnull %2)
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then8, %if.end6
  %len = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 2
  %data = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %__array_foreach_index.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %3 = load i32, i32* %len, align 8
  %cmp12 = icmp ult i32 %__array_foreach_index.0, %3
  %4 = load %struct._cass_table.19**, %struct._cass_table.19*** %data, align 8
  br i1 %cmp12, label %for.inc, label %do.body15

for.inc:                                          ; preds = %for.cond
  %idxprom = zext i32 %__array_foreach_index.0 to i64
  %arrayidx = getelementptr inbounds %struct._cass_table.19*, %struct._cass_table.19** %4, i64 %idxprom
  %5 = load %struct._cass_table.19*, %struct._cass_table.19** %arrayidx, align 8
  call fastcc void @cass_table_free(%struct._cass_table.19* %5)
  %inc = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.body15:                                        ; preds = %for.cond
  %cmp18 = icmp eq %struct._cass_table.19** %4, null
  br i1 %cmp18, label %do.end28, label %if.then19

if.then19:                                        ; preds = %do.body15
  %6 = bitcast %struct._cass_table.19** %4 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @100, i32 0, i32 0))
  call void @free(i8* %6) #11
  br label %do.end28

do.end28:                                         ; preds = %if.then19, %do.body15
  store %struct._cass_table.19** null, %struct._cass_table.19*** %data, align 8
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 16, i32 1
  store i32 0, i32* %size, align 4
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @cass_reg_init(%struct.cass_reg_t* nocapture %reg) unnamed_addr #8 {
do.end:
  %inc = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 0
  store i32 256, i32* %inc, align 8
  %size = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 1
  store i32 0, i32* %size, align 4
  %len = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  store i32 0, i32* %len, align 8
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  store %struct.cass_reg_entry_t* null, %struct.cass_reg_entry_t** %data, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_reg_init_size(%struct.cass_reg_t* nocapture %reg, i32 %size) unnamed_addr #0 {
do.body:
  %inc = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 0
  store i32 256, i32* %inc, align 8
  %size1 = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 1
  store i32 %size, i32* %size1, align 4
  %len = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  store i32 0, i32* %len, align 8
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  store %struct.cass_reg_entry_t* null, %struct.cass_reg_entry_t** %data, align 8
  %cmp = icmp eq i32 %size, 0
  br i1 %cmp, label %do.end, label %if.then

if.then:                                          ; preds = %do.body
  %conv = zext i32 %size to i64
  %mul = shl nuw nsw i64 %conv, 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @101, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %0 = bitcast %struct.cass_reg_entry_t** %data to i8**
  store i8* %call, i8** %0, align 8
  %cmp4 = icmp eq i8* %call, null
  br i1 %cmp4, label %if.else, label %do.end

if.else:                                          ; preds = %if.then
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @102, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.70, i64 0, i64 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.1.71, i64 0, i64 0), i32 31, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__.cass_reg_init_size, i64 0, i64 0)) #16
  unreachable

do.end:                                           ; preds = %do.body, %if.then
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_reg_cleanup(%struct.cass_reg_t* nocapture %reg) unnamed_addr #0 {
do.body:
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  %0 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %cmp = icmp eq %struct.cass_reg_entry_t* %0, null
  br i1 %cmp, label %do.end, label %if.then

if.then:                                          ; preds = %do.body
  %1 = bitcast %struct.cass_reg_entry_t* %0 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @103, i32 0, i32 0))
  call void @free(i8* %1) #11
  br label %do.end

do.end:                                           ; preds = %if.then, %do.body
  store %struct.cass_reg_entry_t* null, %struct.cass_reg_entry_t** %data, align 8
  %len = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 1
  store i32 0, i32* %size, align 4
  ret void
}

; Function Attrs: noinline nounwind readonly uwtable
define internal fastcc i32 @cass_reg_lookup(%struct.cass_reg_t* nocapture readonly %reg, i8* nocapture readonly %n) unnamed_addr #9 {
do.body:
  %len = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  %0 = load i32, i32* %len, align 8
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  %1 = zext i32 %0 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %do.body ]
  %cmp = icmp ult i64 %indvars.iv, %1
  br i1 %cmp, label %for.body, label %return

for.body:                                         ; preds = %for.cond
  %2 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %n1 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %2, i64 %indvars.iv, i32 1
  %3 = load i8*, i8** %n1, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @104, i32 0, i32 0))
  %call = call i32 @strcmp(i8* %3, i8* %n) #15
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %conv = trunc i64 %indvars.iv to i32
  br label %return

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

return:                                           ; preds = %for.cond, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ -1, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i8* @cass_reg_get(%struct.cass_reg_t* nocapture readonly %reg, i32 %i) unnamed_addr #6 {
entry:
  %len = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  %0 = load i32, i32* %len, align 8
  %cmp = icmp ugt i32 %0, %i
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  %1 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %idxprom = zext i32 %i to i64
  %p = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %1, i64 %idxprom, i32 0
  %2 = load i8*, i8** %p, align 8
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i8* [ %2, %if.then ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_reg_add(%struct.cass_reg_t* nocapture %reg, i8* %name, i8* %p) unnamed_addr #0 {
do.body5:
  %len3 = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 2
  %0 = load i32, i32* %len3, align 8
  %inc = add i32 %0, 1
  store i32 %inc, i32* %len3, align 8
  %size = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 1
  %1 = load i32, i32* %size, align 4
  %cmp = icmp ult i32 %1, %inc
  br i1 %cmp, label %if.end, label %do.body5.do.end32_crit_edge

do.body5.do.end32_crit_edge:                      ; preds = %do.body5
  %data31.phi.trans.insert = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  %.pre = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data31.phi.trans.insert, align 8
  br label %do.end32

if.end:                                           ; preds = %do.body5
  %inc9 = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 0
  %2 = load i32, i32* %inc9, align 8
  %add = add i32 %0, %2
  %neg = sub i32 0, %2
  %and = and i32 %add, %neg
  store i32 %and, i32* %size, align 4
  %data = getelementptr inbounds %struct.cass_reg_t, %struct.cass_reg_t* %reg, i64 0, i32 3
  %3 = load %struct.cass_reg_entry_t*, %struct.cass_reg_entry_t** %data, align 8
  %cmp14 = icmp eq %struct.cass_reg_entry_t* %3, null
  br i1 %cmp14, label %if.else, label %if.then15

if.then15:                                        ; preds = %if.end
  %4 = bitcast %struct.cass_reg_entry_t* %3 to i8*
  %5 = bitcast %struct.cass_reg_entry_t** %data to i8**
  %conv = zext i32 %and to i64
  %mul = shl nuw nsw i64 %conv, 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @105, i32 0, i32 0))
  %call = call i8* @realloc(i8* %4, i64 %mul) #11
  store i8* %call, i8** %5, align 8
  br label %if.end24

if.else:                                          ; preds = %if.end
  %conv20 = zext i32 %and to i64
  %mul21 = shl nuw nsw i64 %conv20, 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @106, i32 0, i32 0))
  %call22 = call noalias i8* @malloc(i64 %mul21) #11
  %6 = bitcast %struct.cass_reg_entry_t** %data to i8**
  store i8* %call22, i8** %6, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then15
  %call22.sink = phi i8* [ %call22, %if.else ], [ %call, %if.then15 ]
  %7 = bitcast i8* %call22.sink to %struct.cass_reg_entry_t*
  %cmp26 = icmp eq i8* %call22.sink, null
  br i1 %cmp26, label %if.else29, label %do.end32

if.else29:                                        ; preds = %if.end24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @107, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.70, i64 0, i64 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.1.71, i64 0, i64 0), i32 67, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.cass_reg_add, i64 0, i64 0)) #16
  unreachable

do.end32:                                         ; preds = %do.body5.do.end32_crit_edge, %if.end24
  %8 = phi %struct.cass_reg_entry_t* [ %.pre, %do.body5.do.end32_crit_edge ], [ %7, %if.end24 ]
  %idxprom = sext i32 %0 to i64
  %entry1.sroa.0.0..sroa_idx = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %8, i64 %idxprom, i32 0
  store i8* %p, i8** %entry1.sroa.0.0..sroa_idx, align 8
  %entry1.sroa.2.0..sroa_idx1 = getelementptr inbounds %struct.cass_reg_entry_t, %struct.cass_reg_entry_t* %8, i64 %idxprom, i32 1
  store i8* %name, i8** %entry1.sroa.2.0..sroa_idx1, align 8
  ret void
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i8* @cass_strerror(i32 %err) unnamed_addr #7 {
entry:
  switch i32 %err, label %if.end18 [
    i32 -9999, label %return
    i32 -9998, label %return.fold.split
    i32 -9997, label %return.fold.split1
    i32 -9996, label %return.fold.split2
    i32 -9995, label %return.fold.split3
    i32 -9994, label %return.fold.split4
    i32 -1, label %return.fold.split5
  ]

if.end18:                                         ; preds = %entry
  br label %return

return.fold.split:                                ; preds = %entry
  br label %return

return.fold.split1:                               ; preds = %entry
  br label %return

return.fold.split2:                               ; preds = %entry
  br label %return

return.fold.split3:                               ; preds = %entry
  br label %return

return.fold.split4:                               ; preds = %entry
  br label %return

return.fold.split5:                               ; preds = %entry
  br label %return

return:                                           ; preds = %entry, %return.fold.split5, %return.fold.split4, %return.fold.split3, %return.fold.split2, %return.fold.split1, %return.fold.split, %if.end18
  %retval.0 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7.91, i64 0, i64 0), %if.end18 ], [ getelementptr inbounds ([17 x i8], [17 x i8]* @.str.84, i64 0, i64 0), %entry ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.85, i64 0, i64 0), %return.fold.split ], [ getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2.86, i64 0, i64 0), %return.fold.split1 ], [ getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.87, i64 0, i64 0), %return.fold.split2 ], [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.88, i64 0, i64 0), %return.fold.split3 ], [ getelementptr inbounds ([19 x i8], [19 x i8]* @.str.5.89, i64 0, i64 0), %return.fold.split4 ], [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.90, i64 0, i64 0), %return.fold.split5 ]
  ret i8* %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @queue_init(%struct.queue* %que, i32 %size, i32 %prod_threads) unnamed_addr #0 {
entry:
  %mutex = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @108, i32 0, i32 0))
  %call = call i32 @pthread_mutex_init(%union.pthread_mutex_t* %mutex, %union.pthread_mutexattr_t* null) #11
  %empty = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 7
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @109, i32 0, i32 0))
  %call1 = call i32 @pthread_cond_init(%union.pthread_cond_t* %empty, %union.pthread_mutexattr_t* null) #11
  %full = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @110, i32 0, i32 0))
  %call2 = call i32 @pthread_cond_init(%union.pthread_cond_t* %full, %union.pthread_mutexattr_t* null) #11
  %tail = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 1
  store i32 0, i32* %tail, align 4
  %head = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 0
  store i32 0, i32* %head, align 8
  %conv = sext i32 %size to i64
  %mul = shl nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @111, i32 0, i32 0))
  %call3 = call noalias i8* @malloc(i64 %mul) #11
  %data = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 2
  %0 = bitcast i8*** %data to i8**
  store i8* %call3, i8** %0, align 8
  %size4 = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 3
  store i32 %size, i32* %size4, align 8
  %prod_threads5 = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 4
  store i32 %prod_threads, i32* %prod_threads5, align 4
  %end_count = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 5
  store i32 0, i32* %end_count, align 8
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_init(%union.pthread_mutex_t*, %union.pthread_mutexattr_t*) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @pthread_cond_init(%union.pthread_cond_t*, %union.pthread_mutexattr_t*) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @queue_destroy(%struct.queue* %que) unnamed_addr #0 {
entry:
  %mutex = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @112, i32 0, i32 0))
  %call = call i32 @pthread_mutex_destroy(%union.pthread_mutex_t* %mutex) #11
  %empty = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 7
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @113, i32 0, i32 0))
  %call1 = call i32 @pthread_cond_destroy(%union.pthread_cond_t* %empty) #11
  %full = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @114, i32 0, i32 0))
  %call2 = call i32 @pthread_cond_destroy(%union.pthread_cond_t* %full) #11
  %data = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 2
  %0 = bitcast i8*** %data to i8**
  %1 = load i8*, i8** %0, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @115, i32 0, i32 0))
  call void @free(i8* %1) #11
  store i8** null, i8*** %data, align 8
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_destroy(%union.pthread_mutex_t*) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @pthread_cond_destroy(%union.pthread_cond_t*) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @queue_signal_terminate(%struct.queue* %que) unnamed_addr #0 {
entry:
  %mutex = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @116, i32 0, i32 0))
  %call = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %mutex) #11
  %end_count = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 5
  %0 = load i32, i32* %end_count, align 8
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* %end_count, align 8
  %empty = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 7
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @117, i32 0, i32 0))
  %call1 = call i32 @pthread_cond_broadcast(%union.pthread_cond_t* %empty) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @118, i32 0, i32 0))
  %call3 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %mutex) #11
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_lock(%union.pthread_mutex_t*) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @pthread_cond_broadcast(%union.pthread_cond_t*) local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @pthread_mutex_unlock(%union.pthread_mutex_t*) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @dequeue(%struct.queue* %que, i8** nocapture %to_buf) unnamed_addr #0 {
entry:
  %mutex = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @119, i32 0, i32 0))
  %call = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %mutex) #11
  %end_count = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 5
  %tail = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 1
  %head = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 0
  %prod_threads = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 4
  %empty = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 7
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %tail, align 4
  %1 = load i32, i32* %head, align 8
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %land.end, label %if.end

land.end:                                         ; preds = %while.cond
  %2 = load i32, i32* %end_count, align 8
  %3 = load i32, i32* %prod_threads, align 4
  %cmp1 = icmp slt i32 %2, %3
  br i1 %cmp1, label %while.body, label %land.lhs.true

while.body:                                       ; preds = %land.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @120, i32 0, i32 0))
  %call3 = call i32 @pthread_cond_wait(%union.pthread_cond_t* %empty, %union.pthread_mutex_t* %mutex) #11
  br label %while.cond

land.lhs.true:                                    ; preds = %land.end
  %4 = load i32, i32* %end_count, align 8
  %5 = load i32, i32* %prod_threads, align 4
  %cmp9 = icmp eq i32 %4, %5
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @121, i32 0, i32 0))
  %call11 = call i32 @pthread_cond_broadcast(%union.pthread_cond_t* %empty) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @122, i32 0, i32 0))
  %call13 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %mutex) #11
  br label %return

if.end:                                           ; preds = %while.cond, %land.lhs.true
  %data = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 2
  %6 = load i8**, i8*** %data, align 8
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %6, i64 %idxprom
  %7 = bitcast i8** %arrayidx to i64*
  %8 = load i64, i64* %7, align 8
  %9 = bitcast i8** %to_buf to i64*
  store i64 %8, i64* %9, align 8
  %10 = load i32, i32* %tail, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %tail, align 4
  %size = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 3
  %11 = load i32, i32* %size, align 8
  %cmp17 = icmp eq i32 %inc, %11
  %.inc = select i1 %cmp17, i32 0, i32 %inc
  store i32 %.inc, i32* %tail, align 4
  %full = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @123, i32 0, i32 0))
  %call21 = call i32 @pthread_cond_signal(%union.pthread_cond_t* %full) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @124, i32 0, i32 0))
  %call23 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %mutex) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @pthread_cond_wait(%union.pthread_cond_t*, %union.pthread_mutex_t*) local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @pthread_cond_signal(%union.pthread_cond_t*) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @enqueue(%struct.queue* %que, i8* %from_buf) unnamed_addr #0 {
entry:
  %mutex = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @125, i32 0, i32 0))
  %call = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %mutex) #11
  %head = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 0
  %tail = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 1
  %size = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 3
  %full = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %head, align 8
  %1 = load i32, i32* %tail, align 4
  %sub = add nsw i32 %1, -1
  %2 = load i32, i32* %size, align 8
  %add = add nsw i32 %sub, %2
  %rem = srem i32 %add, %2
  %cmp = icmp eq i32 %0, %rem
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @126, i32 0, i32 0))
  %call3 = call i32 @pthread_cond_wait(%union.pthread_cond_t* %full, %union.pthread_mutex_t* %mutex) #11
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %data = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 2
  %3 = load i8**, i8*** %data, align 8
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %3, i64 %idxprom
  store i8* %from_buf, i8** %arrayidx, align 8
  %4 = load i32, i32* %head, align 8
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %head, align 8
  %5 = load i32, i32* %size, align 8
  %cmp8 = icmp eq i32 %inc, %5
  %.inc = select i1 %cmp8, i32 0, i32 %inc
  store i32 %.inc, i32* %head, align 8
  %empty = getelementptr inbounds %struct.queue, %struct.queue* %que, i64 0, i32 7
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @127, i32 0, i32 0))
  %call10 = call i32 @pthread_cond_signal(%union.pthread_cond_t* %empty) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @128, i32 0, i32 0))
  %call12 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %mutex) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_dataset_init(%struct.cass_dataset_t* nocapture %ds, i32 %vec_size, i32 %vec_dim) unnamed_addr #0 {
entry:
  %0 = bitcast %struct.cass_dataset_t* %ds to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 48, i32 8, i1 false)
  %vec_size1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  store i32 %vec_size, i32* %vec_size1, align 8
  %vec_dim2 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 3
  store i32 %vec_dim, i32* %vec_dim2, align 4
  %flags3 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  store i32 3, i32* %flags3, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_dataset_release(%struct.cass_dataset_t* nocapture %ds) unnamed_addr #0 {
entry:
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %0 = load i8*, i8** %vec, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.end.thread, label %if.end

if.end.thread:                                    ; preds = %entry
  %.pre12 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  br label %if.end5

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @129, i32 0, i32 0))
  call void @free(i8* %0) #11
  %.pre = load i8*, i8** %vec, align 8
  %phitmp = icmp eq i8* %.pre, null
  %.pre1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  br i1 %phitmp, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %1 = bitcast %struct._cass_vecset_t** %.pre1 to i8**
  %2 = load i8*, i8** %1, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @130, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %if.end5

if.end5:                                          ; preds = %if.end.thread, %if.end, %if.then4
  %.pre13 = phi %struct._cass_vecset_t** [ %.pre12, %if.end.thread ], [ %.pre1, %if.end ], [ %.pre1, %if.then4 ]
  store i8* null, i8** %vec, align 8
  store %struct._cass_vecset_t* null, %struct._cass_vecset_t** %.pre13, align 8
  %max_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 7
  store i32 0, i32* %max_vecset, align 8
  %max_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 4
  store i32 0, i32* %max_vec, align 8
  %loaded = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 1
  store i32 0, i32* %loaded, align 4
  ret void
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @grow(i32 %from, i32 %to) unnamed_addr #7 {
entry:
  %cmp = icmp ult i32 %from, %to
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %from, 0
  %.from = select i1 %cmp1, i32 1, i32 %from
  br label %while.cond

while.cond:                                       ; preds = %if.end, %while.body
  %from.addr.1 = phi i32 [ %mul, %while.body ], [ %.from, %if.end ]
  %cmp4 = icmp ult i32 %from.addr.1, %to
  %cmp5 = icmp ult i32 %from.addr.1, 1073741824
  %or.cond = and i1 %cmp4, %cmp5
  br i1 %or.cond, label %while.body, label %while.cond6

while.body:                                       ; preds = %while.cond
  %mul = shl i32 %from.addr.1, 1
  br label %while.cond

while.cond6:                                      ; preds = %while.cond, %while.body8
  %from.addr.2 = phi i32 [ %add, %while.body8 ], [ %from.addr.1, %while.cond ]
  %cmp7 = icmp ult i32 %from.addr.2, %to
  br i1 %cmp7, label %while.body8, label %return

while.body8:                                      ; preds = %while.cond6
  %add = add i32 %from.addr.2, 536870912
  br label %while.cond6

return:                                           ; preds = %while.cond6, %entry
  %retval.0 = phi i32 [ %from, %entry ], [ %from.addr.2, %while.cond6 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_dataset_grow(%struct.cass_dataset_t* nocapture %ds, i32 %num_vec) unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 1
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %max_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 4
  %1 = load i32, i32* %max_vec, align 8
  %cmp = icmp ult i32 %1, %num_vec
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %land.lhs.true
  %call = call fastcc i32 @grow(i32 %1, i32 %num_vec)
  store i32 %call, i32* %max_vec, align 8
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %2 = load i8*, i8** %vec, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %3 = load i32, i32* %vec_size, align 8
  %mul = mul i32 %3, %call
  %conv = zext i32 %mul to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @131, i32 0, i32 0))
  %call4 = call i8* @realloc(i8* %2, i64 %conv) #11
  store i8* %call4, i8** %vec, align 8
  %cmp7 = icmp eq i8* %call4, null
  br i1 %cmp7, label %return, label %if.then.if.end10_crit_edge

if.then.if.end10_crit_edge:                       ; preds = %if.then
  %.pre = load i32, i32* %flags, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then.if.end10_crit_edge, %entry, %land.lhs.true
  %4 = phi i32 [ %.pre, %if.then.if.end10_crit_edge ], [ %0, %entry ], [ %0, %land.lhs.true ]
  %and12 = and i32 %4, 2
  %tobool13 = icmp eq i32 %and12, 0
  br i1 %tobool13, label %return, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %if.end10
  %max_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 7
  %5 = load i32, i32* %max_vecset, align 8
  %cmp15 = icmp eq i32 %5, 0
  br i1 %cmp15, label %if.then17, label %return

if.then17:                                        ; preds = %land.lhs.true14
  %call19 = call fastcc i32 @grow(i32 0, i32 1)
  store i32 %call19, i32* %max_vecset, align 8
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  %6 = bitcast %struct._cass_vecset_t** %vecset to i8**
  %7 = load i8*, i8** %6, align 8
  %conv22 = zext i32 %call19 to i64
  %mul23 = shl nuw nsw i64 %conv22, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @132, i32 0, i32 0))
  %call24 = call i8* @realloc(i8* %7, i64 %mul23) #11
  store i8* %call24, i8** %6, align 8
  br label %return

return:                                           ; preds = %if.then17, %land.lhs.true14, %if.end10, %if.then
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_dataset_merge(%struct.cass_dataset_t* %ds, %struct.cass_dataset_t* nocapture readonly %src, i32 %start, i32 %num) unnamed_addr #0 {
entry:
  %loaded = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 1
  %0 = load i32, i32* %loaded, align 4
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @133, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.124, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 101, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @__PRETTY_FUNCTION__.cass_dataset_merge, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %loaded1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 1
  %1 = load i32, i32* %loaded1, align 4
  %tobool2 = icmp eq i32 %1, 0
  br i1 %tobool2, label %if.else4, label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @134, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.2.126, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 102, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @__PRETTY_FUNCTION__.cass_dataset_merge, i64 0, i64 0)) #16
  unreachable

if.end5:                                          ; preds = %if.end
  %flags = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  %2 = load i32, i32* %flags, align 8
  %and = and i32 %2, 2
  %tobool6 = icmp eq i32 %and, 0
  br i1 %tobool6, label %if.else52, label %if.then7

if.then7:                                         ; preds = %if.end5
  %flags8 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 0
  %3 = load i32, i32* %flags8, align 8
  %and9 = and i32 %3, 2
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %if.else12, label %if.end13

if.else12:                                        ; preds = %if.then7
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @135, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3.127, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 107, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @__PRETTY_FUNCTION__.cass_dataset_merge, i64 0, i64 0)) #16
  unreachable

if.end13:                                         ; preds = %if.then7
  %num_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  %4 = load i32, i32* %num_vecset, align 4
  %sub = sub i32 %4, %start
  %add = add i32 %4, %num
  %max_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 7
  %5 = load i32, i32* %max_vecset, align 8
  %cmp = icmp ugt i32 %add, %5
  br i1 %cmp, label %if.then15, label %if.end13.for.cond.preheader_crit_edge

if.end13.for.cond.preheader_crit_edge:            ; preds = %if.end13
  %.pre5 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  br label %for.cond.preheader

if.then15:                                        ; preds = %if.end13
  %call = call fastcc i32 @grow(i32 %5, i32 %add)
  store i32 %call, i32* %max_vecset, align 8
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  %6 = bitcast %struct._cass_vecset_t** %vecset to i8**
  %7 = load i8*, i8** %6, align 8
  %conv = zext i32 %call to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @136, i32 0, i32 0))
  %call21 = call i8* @realloc(i8* %7, i64 %mul) #11
  store i8* %call21, i8** %6, align 8
  %cmp24 = icmp eq i8* %call21, null
  br i1 %cmp24, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end13.for.cond.preheader_crit_edge, %if.then15
  %vecset33.pre-phi = phi %struct._cass_vecset_t** [ %.pre5, %if.end13.for.cond.preheader_crit_edge ], [ %vecset, %if.then15 ]
  %vecset31 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 9
  %num_vec38 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv7 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next8, %for.inc ]
  %num_vec.0 = phi i32 [ 0, %for.cond.preheader ], [ %add50, %for.inc ]
  %wide.trip.count9 = zext i32 %num to i64
  %exitcond10 = icmp eq i64 %indvars.iv7, %wide.trip.count9
  br i1 %exitcond10, label %if.end68.loopexit1, label %for.inc

for.inc:                                          ; preds = %for.cond
  %8 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset31, align 8
  %9 = trunc i64 %indvars.iv7 to i32
  %add32 = add i32 %9, %start
  %idxprom = zext i32 %add32 to i64
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %8, i64 %idxprom, i32 0
  %10 = load i32, i32* %num_regions, align 4
  %11 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset33.pre-phi, align 8
  %12 = load i32, i32* %num_vecset, align 4
  %idxprom35 = zext i32 %12 to i64
  %num_regions37 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %11, i64 %idxprom35, i32 0
  store i32 %10, i32* %num_regions37, align 4
  %13 = load i32, i32* %num_vec38, align 4
  %add39 = add i32 %13, %num_vec.0
  %14 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset33.pre-phi, align 8
  %15 = load i32, i32* %num_vecset, align 4
  %idxprom42 = zext i32 %15 to i64
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %14, i64 %idxprom42, i32 1
  store i32 %add39, i32* %start_vecid, align 4
  %16 = load i32, i32* %num_vecset, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %num_vecset, align 4
  %17 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset31, align 8
  %num_regions49 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %17, i64 %idxprom, i32 0
  %18 = load i32, i32* %num_regions49, align 4
  %add50 = add i32 %num_vec.0, %18
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  br label %for.cond

if.else52:                                        ; preds = %if.end5
  %num_vecset53 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  %19 = load i32, i32* %num_vecset53, align 4
  %add54 = add i32 %19, %num
  store i32 %add54, i32* %num_vecset53, align 4
  %vecset59 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 9
  br label %for.cond55

for.cond55:                                       ; preds = %for.inc65, %if.else52
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc65 ], [ 0, %if.else52 ]
  %num_vec.1 = phi i32 [ %add64, %for.inc65 ], [ 0, %if.else52 ]
  %wide.trip.count = zext i32 %num to i64
  %exitcond6 = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond6, label %if.end68, label %for.inc65

for.inc65:                                        ; preds = %for.cond55
  %20 = trunc i64 %indvars.iv to i32
  %add60 = add i32 %20, %start
  %idxprom61 = zext i32 %add60 to i64
  %21 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset59, align 8
  %num_regions63 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %21, i64 %idxprom61, i32 0
  %22 = load i32, i32* %num_regions63, align 4
  %add64 = add i32 %num_vec.1, %22
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond55

if.end68.loopexit1:                               ; preds = %for.cond
  %.pre = load i32, i32* %flags, align 8
  br label %if.end68

if.end68:                                         ; preds = %for.cond55, %if.end68.loopexit1
  %23 = phi i32 [ %.pre, %if.end68.loopexit1 ], [ %2, %for.cond55 ]
  %num_vec.2 = phi i32 [ %num_vec.0, %if.end68.loopexit1 ], [ %num_vec.1, %for.cond55 ]
  %parent_delta.0 = phi i32 [ %sub, %if.end68.loopexit1 ], [ 0, %for.cond55 ]
  %and70 = and i32 %23, 1
  %tobool71 = icmp eq i32 %and70, 0
  br i1 %tobool71, label %if.else142, label %if.then72

if.then72:                                        ; preds = %if.end68
  %flags73 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 0
  %24 = load i32, i32* %flags73, align 8
  %and74 = and i32 %24, 2
  %tobool75 = icmp eq i32 %and74, 0
  br i1 %tobool75, label %if.end82, label %if.then76

if.then76:                                        ; preds = %if.then72
  %vecset77 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 9
  %25 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset77, align 8
  %idxprom78 = zext i32 %start to i64
  %start_vecid80 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %25, i64 %idxprom78, i32 1
  %26 = load i32, i32* %start_vecid80, align 4
  br label %if.end82

if.end82:                                         ; preds = %if.then72, %if.then76
  %start_vec.0 = phi i32 [ %26, %if.then76 ], [ %start, %if.then72 ]
  %num_vec.3 = phi i32 [ %num_vec.2, %if.then76 ], [ %num, %if.then72 ]
  %parent_delta.1 = phi i32 [ %parent_delta.0, %if.then76 ], [ 0, %if.then72 ]
  %num_vec83 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %27 = load i32, i32* %num_vec83, align 4
  %add84 = add i32 %27, %num_vec.3
  %max_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 4
  %28 = load i32, i32* %max_vec, align 8
  %cmp85 = icmp ugt i32 %add84, %28
  br i1 %cmp85, label %if.then87, label %if.end82.if.end119_crit_edge

if.end82.if.end119_crit_edge:                     ; preds = %if.end82
  %vec105.phi.trans.insert = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %.pre2 = load i8*, i8** %vec105.phi.trans.insert, align 8
  %.pre4 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  br label %if.end119

if.then87:                                        ; preds = %if.end82
  %call91 = call fastcc i32 @grow(i32 %28, i32 %add84)
  store i32 %call91, i32* %max_vec, align 8
  %vec93 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %29 = load i8*, i8** %vec93, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %30 = load i32, i32* %vec_size, align 8
  %mul95 = mul i32 %30, %call91
  %conv96 = zext i32 %mul95 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @137, i32 0, i32 0))
  %call97 = call i8* @realloc(i8* %29, i64 %conv96) #11
  store i8* %call97, i8** %vec93, align 8
  %cmp100 = icmp eq i8* %call97, null
  br i1 %cmp100, label %return, label %if.then87.if.end119_crit_edge

if.then87.if.end119_crit_edge:                    ; preds = %if.then87
  %.pre3 = load i32, i32* %num_vec83, align 4
  br label %if.end119

if.end119:                                        ; preds = %if.then87.if.end119_crit_edge, %if.end82.if.end119_crit_edge
  %vec_size107.pre-phi = phi i32* [ %vec_size, %if.then87.if.end119_crit_edge ], [ %.pre4, %if.end82.if.end119_crit_edge ]
  %31 = phi i32 [ %.pre3, %if.then87.if.end119_crit_edge ], [ %27, %if.end82.if.end119_crit_edge ]
  %32 = phi i8* [ %call97, %if.then87.if.end119_crit_edge ], [ %.pre2, %if.end82.if.end119_crit_edge ]
  %33 = load i32, i32* %vec_size107.pre-phi, align 8
  %mul108 = mul i32 %31, %33
  %idx.ext = zext i32 %mul108 to i64
  %add.ptr = getelementptr i8, i8* %32, i64 %idx.ext
  %vec109 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 6
  %34 = load i8*, i8** %vec109, align 8
  %vec_size110 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %src, i64 0, i32 2
  %35 = load i32, i32* %vec_size110, align 8
  %mul111 = mul i32 %start_vec.0, %35
  %idx.ext112 = zext i32 %mul111 to i64
  %add.ptr113 = getelementptr i8, i8* %34, i64 %idx.ext112
  %conv118 = zext i32 %33 to i64
  %36 = inttoptr i64 %conv118 to i8*
  br label %for.cond120

for.cond120:                                      ; preds = %for.inc139, %if.end119
  %src_vec.0 = phi i8* [ %add.ptr113, %if.end119 ], [ %add.ptr136, %for.inc139 ]
  %vec.0 = phi i8* [ %add.ptr, %if.end119 ], [ %add.ptr133, %for.inc139 ]
  %i.2 = phi i32 [ 0, %if.end119 ], [ %inc140, %for.inc139 ]
  %exitcond = icmp eq i32 %i.2, %num_vec.3
  br i1 %exitcond, label %return, label %for.inc139

for.inc139:                                       ; preds = %for.cond120
  %37 = bitcast i8* %src_vec.0 to i32*
  %38 = load i32, i32* %37, align 4
  %39 = bitcast i8* %vec.0 to i32*
  store i32 %38, i32* %39, align 4
  %parent = getelementptr inbounds i8, i8* %src_vec.0, i64 4
  %40 = bitcast i8* %parent to i32*
  %41 = load i32, i32* %40, align 4
  %add125 = add i32 %41, %parent_delta.1
  %parent126 = getelementptr inbounds i8, i8* %vec.0, i64 4
  %42 = bitcast i8* %parent126 to i32*
  store i32 %add125, i32* %42, align 4
  %u = getelementptr inbounds i8, i8* %vec.0, i64 8
  %u127 = getelementptr inbounds i8, i8* %src_vec.0, i64 8
  %call130 = call i32 bitcast (i8* (i8*, i8*, i64)* @memcpy to i32 (i8*, i8*, i8*)*)(i8* %u, i8* %u127, i8* %36) #11
  %43 = load i32, i32* %vec_size107.pre-phi, align 8
  %44 = load i32, i32* %vec_size110, align 8
  %45 = load i32, i32* %num_vec83, align 4
  %inc138 = add i32 %45, 1
  store i32 %inc138, i32* %num_vec83, align 4
  %idx.ext135 = zext i32 %44 to i64
  %add.ptr136 = getelementptr i8, i8* %src_vec.0, i64 %idx.ext135
  %idx.ext132 = zext i32 %43 to i64
  %add.ptr133 = getelementptr i8, i8* %vec.0, i64 %idx.ext132
  %inc140 = add nuw nsw i32 %i.2, 1
  br label %for.cond120

if.else142:                                       ; preds = %if.end68
  %num_vec143 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %46 = load i32, i32* %num_vec143, align 4
  %add144 = add i32 %46, %num_vec.2
  store i32 %add144, i32* %num_vec143, align 4
  br label %return

return:                                           ; preds = %for.cond120, %if.else142, %if.then87, %if.then15
  %retval.0 = phi i32 [ -9998, %if.then15 ], [ -9998, %if.then87 ], [ 0, %if.else142 ], [ 0, %for.cond120 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i8* @memcpy(i8*, i8* nocapture readonly, i64) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_dataset_checkpoint() unnamed_addr #0 {
entry:
  call fastcc void @cass_write_uint32.128()
  unreachable
}

; Function Attrs: noinline noreturn nounwind uwtable
define internal fastcc void @cass_write_uint32.128() unnamed_addr #10 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @138, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 88, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__PRETTY_FUNCTION__.cass_write_uint32.516, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_dataset_restore(%struct.cass_dataset_t* nocapture %ds, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast %struct.cass_dataset_t* %ds to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 48, i32 8, i1 false)
  %flags = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  %call = call fastcc i32 @cass_read_uint32.132(i32* %flags, %struct._IO_FILE* %in)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %call1 = call fastcc i32 @cass_read_uint32.132(i32* %vec_size, %struct._IO_FILE* %in)
  %cmp2 = icmp eq i32 %call1, 1
  br i1 %cmp2, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %vec_dim = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 3
  %call5 = call fastcc i32 @cass_read_uint32.132(i32* %vec_dim, %struct._IO_FILE* %in)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %if.end8, label %return

if.end8:                                          ; preds = %if.end4
  %num_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %call9 = call fastcc i32 @cass_read_uint32.132(i32* %num_vec, %struct._IO_FILE* %in)
  %cmp10 = icmp eq i32 %call9, 1
  br i1 %cmp10, label %if.end12, label %return

if.end12:                                         ; preds = %if.end8
  %num_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  %call13 = call fastcc i32 @cass_read_uint32.132(i32* %num_vecset, %struct._IO_FILE* %in)
  %cmp14 = icmp eq i32 %call13, 1
  %. = select i1 %cmp14, i32 0, i32 -9995
  ret i32 %.

return:                                           ; preds = %if.end8, %if.end4, %if.end, %entry
  ret i32 -9995
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.132(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @139, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.133() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_dataset_load(%struct.cass_dataset_t* %ds, %struct._IO_FILE* nocapture %in, i32 %vec_type) unnamed_addr #0 {
entry:
  %loaded = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 1
  %0 = load i32, i32* %loaded, align 4
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @140, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.134, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 206, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_dataset_load, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %1 = load i8*, i8** %vec, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.end3, label %if.else2

if.else2:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @141, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.5.135, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 207, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_dataset_load, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  %2 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %cmp4 = icmp eq %struct._cass_vecset_t* %2, null
  br i1 %cmp4, label %if.end7, label %if.else6

if.else6:                                         ; preds = %if.end3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @142, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.136, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 208, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_dataset_load, i64 0, i64 0)) #16
  unreachable

if.end7:                                          ; preds = %if.end3
  %flags = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 2
  %tobool8 = icmp eq i32 %and, 0
  br i1 %tobool8, label %if.end27, label %if.then9

if.then9:                                         ; preds = %if.end7
  %num_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  %4 = load i32, i32* %num_vecset, align 4
  %mul = mul i32 %4, 3
  %div = lshr i32 %mul, 1
  %max_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 7
  store i32 %div, i32* %max_vecset, align 8
  %conv = zext i32 %div to i64
  %mul11 = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @143, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul11) #11
  %5 = bitcast %struct._cass_vecset_t** %vecset to i8**
  store i8* %call, i8** %5, align 8
  %cmp14 = icmp eq i8* %call, null
  br i1 %cmp14, label %err, label %if.end17

if.end17:                                         ; preds = %if.then9
  %6 = bitcast i8* %call to %struct._cass_vecset_t*
  %conv20 = zext i32 %4 to i64
  %call21 = call fastcc i32 @cass_read_vecset(%struct._cass_vecset_t* %6, i64 %conv20, %struct._IO_FILE* %in)
  %7 = load i32, i32* %num_vecset, align 4
  %cmp23 = icmp eq i32 %call21, %7
  br i1 %cmp23, label %if.end17.if.end27_crit_edge, label %err

if.end17.if.end27_crit_edge:                      ; preds = %if.end17
  %.pre = load i32, i32* %flags, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.end17.if.end27_crit_edge, %if.end7
  %8 = phi i32 [ %.pre, %if.end17.if.end27_crit_edge ], [ %3, %if.end7 ]
  %and29 = and i32 %8, 1
  %tobool30 = icmp eq i32 %and29, 0
  br i1 %tobool30, label %if.end109, label %if.then31

if.then31:                                        ; preds = %if.end27
  %num_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %9 = load i32, i32* %num_vec, align 4
  %max_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 4
  store i32 %9, i32* %max_vec, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %10 = load i32, i32* %vec_size, align 8
  %mul33 = mul i32 %10, %9
  %conv34 = zext i32 %mul33 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @144, i32 0, i32 0))
  %call35 = call noalias i8* @malloc(i64 %conv34) #11
  store i8* %call35, i8** %vec, align 8
  %cmp38 = icmp eq i8* %call35, null
  %11 = bitcast i8* %call35 to float*
  %12 = bitcast i8* %call35 to i32*
  br i1 %cmp38, label %err, label %if.end41

if.end41:                                         ; preds = %if.then31
  %call42 = call fastcc i32 @isLittleEndian.133()
  %tobool43 = icmp eq i32 %call42, 0
  br i1 %tobool43, label %if.else54, label %if.then44

if.then44:                                        ; preds = %if.end41
  %call48 = call fastcc i32 @cass_read(i8* nonnull %call35, i32 %10, i32 %9, %struct._IO_FILE* %in)
  %13 = load i32, i32* %num_vec, align 4
  %cmp50 = icmp eq i32 %call48, %13
  br i1 %cmp50, label %if.end109, label %err

if.else54:                                        ; preds = %if.end41
  switch i32 %vec_type, label %if.else104 [
    i32 1, label %if.then57
    i32 2, label %if.then75
    i32 4, label %if.then94
  ]

if.then57:                                        ; preds = %if.else54
  %div2 = lshr i32 %10, 2
  %mul63 = mul i32 %div2, %9
  %conv66 = zext i32 %mul63 to i64
  %call67 = call fastcc i32 @cass_read_int32(i32* %12, i64 %conv66, %struct._IO_FILE* %in)
  %cmp68 = icmp eq i32 %call67, %mul63
  br i1 %cmp68, label %if.end109, label %err

if.then75:                                        ; preds = %if.else54
  %div1 = lshr i32 %10, 2
  %mul82 = mul i32 %div1, %9
  %conv85 = zext i32 %mul82 to i64
  %call86 = call fastcc i32 @cass_read_float(float* %11, i64 %conv85, %struct._IO_FILE* %in)
  %cmp87 = icmp eq i32 %call86, %mul82
  br i1 %cmp87, label %if.end109, label %err

if.then94:                                        ; preds = %if.else54
  %call98 = call fastcc i32 @cass_read(i8* nonnull %call35, i32 %10, i32 %9, %struct._IO_FILE* %in)
  %14 = load i32, i32* %num_vec, align 4
  %cmp100 = icmp eq i32 %call98, %14
  br i1 %cmp100, label %if.end109, label %err

if.else104:                                       ; preds = %if.else54
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @145, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 242, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_dataset_load, i64 0, i64 0)) #16
  unreachable

if.end109:                                        ; preds = %if.then44, %if.then75, %if.then94, %if.then57, %if.end27
  store i32 1, i32* %loaded, align 4
  br label %return

err:                                              ; preds = %if.then94, %if.then75, %if.then57, %if.then44, %if.then31, %if.end17, %if.then9
  %ret.0 = phi i32 [ -9998, %if.then9 ], [ -9995, %if.end17 ], [ -9998, %if.then31 ], [ -9995, %if.then44 ], [ -9995, %if.then57 ], [ -9995, %if.then75 ], [ -9995, %if.then94 ]
  call fastcc void @cass_dataset_release(%struct.cass_dataset_t* %ds)
  br label %return

return:                                           ; preds = %err, %if.end109
  %retval.0 = phi i32 [ %ret.0, %err ], [ 0, %if.end109 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_vecset(%struct._cass_vecset_t* nocapture %vecset, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast %struct._cass_vecset_t* %vecset to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @146, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 8, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %vecset, i64 %indvars.iv, i32 0
  %2 = load i32, i32* %num_regions, align 4
  %or18 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or18, i32* %num_regions, align 4
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %vecset, i64 %indvars.iv, i32 1
  %3 = load i32, i32* %start_vecid, align 4
  %or43 = call i32 @llvm.bswap.i32(i32 %3)
  store i32 %or43, i32* %start_vecid, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read(i8* nocapture %p, i32 %size, i32 %nmemb, %struct._IO_FILE* nocapture %f) unnamed_addr #0 {
entry:
  %call = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @147, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 22, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__PRETTY_FUNCTION__.cass_read.510, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %conv = zext i32 %size to i64
  %conv1 = zext i32 %nmemb to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @148, i32 0, i32 0))
  %call2 = call i64 @fread(i8* %p, i64 %conv, i64 %conv1, %struct._IO_FILE* %f)
  %conv3 = trunc i64 %call2 to i32
  ret i32 %conv3
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_int32(i32* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @149, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_float(float* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast float* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @150, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %buf, i64 %indvars.iv
  %2 = bitcast float* %arrayidx to i32*
  %3 = load i32, i32* %2, align 4
  %or13 = call i32 @llvm.bswap.i32(i32 %3)
  store i32 %or13, i32* %2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_dataset_dump(%struct.cass_dataset_t* nocapture readonly %ds, %struct._IO_FILE* nocapture %out) unnamed_addr #0 {
entry:
  %loaded = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 1
  %0 = load i32, i32* %loaded, align 4
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @151, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.124, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.125, i64 0, i64 0), i32 258, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.cass_dataset_dump, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 0
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, 2
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.end
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  %2 = bitcast %struct._cass_vecset_t** %vecset to i8**
  %3 = load i8*, i8** %2, align 8
  %num_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  %4 = load i32, i32* %num_vecset, align 4
  %call = call fastcc i32 @cass_write(i8* %3, i32 8, i32 %4, %struct._IO_FILE* %out)
  %5 = load i32, i32* %num_vecset, align 4
  %cmp = icmp eq i32 %call, %5
  br i1 %cmp, label %if.then2.if.end6_crit_edge, label %return

if.then2.if.end6_crit_edge:                       ; preds = %if.then2
  %.pre = load i32, i32* %flags, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then2.if.end6_crit_edge, %if.end
  %6 = phi i32 [ %.pre, %if.then2.if.end6_crit_edge ], [ %1, %if.end ]
  %and8 = and i32 %6, 1
  %tobool9 = icmp eq i32 %and8, 0
  br i1 %tobool9, label %if.end16, label %if.then10

if.then10:                                        ; preds = %if.end6
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %7 = load i8*, i8** %vec, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %8 = load i32, i32* %vec_size, align 8
  %num_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %9 = load i32, i32* %num_vec, align 4
  %call11 = call fastcc i32 @cass_write(i8* %7, i32 %8, i32 %9, %struct._IO_FILE* %out)
  %10 = load i32, i32* %num_vec, align 4
  %cmp13 = icmp eq i32 %call11, %10
  br i1 %cmp13, label %if.end16, label %return

if.end16:                                         ; preds = %if.then10, %if.end6
  br label %return

return:                                           ; preds = %if.then10, %if.then2, %if.end16
  %retval.0 = phi i32 [ 0, %if.end16 ], [ -9995, %if.then2 ], [ -9995, %if.then10 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_write(i8* nocapture %p, i32 %size, i32 %nmemb, %struct._IO_FILE* nocapture %f) unnamed_addr #0 {
entry:
  %call = call fastcc i32 @isLittleEndian.133()
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @152, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 30, i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__PRETTY_FUNCTION__.cass_write.515, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %conv = zext i32 %size to i64
  %conv1 = zext i32 %nmemb to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @153, i32 0, i32 0))
  %call2 = call i64 @fwrite(i8* %p, i64 %conv, i64 %conv1, %struct._IO_FILE* %f)
  %conv3 = trunc i64 %call2 to i32
  ret i32 %conv3
}

; Function Attrs: nounwind
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #1

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc %struct._cass_table_opr.16* @cass_table_opr_get(i32 %i) unnamed_addr #6 {
entry:
  %call = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* nonnull @cass_table_opr_reg, i32 %i)
  %0 = bitcast i8* %call to %struct._cass_table_opr.16*
  ret %struct._cass_table_opr.16* %0
}

; Function Attrs: nounwind
declare i32 @sprintf(i8* nocapture, i8* nocapture readonly, ...) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_table_free(%struct._cass_table.19* %table) unnamed_addr #0 {
entry:
  %cmp = icmp eq %struct._cass_table.19* %table, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @154, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.6.142, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.2.143, i64 0, i64 0), i32 114, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__.cass_table_free, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %refcnt = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 0
  %0 = load i32, i32* %refcnt, align 8
  %dec = add i32 %0, -1
  store i32 %dec, i32* %refcnt, align 8
  %cmp2 = icmp eq i32 %dec, 0
  br i1 %cmp2, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %dirty = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 11
  %1 = load i32, i32* %dirty, align 4
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end7, label %if.else6

if.else6:                                         ; preds = %if.end4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @155, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.7.144, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.2.143, i64 0, i64 0), i32 117, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__.cass_table_free, i64 0, i64 0)) #16
  unreachable

if.end7:                                          ; preds = %if.end4
  call fastcc void @__cass_table_unref(%struct._cass_table.19* nonnull %table)
  %__private = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 12
  %2 = load i8*, i8** %__private, align 8
  %cmp8 = icmp eq i8* %2, null
  br i1 %cmp8, label %do.body, label %if.then9

if.then9:                                         ; preds = %if.end7
  %opr = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 9
  %3 = load %struct._cass_table_opr.16*, %struct._cass_table_opr.16** %opr, align 8
  %free_private = getelementptr inbounds %struct._cass_table_opr.16, %struct._cass_table_opr.16* %3, i64 0, i32 16
  %4 = load i32 (%struct._cass_table.19*)*, i32 (%struct._cass_table.19*)** %free_private, align 8
  %call10 = call i32 %4(%struct._cass_table.19* nonnull %table) #11
  br label %do.body

do.body:                                          ; preds = %if.then9, %if.end7
  %data = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 8, i32 3
  %5 = load i32*, i32** %data, align 8
  %cmp12 = icmp eq i32* %5, null
  br i1 %cmp12, label %do.end, label %if.then13

if.then13:                                        ; preds = %do.body
  %6 = bitcast i32* %5 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @156, i32 0, i32 0))
  call void @free(i8* %6) #11
  br label %do.end

do.end:                                           ; preds = %if.then13, %do.body
  store i32* null, i32** %data, align 8
  %len = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 8, i32 2
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 8, i32 1
  store i32 0, i32* %size, align 4
  %name = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 1
  %7 = load i8*, i8** %name, align 8
  %cmp21 = icmp eq i8* %7, null
  br i1 %cmp21, label %if.end24, label %if.then22

if.then22:                                        ; preds = %do.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @157, i32 0, i32 0))
  call void @free(i8* %7) #11
  br label %if.end24

if.end24:                                         ; preds = %do.end, %if.then22
  %filename = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 2
  %8 = load i8*, i8** %filename, align 8
  %cmp25 = icmp eq i8* %8, null
  br i1 %cmp25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %if.end24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @158, i32 0, i32 0))
  call void @free(i8* %8) #11
  br label %if.end28

if.end28:                                         ; preds = %if.end24, %if.then26
  %9 = bitcast %struct._cass_table.19* %table to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @159, i32 0, i32 0))
  call void @free(i8* %9) #11
  br label %return

return:                                           ; preds = %if.end, %if.end28
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_table_restore(%struct._cass_table.19** nocapture %_table, %struct._cass_env_t* %env, %struct._IO_FILE* %in) unnamed_addr #0 {
entry:
  %n = alloca i32, align 4
  %c = alloca i32, align 4
  %buf = alloca [8192 x i8], align 16
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @160, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 144, i64 1) #11
  %0 = bitcast i8* %call to %struct._cass_table.19*
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %env1 = getelementptr inbounds i8, i8* %call, i64 24
  %1 = bitcast i8* %env1 to %struct._cass_env_t**
  store %struct._cass_env_t* %env, %struct._cass_env_t** %1, align 8
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %call2 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %in)
  %name = getelementptr inbounds i8, i8* %call, i64 8
  %2 = bitcast i8* %name to i8**
  store i8* %call2, i8** %2, align 8
  %cmp4 = icmp eq i8* %call2, null
  br i1 %cmp4, label %if.then91, label %if.end6

if.end6:                                          ; preds = %if.end
  %parent_id = getelementptr inbounds i8, i8* %call, i64 32
  %3 = bitcast i8* %parent_id to i32*
  %call7 = call fastcc i32 @cass_read_int32.151(i32* %3, i64 1, %struct._IO_FILE* %in)
  %cmp8 = icmp eq i32 %call7, 1
  br i1 %cmp8, label %if.end10, label %if.then91

if.end10:                                         ; preds = %if.end6
  %cfg_id = getelementptr inbounds i8, i8* %call, i64 36
  %4 = bitcast i8* %cfg_id to i32*
  %call11 = call fastcc i32 @cass_read_int32.151(i32* %4, i64 1, %struct._IO_FILE* %in)
  %cmp12 = icmp eq i32 %call11, 1
  br i1 %cmp12, label %if.end14, label %if.then91

if.end14:                                         ; preds = %if.end10
  %parent_cfg_id = getelementptr inbounds i8, i8* %call, i64 40
  %5 = bitcast i8* %parent_cfg_id to i32*
  %call15 = call fastcc i32 @cass_read_int32.151(i32* %5, i64 1, %struct._IO_FILE* %in)
  %cmp16 = icmp eq i32 %call15, 1
  br i1 %cmp16, label %if.end18, label %if.then91

if.end18:                                         ; preds = %if.end14
  %map_id = getelementptr inbounds i8, i8* %call, i64 44
  %6 = bitcast i8* %map_id to i32*
  %call19 = call fastcc i32 @cass_read_int32.151(i32* %6, i64 1, %struct._IO_FILE* %in)
  %cmp20 = icmp eq i32 %call19, 1
  br i1 %cmp20, label %if.end22, label %if.then91

if.end22:                                         ; preds = %if.end18
  %call23 = call fastcc i32 @cass_read_uint32.152(i32* nonnull %n, %struct._IO_FILE* %in)
  %cmp24 = icmp eq i32 %call23, 1
  br i1 %cmp24, label %do.body, label %if.then91

do.body:                                          ; preds = %if.end22
  %child_ids = getelementptr inbounds i8, i8* %call, i64 48
  %inc27 = bitcast i8* %child_ids to i32*
  store i32 256, i32* %inc27, align 8
  %7 = load i32, i32* %n, align 4
  %size = getelementptr inbounds i8, i8* %call, i64 52
  %8 = bitcast i8* %size to i32*
  store i32 %7, i32* %8, align 4
  %len = getelementptr inbounds i8, i8* %call, i64 56
  %9 = bitcast i8* %len to i32*
  store i32 0, i32* %9, align 8
  %data = getelementptr inbounds i8, i8* %call, i64 64
  %10 = bitcast i8* %data to i32**
  store i32* null, i32** %10, align 8
  %cmp31 = icmp eq i32 %7, 0
  br i1 %cmp31, label %if.end64, label %if.then32

if.then32:                                        ; preds = %do.body
  %conv = zext i32 %7 to i64
  %mul = shl nuw nsw i64 %conv, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @161, i32 0, i32 0))
  %call33 = call noalias i8* @malloc(i64 %mul) #11
  %11 = bitcast i8* %data to i8**
  store i8* %call33, i8** %11, align 8
  %cmp38 = icmp eq i8* %call33, null
  br i1 %cmp38, label %if.else, label %if.then53

if.else:                                          ; preds = %if.then32
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @162, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3.146, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.2.143, i64 0, i64 0), i32 151, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @__PRETTY_FUNCTION__.cass_table_restore, i64 0, i64 0)) #16
  unreachable

if.then53:                                        ; preds = %if.then32
  %12 = bitcast i8* %call33 to i32*
  %call57 = call fastcc i32 @cass_read_int32.151(i32* %12, i64 %conv, %struct._IO_FILE* %in)
  %13 = load i32, i32* %n, align 4
  %cmp58 = icmp eq i32 %call57, %13
  br i1 %cmp58, label %if.end61, label %if.then91

if.end61:                                         ; preds = %if.then53
  store i32 %call57, i32* %9, align 8
  br label %if.end64

if.end64:                                         ; preds = %do.body, %if.end61
  %call65 = call fastcc i32 @cass_read_uint32.152(i32* nonnull %c, %struct._IO_FILE* %in)
  %cmp66 = icmp eq i32 %call65, 1
  br i1 %cmp66, label %if.end69, label %if.then91

if.end69:                                         ; preds = %if.end64
  %14 = load i32, i32* %c, align 4
  %call70 = call fastcc %struct._cass_table_opr.16* @cass_table_opr_get(i32 %14)
  %opr = getelementptr inbounds i8, i8* %call, i64 72
  %15 = bitcast i8* %opr to %struct._cass_table_opr.16**
  store %struct._cass_table_opr.16* %call70, %struct._cass_table_opr.16** %15, align 8
  %cmp72 = icmp eq %struct._cass_table_opr.16* %call70, null
  br i1 %cmp72, label %if.else75, label %if.end76

if.else75:                                        ; preds = %if.end69
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @163, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8.153, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.2.143, i64 0, i64 0), i32 164, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @__PRETTY_FUNCTION__.cass_table_restore, i64 0, i64 0)) #16
  unreachable

if.end76:                                         ; preds = %if.end69
  %arraydecay = getelementptr inbounds [8192 x i8], [8192 x i8]* %buf, i64 0, i64 0
  %base_dir = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %env, i64 0, i32 1
  %16 = load i8*, i8** %base_dir, align 8
  %17 = load i8*, i8** %2, align 8
  %name79 = getelementptr inbounds %struct._cass_table_opr.16, %struct._cass_table_opr.16* %call70, i64 0, i32 0
  %18 = load i8*, i8** %name79, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @164, i32 0, i32 0))
  %call80 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1.216, i64 0, i64 0), i8* %16, i8* %17, i8* %18) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @165, i32 0, i32 0))
  %call82 = call noalias i8* @strdup(i8* %arraydecay) #11
  %filename = getelementptr inbounds i8, i8* %call, i64 16
  %19 = bitcast i8* %filename to i8**
  store i8* %call82, i8** %19, align 8
  %dirty = getelementptr inbounds i8, i8* %call, i64 84
  %20 = bitcast i8* %dirty to i32*
  store i32 0, i32* %20, align 4
  %loaded = getelementptr inbounds i8, i8* %call, i64 80
  %21 = bitcast i8* %loaded to i32*
  store i32 0, i32* %21, align 8
  %22 = load %struct._cass_table_opr.16*, %struct._cass_table_opr.16** %15, align 8
  %restore_private = getelementptr inbounds %struct._cass_table_opr.16, %struct._cass_table_opr.16* %22, i64 0, i32 15
  %23 = load i32 (%struct._cass_table.19*, %struct._IO_FILE*)*, i32 (%struct._cass_table.19*, %struct._IO_FILE*)** %restore_private, align 8
  %call84 = call i32 %23(%struct._cass_table.19* %0, %struct._IO_FILE* %in) #11
  %cmp85 = icmp eq i32 %call84, 0
  br i1 %cmp85, label %if.end88, label %if.then91

if.end88:                                         ; preds = %if.end76
  %24 = bitcast %struct._cass_table.19** %_table to i8**
  store i8* %call, i8** %24, align 8
  br label %return

if.then91:                                        ; preds = %if.end76, %if.end64, %if.then53, %if.end22, %if.end18, %if.end14, %if.end10, %if.end6, %if.end
  %ret.0.ph = phi i32 [ %call84, %if.end76 ], [ -9995, %if.end64 ], [ -9995, %if.then53 ], [ -9995, %if.end22 ], [ -9995, %if.end18 ], [ -9995, %if.end14 ], [ -9995, %if.end10 ], [ -9995, %if.end6 ], [ -9998, %if.end ]
  call fastcc void @cass_table_free(%struct._cass_table.19* %0)
  br label %return

return:                                           ; preds = %if.then91, %entry, %if.end88
  %retval.0 = phi i32 [ 0, %if.end88 ], [ %ret.0.ph, %if.then91 ], [ -9998, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_int32.151(i32* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @166, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.154()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.152(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @167, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.154()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.154() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_table_query(%struct._cass_table.19* %table, %struct.cass_query_t* %query, %struct.cass_result_t* %result) unnamed_addr #0 {
entry:
  %query.addr = alloca %struct.cass_query_t*, align 8
  %result.addr = alloca %struct.cass_result_t*, align 8
  store %struct.cass_query_t* %query, %struct.cass_query_t** %query.addr, align 8
  store %struct.cass_result_t* %result, %struct.cass_result_t** %result.addr, align 8
  %opr = getelementptr inbounds %struct._cass_table.19, %struct._cass_table.19* %table, i64 0, i32 9
  %0 = load %struct._cass_table_opr.16*, %struct._cass_table_opr.16** %opr, align 8
  %query1 = getelementptr inbounds %struct._cass_table_opr.16, %struct._cass_table_opr.16* %0, i64 0, i32 10
  %1 = load i32 (%struct._cass_table.19*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.19*, %struct.cass_query_t*, %struct.cass_result_t*)** %query1, align 8
  %cmp = icmp eq i32 (%struct._cass_table.19*, %struct.cass_query_t*, %struct.cass_result_t*)* %1, null
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 %1(%struct._cass_table.19* %table, %struct.cass_query_t* %query, %struct.cass_result_t* %result) #11
  br label %return

if.else:                                          ; preds = %entry
  %batch_query = getelementptr inbounds %struct._cass_table_opr.16, %struct._cass_table_opr.16* %0, i64 0, i32 11
  %2 = load i32 (%struct._cass_table.19*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.19*, i32, %struct.cass_query_t**, %struct.cass_result_t**)** %batch_query, align 8
  %cmp5 = icmp eq i32 (%struct._cass_table.19*, i32, %struct.cass_query_t**, %struct.cass_result_t**)* %2, null
  br i1 %cmp5, label %if.else7, label %if.end

if.else7:                                         ; preds = %if.else
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @168, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.23.181, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.2.143, i64 0, i64 0), i32 311, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_table_query, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %if.else
  %call10 = call i32 %2(%struct._cass_table.19* %table, i32 1, %struct.cass_query_t** nonnull %query.addr, %struct.cass_result_t** nonnull %result.addr) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call10, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_init() unnamed_addr #0 {
entry:
  call fastcc void @cass_vec_dist_class_init()
  call fastcc void @cass_vecset_dist_class_init()
  call fastcc void @cass_table_opr_init()
  %0 = load i8*, i8** getelementptr inbounds ({ i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* }, { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* }* @opr_raw, i64 0, i32 0), align 8
  call fastcc void @cass_table_opr_add(i8* %0, %struct._cass_table_opr.69* bitcast ({ i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, i8*)*, i32 (%struct._cass_table.91*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.91*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.91*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*, %struct._IO_FILE*)*, i32 (%struct._cass_table.91*)*, i32 (%struct._cass_table_opr.86*, %struct._IO_FILE*)* }* @opr_raw to %struct._cass_table_opr.69*))
  %1 = load i8*, i8** getelementptr inbounds ({ i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* }, { i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* }* @opr_lsh, i64 0, i32 0), align 8
  call fastcc void @cass_table_opr_add(i8* %1, %struct._cass_table_opr.69* bitcast ({ i8*, i32, i32, i32, i32, i32, %struct._cass_vecset_cfg_t* (i8*)*, i8* (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, i8*)*, i32 (%struct._cass_table.157*, %struct.cass_dataset_t*, i32, i32)*, i32 (%struct._cass_table.157*, %struct.cass_query_t*, %struct.cass_result_t*)*, i32 (%struct._cass_table.157*, i32, %struct.cass_query_t**, %struct.cass_result_t**)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*, %struct._IO_FILE*)*, i32 (%struct._cass_table.157*)*, i32 (%struct._cass_table_opr.152*, %struct._IO_FILE*)* }* @opr_lsh to %struct._cass_table_opr.69*))
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_trivial)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_L1_int)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_L2_int)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_L1_float)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_L2_float)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_hamming)
  call fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* nonnull @vec_dist_cos_float)
  call fastcc void @cass_vecset_dist_class_add(%struct._cass_vecset_dist_class* nonnull @vecset_dist_trivial)
  call fastcc void @cass_vecset_dist_class_add(%struct._cass_vecset_dist_class* nonnull @vecset_dist_single)
  call fastcc void @cass_vecset_dist_class_add(%struct._cass_vecset_dist_class* nonnull @vecset_dist_emd)
  call fastcc void @cass_vecset_dist_class_add(%struct._cass_vecset_dist_class* nonnull @vecset_dist_myemd)
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @cass_vec_dist_class_init() unnamed_addr #8 {
entry:
  call fastcc void @cass_reg_init(%struct.cass_reg_t* nonnull @cass_vec_dist_class_reg)
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @cass_vecset_dist_class_init() unnamed_addr #8 {
entry:
  call fastcc void @cass_reg_init(%struct.cass_reg_t* nonnull @cass_vecset_dist_class_reg)
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @cass_table_opr_init() unnamed_addr #8 {
entry:
  call fastcc void @cass_reg_init(%struct.cass_reg_t* nonnull @cass_table_opr_reg)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_table_opr_add(i8* %n, %struct._cass_table_opr.69* %p) unnamed_addr #0 {
entry:
  %0 = bitcast %struct._cass_table_opr.69* %p to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* nonnull @cass_table_opr_reg, i8* %n, i8* %0)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_vec_dist_class_add(%struct._cass_vec_dist_class* %p) unnamed_addr #0 {
entry:
  %name = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %p, i64 0, i32 0
  %0 = load i8*, i8** %name, align 8
  %1 = bitcast %struct._cass_vec_dist_class* %p to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* nonnull @cass_vec_dist_class_reg, i8* %0, i8* %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_vecset_dist_class_add(%struct._cass_vecset_dist_class* %p) unnamed_addr #0 {
entry:
  %name = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %p, i64 0, i32 0
  %0 = load i8*, i8** %name, align 8
  %1 = bitcast %struct._cass_vecset_dist_class* %p to i8*
  call fastcc void @cass_reg_add(%struct.cass_reg_t* nonnull @cass_vecset_dist_class_reg, i8* %0, i8* %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_cleanup() unnamed_addr #0 {
entry:
  call fastcc void @cass_table_opr_cleanup()
  call fastcc void @cass_vecset_dist_class_cleanup()
  call fastcc void @cass_vec_dist_class_cleanup()
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_table_opr_cleanup() unnamed_addr #0 {
entry:
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* nonnull @cass_table_opr_reg)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_vecset_dist_class_cleanup() unnamed_addr #0 {
entry:
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* nonnull @cass_vecset_dist_class_reg)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_vec_dist_class_cleanup() unnamed_addr #0 {
entry:
  call fastcc void @cass_reg_cleanup(%struct.cass_reg_t* nonnull @cass_vec_dist_class_reg)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @raw_dump(%struct._cass_table.91* nocapture %table) unnamed_addr #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.raw_private**
  %1 = load %struct.raw_private*, %struct.raw_private** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @169, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 41, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__PRETTY_FUNCTION__.raw_dump, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %filename = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 2
  %3 = load i8*, i8** %filename, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @170, i32 0, i32 0))
  %call = call %struct._IO_FILE* @fopen(i8* %3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.26.337, i64 0, i64 0))
  %cmp = icmp eq %struct._IO_FILE* %call, null
  br i1 %cmp, label %return, label %if.end2

if.end2:                                          ; preds = %if.end
  %dataset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0
  %call3 = call fastcc i32 @cass_dataset_dump(%struct.cass_dataset_t* %dataset, %struct._IO_FILE* nonnull %call)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @171, i32 0, i32 0))
  %call4 = call i32 @fclose(%struct._IO_FILE* nonnull %call)
  %cmp5 = icmp eq i32 %call3, 0
  br i1 %cmp5, label %if.then6, label %return

if.then6:                                         ; preds = %if.end2
  %dirty = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 11
  store i32 0, i32* %dirty, align 4
  br label %return

return:                                           ; preds = %if.end2, %if.then6, %if.end
  %retval.0 = phi i32 [ -9995, %if.end ], [ 0, %if.then6 ], [ %call3, %if.end2 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_load(%struct._cass_table.91* nocapture readonly %table) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.raw_private**
  %1 = load %struct.raw_private*, %struct.raw_private** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @172, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3.196, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 82, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__PRETTY_FUNCTION__.raw_load, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %num_vecset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0, i32 8
  %3 = load i32, i32* %num_vecset, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %loaded3 = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0, i32 1
  store i32 1, i32* %loaded3, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %filename = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 2
  %4 = load i8*, i8** %filename, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @173, i32 0, i32 0))
  %call = call %struct._IO_FILE* @fopen(i8* %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23.358, i64 0, i64 0))
  %cmp5 = icmp eq %struct._IO_FILE* %call, null
  br i1 %cmp5, label %return, label %if.end7

if.end7:                                          ; preds = %if.end4
  %dataset8 = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0
  %cfg = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 13
  %5 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %cfg, align 8
  %vec_type = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %5, i64 0, i32 3
  %6 = load i32, i32* %vec_type, align 4
  %call9 = call fastcc i32 @cass_dataset_load(%struct.cass_dataset_t* %dataset8, %struct._IO_FILE* nonnull %call, i32 %6)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @174, i32 0, i32 0))
  %call10 = call i32 @fclose(%struct._IO_FILE* nonnull %call)
  br label %return

return:                                           ; preds = %if.end4, %if.end7, %if.then1
  %retval.0 = phi i32 [ 0, %if.then1 ], [ %call9, %if.end7 ], [ -9995, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_release(%struct._cass_table.91* nocapture %table) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.raw_private**
  %1 = load %struct.raw_private*, %struct.raw_private** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dirty = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 11
  %3 = load i32, i32* %dirty, align 4
  %tobool1 = icmp eq i32 %3, 0
  br i1 %tobool1, label %if.end3, label %if.end

if.end:                                           ; preds = %land.lhs.true
  %call = call fastcc i32 @raw_dump(%struct._cass_table.91* %table)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end3, label %return

if.end3:                                          ; preds = %entry, %land.lhs.true, %if.end
  %dataset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0
  call fastcc void @cass_dataset_release(%struct.cass_dataset_t* %dataset)
  br label %return

return:                                           ; preds = %if.end, %if.end3
  %retval.0 = phi i32 [ 0, %if.end3 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal noalias i8* @raw_tune(%struct._cass_table.91* nocapture readnone %table, i8* nocapture readnone %extra_input) #7 {
entry:
  ret i8* null
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_init_private(%struct._cass_table.91* nocapture %table, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @175, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 48, i64 1) #11
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end5

if.end5:                                          ; preds = %entry
  %dataset = bitcast i8* %call to %struct.cass_dataset_t*
  %cfg = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 13
  %0 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %cfg, align 8
  %vec_size = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %0, i64 0, i32 5
  %1 = load i32, i32* %vec_size, align 4
  %vec_dim = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %0, i64 0, i32 4
  %2 = load i32, i32* %vec_dim, align 8
  call fastcc void @cass_dataset_init(%struct.cass_dataset_t* %dataset, i32 %1, i32 %2)
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  store i8* %call, i8** %__private, align 8
  br label %return

return:                                           ; preds = %entry, %if.end5
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -9998, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_batch_insert(%struct._cass_table.91* nocapture readonly %table, %struct.cass_dataset_t* nocapture readonly %parent, i32 %start, i32 %end) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.raw_private**
  %1 = load %struct.raw_private*, %struct.raw_private** %0, align 8
  %dataset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0
  %sub = sub i32 %end, %start
  %add = add i32 %sub, 1
  %call = call fastcc i32 @cass_dataset_merge(%struct.cass_dataset_t* %dataset, %struct.cass_dataset_t* %parent, i32 %start, i32 %add)
  ret i32 %call
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_query(%struct._cass_table.91* nocapture readonly %table, %struct.cass_query_t* readonly %query, %struct.cass_result_t* %result) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.raw_private**
  %1 = load %struct.raw_private*, %struct.raw_private** %0, align 8
  %dataset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0
  %extra_params = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 5
  %2 = load i8*, i8** %extra_params, align 8
  %call = call fastcc i32 @param_get_int(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.201, i64 0, i64 0), i32 100)
  %flags = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 0
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 4
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @176, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.38, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 124, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %and2 = and i32 %3, 8
  %cmp3 = icmp eq i32 %and2, 0
  br i1 %cmp3, label %if.end6, label %if.else5

if.else5:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @177, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.8.203, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 125, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

if.end6:                                          ; preds = %if.end
  %env = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 3
  %4 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %vec_dist7 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %4, i64 0, i32 6
  %vec_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 7
  %5 = load i32, i32* %vec_dist_id, align 8
  %call8 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %vec_dist7, i32 %5)
  %6 = bitcast i8* %call8 to %struct.cass_vec_dist_t*
  %cmp9 = icmp eq i8* %call8, null
  br i1 %cmp9, label %if.else11, label %if.end12

if.else11:                                        ; preds = %if.end6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @178, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.30, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 128, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

if.end12:                                         ; preds = %if.end6
  %vecset_dist14 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %4, i64 0, i32 5
  %vecset_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 8
  %7 = load i32, i32* %vecset_dist_id, align 4
  %call15 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %vecset_dist14, i32 %7)
  %cmp16 = icmp eq i8* %call15, null
  br i1 %cmp16, label %if.else18, label %if.end19

if.else18:                                        ; preds = %if.end12
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @179, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.10.205, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 130, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

if.end19:                                         ; preds = %if.end12
  %flags20 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 0
  store i32 34, i32* %flags20, align 8
  %8 = load i32, i32* %flags, align 8
  %and22 = and i32 %8, 1024
  %tobool = icmp eq i32 %and22, 0
  br i1 %tobool, label %if.else95, label %if.then23

if.then23:                                        ; preds = %if.end19
  %9 = and i32 %8, 3
  %10 = icmp eq i32 %9, 2
  br i1 %10, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then23
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 137, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.12.207, i64 0, i64 0))
  br label %if.end31

if.end31:                                         ; preds = %if.then23, %if.then30
  %size = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %11 = load i32, i32* %size, align 4
  %topk = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 3
  %12 = load i32, i32* %topk, align 4
  %cmp35 = icmp ugt i32 %12, %11
  br i1 %cmp35, label %if.end43, label %if.end150

if.end43:                                         ; preds = %if.end31
  %inc = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  %13 = load i32, i32* %inc, align 8
  %sub = add i32 %13, -1
  %add = add i32 %12, %sub
  %neg = sub i32 0, %13
  %and60 = and i32 %add, %neg
  store i32 %and60, i32* %size, align 4
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %14 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data, align 8
  %cmp63 = icmp eq %struct.cass_list_entry_t* %14, null
  br i1 %cmp63, label %if.else75, label %if.then64

if.then64:                                        ; preds = %if.end43
  %15 = bitcast %struct.cass_list_entry_t* %14 to i8*
  %16 = bitcast %struct.cass_list_entry_t** %data to i8**
  %conv = zext i32 %and60 to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @180, i32 0, i32 0))
  %call71 = call i8* @realloc(i8* %15, i64 %mul) #11
  store i8* %call71, i8** %16, align 8
  br label %if.end85

if.else75:                                        ; preds = %if.end43
  %conv79 = zext i32 %and60 to i64
  %mul80 = shl nuw nsw i64 %conv79, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @181, i32 0, i32 0))
  %call81 = call noalias i8* @malloc(i64 %mul80) #11
  %17 = bitcast %struct.cass_list_entry_t** %data to i8**
  store i8* %call81, i8** %17, align 8
  br label %if.end85

if.end85:                                         ; preds = %if.else75, %if.then64
  %.in = phi i8* [ %call81, %if.else75 ], [ %call71, %if.then64 ]
  %cmp89 = icmp eq i8* %.in, null
  br i1 %cmp89, label %if.else92, label %if.end150

if.else92:                                        ; preds = %if.end85
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @182, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 141, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

if.else95:                                        ; preds = %if.end19
  %topk96 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 3
  %18 = load i32, i32* %topk96, align 4
  %cmp97 = icmp eq i32 %18, 0
  %inc138 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  store i32 256, i32* %inc138, align 8
  br i1 %cmp97, label %do.end148, label %do.body100

do.body100:                                       ; preds = %if.else95
  %19 = load i32, i32* %topk96, align 4
  %size107 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 %19, i32* %size107, align 4
  %len = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %len, align 8
  %data112 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data112, align 8
  %20 = load i32, i32* %topk96, align 4
  %cmp114 = icmp eq i32 %20, 0
  br i1 %cmp114, label %if.end150, label %if.then116

if.then116:                                       ; preds = %do.body100
  %conv118 = zext i32 %20 to i64
  %mul119 = shl nuw nsw i64 %conv118, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @183, i32 0, i32 0))
  %call120 = call noalias i8* @malloc(i64 %mul119) #11
  %21 = bitcast %struct.cass_list_entry_t** %data112 to i8**
  store i8* %call120, i8** %21, align 8
  %cmp127 = icmp eq i8* %call120, null
  br i1 %cmp127, label %if.else130, label %if.end150

if.else130:                                       ; preds = %if.then116
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @184, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 149, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

do.end148:                                        ; preds = %if.else95
  %size141 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 0, i32* %size141, align 4
  %len144 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %len144, align 8
  %data147 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data147, align 8
  br label %if.end150

if.end150:                                        ; preds = %do.end148, %do.body100, %if.then116, %if.end31, %if.end85
  %topk151.pre-phi = phi i32* [ %topk96, %do.end148 ], [ %topk96, %do.body100 ], [ %topk96, %if.then116 ], [ %topk, %if.end31 ], [ %topk, %if.end85 ]
  %orig_size.0 = phi i32 [ 0, %do.end148 ], [ 0, %do.body100 ], [ 0, %if.then116 ], [ %11, %if.end31 ], [ %11, %if.end85 ]
  %22 = load i32, i32* %topk151.pre-phi, align 4
  %cmp152 = icmp eq i32 %22, 0
  br i1 %cmp152, label %do.end571, label %if.then154

if.then154:                                       ; preds = %if.end150
  %size157 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %23 = load i32, i32* %size157, align 4
  %cmp159 = icmp ult i32 %23, %22
  br i1 %cmp159, label %if.else162, label %do.body168

if.else162:                                       ; preds = %if.then154
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @185, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.14.209, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 160, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

do.body168:                                       ; preds = %if.then154
  %len167 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 %22, i32* %len167, align 8
  %data174 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body168
  %indvars.iv78 = phi i64 [ %indvars.iv.next79, %for.inc ], [ 0, %do.body168 ]
  %24 = load i32, i32* %topk151.pre-phi, align 4
  %25 = zext i32 %24 to i64
  %cmp170 = icmp ult i64 %indvars.iv78, %25
  br i1 %cmp170, label %for.inc, label %do.end176

for.inc:                                          ; preds = %for.cond
  %26 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %26, i64 %indvars.iv78, i32 1
  store float 0x47EFFFFFE0000000, float* %dist, align 4
  %indvars.iv.next79 = add nuw i64 %indvars.iv78, 1
  br label %for.cond

do.end176:                                        ; preds = %for.cond
  %candidate = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 6
  %27 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate, align 8
  %cmp177 = icmp eq %struct.cass_result_t* %27, null
  br i1 %cmp177, label %for.cond392.preheader, label %if.then179

for.cond392.preheader:                            ; preds = %do.end176
  %num_vecset = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0, i32 8
  %__class402 = getelementptr inbounds i8, i8* %call15, i64 24
  %28 = bitcast i8* %__class402 to %struct._cass_vecset_dist_class**
  %dataset404 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id405 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  br label %for.cond392

if.then179:                                       ; preds = %do.end176
  %flags181 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %27, i64 0, i32 0
  %29 = load i32, i32* %flags181, align 8
  %and182 = and i32 %29, 2
  %tobool183 = icmp eq i32 %and182, 0
  br i1 %tobool183, label %if.else283, label %for.cond186.preheader

for.cond186.preheader:                            ; preds = %if.then179
  %__class = getelementptr inbounds i8, i8* %call15, i64 24
  %30 = bitcast i8* %__class to %struct._cass_vecset_dist_class**
  %dataset209 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  br label %for.cond186

for.cond186:                                      ; preds = %for.cond186.preheader, %for.inc279
  %31 = phi %struct.cass_result_t* [ %.pre, %for.inc279 ], [ %27, %for.cond186.preheader ]
  %__array_foreach_index.0 = phi i32 [ %inc280, %for.inc279 ], [ 0, %for.cond186.preheader ]
  %len190 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %31, i64 0, i32 1, i32 0, i32 2
  %32 = load i32, i32* %len190, align 8
  %cmp191 = icmp ult i32 %__array_foreach_index.0, %32
  br i1 %cmp191, label %for.body193, label %if.end483

for.body193:                                      ; preds = %for.cond186
  %data197 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %31, i64 0, i32 1, i32 0, i32 3
  %33 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data197, align 8
  %idxprom198 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx199 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %33, i64 %idxprom198
  %34 = bitcast %struct.cass_list_entry_t* %arrayidx199 to i64*
  %35 = load i64, i64* %34, align 4
  %cand.sroa.0.0.extract.trunc = trunc i64 %35 to i32
  %cmp201 = icmp eq i32 %cand.sroa.0.0.extract.trunc, -1
  br i1 %cmp201, label %for.inc279, label %do.body212

do.body212:                                       ; preds = %for.body193
  %36 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %30, align 8
  %dist207 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %36, i64 0, i32 3
  %37 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist207, align 8
  %38 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset209, align 8
  %39 = load i32, i32* %vecset_id, align 8
  %call210 = call float %37(%struct.cass_dataset_t* %dataset, i32 %cand.sroa.0.0.extract.trunc, %struct.cass_dataset_t* %38, i32 %39, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %40 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  %dist219 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %40, i64 0, i32 1
  %41 = load float, float* %dist219, align 4
  %cmp220 = fcmp ogt float %call210, %41
  br i1 %cmp220, label %for.inc279, label %for.cond224

for.cond224:                                      ; preds = %do.body212, %if.end261
  %iiii213.0 = phi i32 [ %llll.0, %if.end261 ], [ 0, %do.body212 ]
  %shl = shl i32 %iiii213.0, 1
  %add225 = or i32 %shl, 1
  %42 = load i32, i32* %topk151.pre-phi, align 4
  %cmp227 = icmp ult i32 %add225, %42
  br i1 %cmp227, label %if.end230, label %for.cond224.for.end272_crit_edge

for.cond224.for.end272_crit_edge:                 ; preds = %for.cond224
  %.pre54 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br label %for.end272

if.end230:                                        ; preds = %for.cond224
  %add231 = add nsw i32 %add225, 1
  %cmp233 = icmp ult i32 %add231, %42
  %43 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br i1 %cmp233, label %land.lhs.true, label %if.end250

land.lhs.true:                                    ; preds = %if.end230
  %idxprom238 = sext i32 %add231 to i64
  %dist240 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %43, i64 %idxprom238, i32 1
  %44 = load float, float* %dist240, align 4
  %idxprom244 = sext i32 %add225 to i64
  %dist246 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %43, i64 %idxprom244, i32 1
  %45 = load float, float* %dist246, align 4
  %cmp247 = fcmp ogt float %44, %45
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %land.lhs.true
  br label %if.end250

if.end250:                                        ; preds = %if.end230, %if.then249, %land.lhs.true
  %llll.0 = phi i32 [ %add231, %if.then249 ], [ %add225, %land.lhs.true ], [ %add225, %if.end230 ]
  %idxprom255 = sext i32 %llll.0 to i64
  %dist257 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %43, i64 %idxprom255, i32 1
  %46 = load float, float* %dist257, align 4
  %cmp258 = fcmp ogt float %call210, %46
  br i1 %cmp258, label %for.end272, label %if.end261

if.end261:                                        ; preds = %if.end250
  %idxprom265 = sext i32 %iiii213.0 to i64
  %arrayidx266 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %43, i64 %idxprom265
  %arrayidx271 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %43, i64 %idxprom255
  %47 = bitcast %struct.cass_list_entry_t* %arrayidx271 to i64*
  %48 = bitcast %struct.cass_list_entry_t* %arrayidx266 to i64*
  %49 = load i64, i64* %47, align 4
  store i64 %49, i64* %48, align 4
  br label %for.cond224

for.end272:                                       ; preds = %if.end250, %for.cond224.for.end272_crit_edge
  %50 = phi %struct.cass_list_entry_t* [ %.pre54, %for.cond224.for.end272_crit_edge ], [ %43, %if.end250 ]
  %idxprom276 = sext i32 %iiii213.0 to i64
  %.sroa_idx43 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %50, i64 %idxprom276, i32 0
  store i32 %cand.sroa.0.0.extract.trunc, i32* %.sroa_idx43, align 4
  %.sroa_idx44 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %50, i64 %idxprom276, i32 1
  store float %call210, float* %.sroa_idx44, align 4
  br label %for.inc279

for.inc279:                                       ; preds = %for.end272, %do.body212, %for.body193
  %inc280 = add i32 %__array_foreach_index.0, 1
  %.pre = load %struct.cass_result_t*, %struct.cass_result_t** %candidate, align 8
  br label %for.cond186

if.else283:                                       ; preds = %if.then179
  %and286 = and i32 %29, 1
  %tobool287 = icmp eq i32 %and286, 0
  br i1 %tobool287, label %if.else388, label %if.then288

if.then288:                                       ; preds = %if.else283
  %bitmap.idx = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %27, i64 0, i32 1, i32 0, i32 0
  %bitmap.idx.val = load i32, i32* %bitmap.idx, align 8
  %call292 = call fastcc i32 @bitmap_get_size(i32 %bitmap.idx.val)
  %__class307 = getelementptr inbounds i8, i8* %call15, i64 24
  %51 = bitcast i8* %__class307 to %struct._cass_vecset_dist_class**
  %dataset310 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id311 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  br label %for.cond293

for.cond293:                                      ; preds = %for.inc385, %if.then288
  %52 = phi %struct.cass_result_t* [ %27, %if.then288 ], [ %.pre55, %for.inc385 ]
  %id289.0 = phi i32 [ %call292, %if.then288 ], [ %call304, %for.inc385 ]
  %i.0 = phi i32 [ 0, %if.then288 ], [ %inc386, %for.inc385 ]
  %53 = getelementptr %struct.cass_result_t, %struct.cass_result_t* %52, i64 0, i32 1, i32 0, i32 1
  %bitmap296.idx.val = load i32, i32* %53, align 4
  %call297 = call fastcc i32 @bitmap_get_count(i32 %bitmap296.idx.val)
  %cmp298 = icmp ult i32 %i.0, %call297
  br i1 %cmp298, label %do.body314, label %if.end483

do.body314:                                       ; preds = %for.cond293
  %u302 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %52, i64 0, i32 1
  %bitmap303 = bitcast %union.anon.2* %u302 to %struct.bitmap_t*
  %call304 = call fastcc i32 @bitmap_getNext(%struct.bitmap_t* %bitmap303, i32 %id289.0)
  %54 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %51, align 8
  %dist308 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %54, i64 0, i32 3
  %55 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist308, align 8
  %56 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset310, align 8
  %57 = load i32, i32* %vecset_id311, align 8
  %call312 = call float %55(%struct.cass_dataset_t* %dataset, i32 %call304, %struct.cass_dataset_t* %56, i32 %57, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %58 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  %dist323 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %58, i64 0, i32 1
  %59 = load float, float* %dist323, align 4
  %cmp324 = fcmp ogt float %call312, %59
  br i1 %cmp324, label %for.inc385, label %for.cond328

for.cond328:                                      ; preds = %do.body314, %if.end367
  %iiii315.0 = phi i32 [ %llll316.0, %if.end367 ], [ 0, %do.body314 ]
  %shl329 = shl i32 %iiii315.0, 1
  %add330 = or i32 %shl329, 1
  %60 = load i32, i32* %topk151.pre-phi, align 4
  %cmp332 = icmp ult i32 %add330, %60
  br i1 %cmp332, label %if.end335, label %for.cond328.for.end378_crit_edge

for.cond328.for.end378_crit_edge:                 ; preds = %for.cond328
  %.pre57 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br label %for.end378

if.end335:                                        ; preds = %for.cond328
  %add336 = add nsw i32 %add330, 1
  %cmp338 = icmp ult i32 %add336, %60
  %61 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br i1 %cmp338, label %land.lhs.true340, label %if.end356

land.lhs.true340:                                 ; preds = %if.end335
  %idxprom344 = sext i32 %add336 to i64
  %dist346 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %61, i64 %idxprom344, i32 1
  %62 = load float, float* %dist346, align 4
  %idxprom350 = sext i32 %add330 to i64
  %dist352 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %61, i64 %idxprom350, i32 1
  %63 = load float, float* %dist352, align 4
  %cmp353 = fcmp ogt float %62, %63
  br i1 %cmp353, label %if.then355, label %if.end356

if.then355:                                       ; preds = %land.lhs.true340
  br label %if.end356

if.end356:                                        ; preds = %if.end335, %if.then355, %land.lhs.true340
  %llll316.0 = phi i32 [ %add336, %if.then355 ], [ %add330, %land.lhs.true340 ], [ %add330, %if.end335 ]
  %idxprom361 = sext i32 %llll316.0 to i64
  %dist363 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %61, i64 %idxprom361, i32 1
  %64 = load float, float* %dist363, align 4
  %cmp364 = fcmp ogt float %call312, %64
  br i1 %cmp364, label %for.end378, label %if.end367

if.end367:                                        ; preds = %if.end356
  %idxprom371 = sext i32 %iiii315.0 to i64
  %arrayidx372 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %61, i64 %idxprom371
  %arrayidx377 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %61, i64 %idxprom361
  %65 = bitcast %struct.cass_list_entry_t* %arrayidx377 to i64*
  %66 = bitcast %struct.cass_list_entry_t* %arrayidx372 to i64*
  %67 = load i64, i64* %65, align 4
  store i64 %67, i64* %66, align 4
  br label %for.cond328

for.end378:                                       ; preds = %if.end356, %for.cond328.for.end378_crit_edge
  %68 = phi %struct.cass_list_entry_t* [ %.pre57, %for.cond328.for.end378_crit_edge ], [ %61, %if.end356 ]
  %idxprom382 = sext i32 %iiii315.0 to i64
  %.sroa_idx37 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %68, i64 %idxprom382, i32 0
  store i32 %call304, i32* %.sroa_idx37, align 4
  %.sroa_idx38 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %68, i64 %idxprom382, i32 1
  store float %call312, float* %.sroa_idx38, align 4
  br label %for.inc385

for.inc385:                                       ; preds = %for.end378, %do.body314
  %inc386 = add i32 %i.0, 1
  %.pre55 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate, align 8
  br label %for.cond293

if.else388:                                       ; preds = %if.else283
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @186, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 192, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

for.cond392:                                      ; preds = %for.cond392.preheader, %for.inc480
  %i.1 = phi i32 [ %inc481, %for.inc480 ], [ 0, %for.cond392.preheader ]
  %69 = load i32, i32* %num_vecset, align 4
  %cmp393 = icmp ult i32 %i.1, %69
  br i1 %cmp393, label %for.body395, label %if.end483

for.body395:                                      ; preds = %for.cond392
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @187, i32 0, i32 0))
  %call396 = call i32 @rand() #11
  %rem = srem i32 %call396, 100
  %cmp397 = icmp sgt i32 %rem, %call
  br i1 %cmp397, label %for.inc480, label %do.body409

do.body409:                                       ; preds = %for.body395
  %70 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %28, align 8
  %dist403 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %70, i64 0, i32 3
  %71 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist403, align 8
  %72 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset404, align 8
  %73 = load i32, i32* %vecset_id405, align 8
  %call406 = call float %71(%struct.cass_dataset_t* %dataset, i32 %i.1, %struct.cass_dataset_t* %72, i32 %73, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %74 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  %dist418 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %74, i64 0, i32 1
  %75 = load float, float* %dist418, align 4
  %cmp419 = fcmp ogt float %call406, %75
  br i1 %cmp419, label %for.inc480, label %for.cond423

for.cond423:                                      ; preds = %do.body409, %if.end462
  %iiii410.0 = phi i32 [ %llll411.0, %if.end462 ], [ 0, %do.body409 ]
  %shl424 = shl i32 %iiii410.0, 1
  %add425 = or i32 %shl424, 1
  %76 = load i32, i32* %topk151.pre-phi, align 4
  %cmp427 = icmp ult i32 %add425, %76
  br i1 %cmp427, label %if.end430, label %for.cond423.for.end473_crit_edge

for.cond423.for.end473_crit_edge:                 ; preds = %for.cond423
  %.pre61 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br label %for.end473

if.end430:                                        ; preds = %for.cond423
  %add431 = add nsw i32 %add425, 1
  %cmp433 = icmp ult i32 %add431, %76
  %77 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br i1 %cmp433, label %land.lhs.true435, label %if.end451

land.lhs.true435:                                 ; preds = %if.end430
  %idxprom439 = sext i32 %add431 to i64
  %dist441 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom439, i32 1
  %78 = load float, float* %dist441, align 4
  %idxprom445 = sext i32 %add425 to i64
  %dist447 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom445, i32 1
  %79 = load float, float* %dist447, align 4
  %cmp448 = fcmp ogt float %78, %79
  br i1 %cmp448, label %if.then450, label %if.end451

if.then450:                                       ; preds = %land.lhs.true435
  br label %if.end451

if.end451:                                        ; preds = %if.end430, %if.then450, %land.lhs.true435
  %llll411.0 = phi i32 [ %add431, %if.then450 ], [ %add425, %land.lhs.true435 ], [ %add425, %if.end430 ]
  %idxprom456 = sext i32 %llll411.0 to i64
  %dist458 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom456, i32 1
  %80 = load float, float* %dist458, align 4
  %cmp459 = fcmp ogt float %call406, %80
  br i1 %cmp459, label %for.end473, label %if.end462

if.end462:                                        ; preds = %if.end451
  %idxprom466 = sext i32 %iiii410.0 to i64
  %arrayidx467 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom466
  %arrayidx472 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom456
  %81 = bitcast %struct.cass_list_entry_t* %arrayidx472 to i64*
  %82 = bitcast %struct.cass_list_entry_t* %arrayidx467 to i64*
  %83 = load i64, i64* %81, align 4
  store i64 %83, i64* %82, align 4
  br label %for.cond423

for.end473:                                       ; preds = %if.end451, %for.cond423.for.end473_crit_edge
  %84 = phi %struct.cass_list_entry_t* [ %.pre61, %for.cond423.for.end473_crit_edge ], [ %77, %if.end451 ]
  %idxprom477 = sext i32 %iiii410.0 to i64
  %.sroa_idx32 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %84, i64 %idxprom477, i32 0
  store i32 %i.1, i32* %.sroa_idx32, align 4
  %.sroa_idx33 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %84, i64 %idxprom477, i32 1
  store float %call406, float* %.sroa_idx33, align 4
  br label %for.inc480

for.inc480:                                       ; preds = %for.end473, %do.body409, %for.body395
  %inc481 = add i32 %i.1, 1
  br label %for.cond392

if.end483:                                        ; preds = %for.cond186, %for.cond293, %for.cond392
  %85 = load i32, i32* %flags, align 8
  %and485 = and i32 %85, 16
  %tobool486 = icmp eq i32 %and485, 0
  br i1 %tobool486, label %if.end952, label %do.body488

do.body488:                                       ; preds = %if.end483
  %86 = load i32, i32* %topk151.pre-phi, align 4
  %87 = sext i32 %86 to i64
  br label %while.cond

while.cond:                                       ; preds = %for.end557, %do.body488
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end557 ], [ %87, %do.body488 ]
  %cmp493 = icmp sgt i64 %indvars.iv, 0
  br i1 %cmp493, label %while.body, label %do.end563

while.body:                                       ; preds = %while.cond
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %88 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  %arrayidx499 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %88, i64 %indvars.iv.next
  %.sroa_idx24 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %arrayidx499, i64 0, i32 0
  %89 = load i32, i32* %.sroa_idx24, align 4
  %.sroa_idx26 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %88, i64 %indvars.iv.next, i32 1
  %.sroa_cast27 = bitcast float* %.sroa_idx26 to i32*
  %90 = load i32, i32* %.sroa_cast27, align 4
  %91 = bitcast %struct.cass_list_entry_t* %88 to i64*
  %92 = bitcast %struct.cass_list_entry_t* %arrayidx499 to i64*
  %93 = load i64, i64* %91, align 4
  store i64 %93, i64* %92, align 4
  %94 = bitcast i32 %90 to float
  br label %for.cond509

for.cond509:                                      ; preds = %if.end546, %while.body
  %iiii490.0 = phi i32 [ 0, %while.body ], [ %llll491.0, %if.end546 ]
  %shl510 = shl i32 %iiii490.0, 1
  %add511 = or i32 %shl510, 1
  %95 = sext i32 %add511 to i64
  %cmp512 = icmp slt i64 %95, %indvars.iv.next
  br i1 %cmp512, label %if.end515, label %for.cond509.for.end557_crit_edge

for.cond509.for.end557_crit_edge:                 ; preds = %for.cond509
  %.pre59 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br label %for.end557

if.end515:                                        ; preds = %for.cond509
  %add516 = add nsw i32 %add511, 1
  %96 = sext i32 %add516 to i64
  %cmp517 = icmp slt i64 %96, %indvars.iv.next
  %97 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data174, align 8
  br i1 %cmp517, label %land.lhs.true519, label %if.end535

land.lhs.true519:                                 ; preds = %if.end515
  %idxprom523 = sext i32 %add516 to i64
  %dist525 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %97, i64 %idxprom523, i32 1
  %98 = load float, float* %dist525, align 4
  %idxprom529 = sext i32 %add511 to i64
  %dist531 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %97, i64 %idxprom529, i32 1
  %99 = load float, float* %dist531, align 4
  %cmp532 = fcmp ogt float %98, %99
  br i1 %cmp532, label %if.then534, label %if.end535

if.then534:                                       ; preds = %land.lhs.true519
  br label %if.end535

if.end535:                                        ; preds = %if.end515, %if.then534, %land.lhs.true519
  %llll491.0 = phi i32 [ %add516, %if.then534 ], [ %add511, %land.lhs.true519 ], [ %add511, %if.end515 ]
  %idxprom540 = sext i32 %llll491.0 to i64
  %dist542 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %97, i64 %idxprom540, i32 1
  %100 = load float, float* %dist542, align 4
  %cmp543 = fcmp ogt float %94, %100
  br i1 %cmp543, label %for.end557, label %if.end546

if.end546:                                        ; preds = %if.end535
  %idxprom550 = sext i32 %iiii490.0 to i64
  %arrayidx551 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %97, i64 %idxprom550
  %arrayidx556 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %97, i64 %idxprom540
  %101 = bitcast %struct.cass_list_entry_t* %arrayidx556 to i64*
  %102 = bitcast %struct.cass_list_entry_t* %arrayidx551 to i64*
  %103 = load i64, i64* %101, align 4
  store i64 %103, i64* %102, align 4
  br label %for.cond509

for.end557:                                       ; preds = %if.end535, %for.cond509.for.end557_crit_edge
  %104 = phi %struct.cass_list_entry_t* [ %.pre59, %for.cond509.for.end557_crit_edge ], [ %97, %if.end535 ]
  %idxprom561 = sext i32 %iiii490.0 to i64
  %.sroa_idx21 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %104, i64 %idxprom561, i32 0
  store i32 %89, i32* %.sroa_idx21, align 4
  %.sroa_idx22 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %104, i64 %idxprom561, i32 1
  %.sroa_cast23 = bitcast float* %.sroa_idx22 to i32*
  store i32 %90, i32* %.sroa_cast23, align 4
  br label %while.cond

do.end563:                                        ; preds = %while.cond
  %105 = load i32, i32* %flags20, align 8
  %or = or i32 %105, 16
  store i32 %or, i32* %flags20, align 8
  br label %if.end952

do.end571:                                        ; preds = %if.end150
  %len570 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %len570, align 8
  %candidate572 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 6
  %106 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate572, align 8
  %cmp573 = icmp eq %struct.cass_result_t* %106, null
  br i1 %cmp573, label %for.cond836.preheader, label %if.then575

for.cond836.preheader:                            ; preds = %do.end571
  %num_vecset837 = getelementptr inbounds %struct.raw_private, %struct.raw_private* %1, i64 0, i32 0, i32 8
  %__class848 = getelementptr inbounds i8, i8* %call15, i64 24
  %107 = bitcast i8* %__class848 to %struct._cass_vecset_dist_class**
  %dataset850 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id851 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %range856 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 4
  %size872 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %inc888 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  %data905 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %108 = bitcast %struct.cass_list_entry_t** %data905 to i8**
  br label %for.cond836

if.then575:                                       ; preds = %do.end571
  %flags577 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %106, i64 0, i32 0
  %109 = load i32, i32* %flags577, align 8
  %and578 = and i32 %109, 2
  %tobool579 = icmp eq i32 %and578, 0
  br i1 %tobool579, label %if.else705, label %for.cond581.preheader

for.cond581.preheader:                            ; preds = %if.then575
  %__class603 = getelementptr inbounds i8, i8* %call15, i64 24
  %110 = bitcast i8* %__class603 to %struct._cass_vecset_dist_class**
  %dataset606 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id607 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %range = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 4
  %size626 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %inc642 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  %data659 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %111 = bitcast %struct.cass_list_entry_t** %data659 to i8**
  br label %for.cond581

for.cond581:                                      ; preds = %for.cond581.preheader, %for.inc702
  %112 = phi %struct.cass_result_t* [ %.pre62, %for.inc702 ], [ %106, %for.cond581.preheader ]
  %i.2 = phi i32 [ %inc703, %for.inc702 ], [ 0, %for.cond581.preheader ]
  %len585 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %112, i64 0, i32 1, i32 0, i32 2
  %113 = load i32, i32* %len585, align 8
  %cmp586 = icmp ult i32 %i.2, %113
  br i1 %cmp586, label %for.body588, label %if.end952

for.body588:                                      ; preds = %for.cond581
  %data593 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %112, i64 0, i32 1, i32 0, i32 3
  %114 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data593, align 8
  %idxprom594 = zext i32 %i.2 to i64
  %id596 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %114, i64 %idxprom594, i32 0
  %115 = load i32, i32* %id596, align 4
  %cmp599 = icmp eq i32 %115, -1
  br i1 %cmp599, label %for.inc702, label %if.end602

if.end602:                                        ; preds = %for.body588
  %116 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %110, align 8
  %dist604 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %116, i64 0, i32 3
  %117 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist604, align 8
  %118 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset606, align 8
  %119 = load i32, i32* %vecset_id607, align 8
  %call608 = call float %117(%struct.cass_dataset_t* %dataset, i32 %115, %struct.cass_dataset_t* %118, i32 %119, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %120 = load float, float* %range, align 8
  %cmp611 = fcmp olt float %call608, %120
  br i1 %cmp611, label %do.body623, label %for.inc702

do.body623:                                       ; preds = %if.end602
  %121 = load i32, i32* %len570, align 8
  %inc622 = add i32 %121, 1
  store i32 %inc622, i32* %len570, align 8
  %122 = load i32, i32* %size626, align 4
  %cmp630 = icmp ult i32 %122, %inc622
  br i1 %cmp630, label %if.end633, label %do.body623.do.end700_crit_edge

do.body623.do.end700_crit_edge:                   ; preds = %do.body623
  %.pre63 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data659, align 8
  br label %do.end700

if.end633:                                        ; preds = %do.body623
  %123 = load i32, i32* %inc642, align 8
  %add647 = add i32 %121, %123
  %neg652 = sub i32 0, %123
  %and656 = and i32 %add647, %neg652
  store i32 %and656, i32* %size626, align 4
  %124 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data659, align 8
  %cmp660 = icmp eq %struct.cass_list_entry_t* %124, null
  br i1 %cmp660, label %if.else675, label %if.then662

if.then662:                                       ; preds = %if.end633
  %125 = bitcast %struct.cass_list_entry_t* %124 to i8*
  %conv669 = zext i32 %and656 to i64
  %mul670 = shl nuw nsw i64 %conv669, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @188, i32 0, i32 0))
  %call671 = call i8* @realloc(i8* %125, i64 %mul670) #11
  br label %if.end685

if.else675:                                       ; preds = %if.end633
  %conv679 = zext i32 %and656 to i64
  %mul680 = shl nuw nsw i64 %conv679, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @189, i32 0, i32 0))
  %call681 = call noalias i8* @malloc(i64 %mul680) #11
  br label %if.end685

if.end685:                                        ; preds = %if.else675, %if.then662
  %call681.sink = phi i8* [ %call681, %if.else675 ], [ %call671, %if.then662 ]
  %126 = bitcast i8* %call681.sink to %struct.cass_list_entry_t*
  store i8* %call681.sink, i8** %111, align 8
  %cmp689 = icmp eq i8* %call681.sink, null
  br i1 %cmp689, label %if.else692, label %do.end700

if.else692:                                       ; preds = %if.end685
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @190, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 225, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

do.end700:                                        ; preds = %do.body623.do.end700_crit_edge, %if.end685
  %127 = phi %struct.cass_list_entry_t* [ %.pre63, %do.body623.do.end700_crit_edge ], [ %126, %if.end685 ]
  %idxprom698 = sext i32 %121 to i64
  %.sroa_idx16 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %127, i64 %idxprom698, i32 0
  store i32 %115, i32* %.sroa_idx16, align 4
  %.sroa_idx17 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %127, i64 %idxprom698, i32 1
  store float %call608, float* %.sroa_idx17, align 4
  br label %for.inc702

for.inc702:                                       ; preds = %if.end602, %do.end700, %for.body588
  %inc703 = add i32 %i.2, 1
  %.pre62 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate572, align 8
  br label %for.cond581

if.else705:                                       ; preds = %if.then575
  %and708 = and i32 %109, 1
  %tobool709 = icmp eq i32 %and708, 0
  br i1 %tobool709, label %if.end952, label %if.then710

if.then710:                                       ; preds = %if.else705
  %bitmap714.idx = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %106, i64 0, i32 1, i32 0, i32 0
  %bitmap714.idx.val = load i32, i32* %bitmap714.idx, align 8
  %call715 = call fastcc i32 @bitmap_get_size(i32 %bitmap714.idx.val)
  %__class730 = getelementptr inbounds i8, i8* %call15, i64 24
  %128 = bitcast i8* %__class730 to %struct._cass_vecset_dist_class**
  %dataset733 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %vecset_id734 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %range738 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 4
  %size754 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %inc770 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  %data787 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %129 = bitcast %struct.cass_list_entry_t** %data787 to i8**
  br label %for.cond716

for.cond716:                                      ; preds = %for.inc830, %if.then710
  %130 = phi %struct.cass_result_t* [ %106, %if.then710 ], [ %.pre64, %for.inc830 ]
  %i.3 = phi i32 [ 0, %if.then710 ], [ %inc831, %for.inc830 ]
  %id711.0 = phi i32 [ %call715, %if.then710 ], [ %call727, %for.inc830 ]
  %131 = getelementptr %struct.cass_result_t, %struct.cass_result_t* %130, i64 0, i32 1, i32 0, i32 1
  %bitmap719.idx.val = load i32, i32* %131, align 4
  %call720 = call fastcc i32 @bitmap_get_count(i32 %bitmap719.idx.val)
  %cmp721 = icmp ult i32 %i.3, %call720
  br i1 %cmp721, label %for.body723, label %if.end952

for.body723:                                      ; preds = %for.cond716
  %u725 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %130, i64 0, i32 1
  %bitmap726 = bitcast %union.anon.2* %u725 to %struct.bitmap_t*
  %call727 = call fastcc i32 @bitmap_getNext(%struct.bitmap_t* %bitmap726, i32 %id711.0)
  %132 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %128, align 8
  %dist731 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %132, i64 0, i32 3
  %133 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist731, align 8
  %134 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset733, align 8
  %135 = load i32, i32* %vecset_id734, align 8
  %call735 = call float %133(%struct.cass_dataset_t* %dataset, i32 %call727, %struct.cass_dataset_t* %134, i32 %135, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %136 = load float, float* %range738, align 8
  %cmp739 = fcmp olt float %call735, %136
  br i1 %cmp739, label %do.body751, label %for.inc830

do.body751:                                       ; preds = %for.body723
  %137 = load i32, i32* %len570, align 8
  %inc750 = add i32 %137, 1
  store i32 %inc750, i32* %len570, align 8
  %138 = load i32, i32* %size754, align 4
  %cmp758 = icmp ult i32 %138, %inc750
  br i1 %cmp758, label %if.end761, label %do.body751.do.end828_crit_edge

do.body751.do.end828_crit_edge:                   ; preds = %do.body751
  %.pre65 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data787, align 8
  br label %do.end828

if.end761:                                        ; preds = %do.body751
  %139 = load i32, i32* %inc770, align 8
  %add775 = add i32 %137, %139
  %neg780 = sub i32 0, %139
  %and784 = and i32 %add775, %neg780
  store i32 %and784, i32* %size754, align 4
  %140 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data787, align 8
  %cmp788 = icmp eq %struct.cass_list_entry_t* %140, null
  br i1 %cmp788, label %if.else803, label %if.then790

if.then790:                                       ; preds = %if.end761
  %141 = bitcast %struct.cass_list_entry_t* %140 to i8*
  %conv797 = zext i32 %and784 to i64
  %mul798 = shl nuw nsw i64 %conv797, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @191, i32 0, i32 0))
  %call799 = call i8* @realloc(i8* %141, i64 %mul798) #11
  br label %if.end813

if.else803:                                       ; preds = %if.end761
  %conv807 = zext i32 %and784 to i64
  %mul808 = shl nuw nsw i64 %conv807, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @192, i32 0, i32 0))
  %call809 = call noalias i8* @malloc(i64 %mul808) #11
  br label %if.end813

if.end813:                                        ; preds = %if.else803, %if.then790
  %call809.sink = phi i8* [ %call809, %if.else803 ], [ %call799, %if.then790 ]
  %142 = bitcast i8* %call809.sink to %struct.cass_list_entry_t*
  store i8* %call809.sink, i8** %129, align 8
  %cmp817 = icmp eq i8* %call809.sink, null
  br i1 %cmp817, label %if.else820, label %do.end828

if.else820:                                       ; preds = %if.end813
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @193, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 241, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

do.end828:                                        ; preds = %do.body751.do.end828_crit_edge, %if.end813
  %143 = phi %struct.cass_list_entry_t* [ %.pre65, %do.body751.do.end828_crit_edge ], [ %142, %if.end813 ]
  %idxprom826 = sext i32 %137 to i64
  %.sroa_idx11 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %143, i64 %idxprom826, i32 0
  store i32 %call727, i32* %.sroa_idx11, align 4
  %.sroa_idx12 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %143, i64 %idxprom826, i32 1
  store float %call735, float* %.sroa_idx12, align 4
  br label %for.inc830

for.inc830:                                       ; preds = %for.body723, %do.end828
  %inc831 = add i32 %i.3, 1
  %.pre64 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate572, align 8
  br label %for.cond716

for.cond836:                                      ; preds = %for.cond836.preheader, %for.inc948
  %i.4 = phi i32 [ %inc949, %for.inc948 ], [ 0, %for.cond836.preheader ]
  %144 = load i32, i32* %num_vecset837, align 4
  %cmp838 = icmp ult i32 %i.4, %144
  br i1 %cmp838, label %for.body840, label %if.end952

for.body840:                                      ; preds = %for.cond836
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @194, i32 0, i32 0))
  %call841 = call i32 @rand() #11
  %rem842 = srem i32 %call841, 100
  %cmp843 = icmp sgt i32 %rem842, %call
  br i1 %cmp843, label %for.inc948, label %if.end846

if.end846:                                        ; preds = %for.body840
  %145 = load %struct._cass_vecset_dist_class*, %struct._cass_vecset_dist_class** %107, align 8
  %dist849 = getelementptr inbounds %struct._cass_vecset_dist_class, %struct._cass_vecset_dist_class* %145, i64 0, i32 3
  %146 = load float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)*, float (%struct.cass_dataset_t*, i32, %struct.cass_dataset_t*, i32, %struct.cass_vec_dist_t*, i8*)** %dist849, align 8
  %147 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset850, align 8
  %148 = load i32, i32* %vecset_id851, align 8
  %call852 = call float %146(%struct.cass_dataset_t* %dataset, i32 %i.4, %struct.cass_dataset_t* %147, i32 %148, %struct.cass_vec_dist_t* %6, i8* nonnull %call15) #11
  %149 = load float, float* %range856, align 8
  %cmp857 = fcmp olt float %call852, %149
  br i1 %cmp857, label %do.body869, label %for.inc948

do.body869:                                       ; preds = %if.end846
  %150 = load i32, i32* %len570, align 8
  %inc868 = add i32 %150, 1
  store i32 %inc868, i32* %len570, align 8
  %151 = load i32, i32* %size872, align 4
  %cmp876 = icmp ult i32 %151, %inc868
  br i1 %cmp876, label %if.end879, label %do.body869.do.end946_crit_edge

do.body869.do.end946_crit_edge:                   ; preds = %do.body869
  %.pre66 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data905, align 8
  br label %do.end946

if.end879:                                        ; preds = %do.body869
  %152 = load i32, i32* %inc888, align 8
  %add893 = add i32 %150, %152
  %neg898 = sub i32 0, %152
  %and902 = and i32 %add893, %neg898
  store i32 %and902, i32* %size872, align 4
  %153 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data905, align 8
  %cmp906 = icmp eq %struct.cass_list_entry_t* %153, null
  br i1 %cmp906, label %if.else921, label %if.then908

if.then908:                                       ; preds = %if.end879
  %154 = bitcast %struct.cass_list_entry_t* %153 to i8*
  %conv915 = zext i32 %and902 to i64
  %mul916 = shl nuw nsw i64 %conv915, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @195, i32 0, i32 0))
  %call917 = call i8* @realloc(i8* %154, i64 %mul916) #11
  br label %if.end931

if.else921:                                       ; preds = %if.end879
  %conv925 = zext i32 %and902 to i64
  %mul926 = shl nuw nsw i64 %conv925, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @196, i32 0, i32 0))
  %call927 = call noalias i8* @malloc(i64 %mul926) #11
  br label %if.end931

if.end931:                                        ; preds = %if.else921, %if.then908
  %call927.sink = phi i8* [ %call927, %if.else921 ], [ %call917, %if.then908 ]
  %155 = bitcast i8* %call927.sink to %struct.cass_list_entry_t*
  store i8* %call927.sink, i8** %108, align 8
  %cmp935 = icmp eq i8* %call927.sink, null
  br i1 %cmp935, label %if.else938, label %do.end946

if.else938:                                       ; preds = %if.end931
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @197, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.194, i64 0, i64 0), i32 256, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.raw_query, i64 0, i64 0)) #16
  unreachable

do.end946:                                        ; preds = %do.body869.do.end946_crit_edge, %if.end931
  %156 = phi %struct.cass_list_entry_t* [ %.pre66, %do.body869.do.end946_crit_edge ], [ %155, %if.end931 ]
  %idxprom944 = sext i32 %150 to i64
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %156, i64 %idxprom944, i32 0
  store i32 %i.4, i32* %.sroa_idx, align 4
  %.sroa_idx9 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %156, i64 %idxprom944, i32 1
  store float %call852, float* %.sroa_idx9, align 4
  br label %for.inc948

for.inc948:                                       ; preds = %if.end846, %do.end946, %for.body840
  %inc949 = add i32 %i.4, 1
  br label %for.cond836

if.end952:                                        ; preds = %for.cond581, %for.cond716, %for.cond836, %if.else705, %do.end563, %if.end483
  %cmp953 = icmp eq i32 %orig_size.0, 0
  br i1 %cmp953, label %if.end968.sink.split, label %if.else958

if.else958:                                       ; preds = %if.end952
  %size961 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  %157 = load i32, i32* %size961, align 4
  %cmp962 = icmp ugt i32 %157, %orig_size.0
  br i1 %cmp962, label %if.end968.sink.split, label %if.end968

if.end968.sink.split:                             ; preds = %if.end952, %if.else958
  %.sink82 = phi i32 [ 512, %if.else958 ], [ 256, %if.end952 ]
  %158 = load i32, i32* %flags20, align 8
  %or966 = or i32 %158, %.sink82
  store i32 %or966, i32* %flags20, align 8
  br label %if.end968

if.end968:                                        ; preds = %if.end968.sink.split, %if.else958
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_checkpoint_private(%struct._cass_table.91* nocapture %table, %struct._IO_FILE* nocapture readnone %out) #0 {
entry:
  %loaded = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 10
  %0 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dirty = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 11
  %1 = load i32, i32* %dirty, align 4
  %tobool1 = icmp eq i32 %1, 0
  br i1 %tobool1, label %if.end3, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = call fastcc i32 @raw_dump(%struct._cass_table.91* %table)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end3, label %return

if.end3:                                          ; preds = %if.then, %land.lhs.true, %entry
  %call4 = call fastcc i32 @cass_dataset_checkpoint()
  br label %return

return:                                           ; preds = %if.then, %if.end3
  %retval.0 = phi i32 [ %call4, %if.end3 ], [ %call, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_restore_private(%struct._cass_table.91* nocapture %table, %struct._IO_FILE* nocapture %in) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @198, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 48, i64 1) #11
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = bitcast i8* %call to %struct.raw_private*
  %dataset = bitcast i8* %call to %struct.cass_dataset_t*
  %call1 = call fastcc i32 @cass_dataset_restore(%struct.cass_dataset_t* %dataset, %struct._IO_FILE* %in)
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @199, i32 0, i32 0))
  call void @free(i8* %call) #11
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then3
  %priv.0 = phi %struct.raw_private* [ null, %if.then3 ], [ %0, %if.end ]
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %1 = bitcast i8** %__private to %struct.raw_private**
  store %struct.raw_private* %priv.0, %struct.raw_private** %1, align 8
  br label %return

return:                                           ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ %call1, %if.end4 ], [ -9998, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @raw_free_private(%struct._cass_table.91* nocapture %table) #0 {
entry:
  %loaded = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 10
  %0 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @raw_release(%struct._cass_table.91* %table)
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %__private = getelementptr inbounds %struct._cass_table.91, %struct._cass_table.91* %table, i64 0, i32 12
  %1 = load i8*, i8** %__private, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @200, i32 0, i32 0))
  call void @free(i8* %1) #11
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @rand() local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal void @__debug(i8* %file, i32 %line, i8* %func, i8* nocapture readonly %fmt, ...) unnamed_addr #0 {
entry:
  %argptr = alloca [1 x %struct.__va_list_tag], align 16
  %0 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @201, i32 0, i32 0))
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.213, i64 0, i64 0), i8* %file, i32 %line, i8* %func) #14
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %argptr to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %argptr, i64 0, i64 0
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @202, i32 0, i32 0))
  %call3 = call i32 @vfprintf(%struct._IO_FILE* %1, i8* %fmt, %struct.__va_list_tag* %arraydecay2) #14
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #11

; Function Attrs: nounwind
declare i32 @vfprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, %struct.__va_list_tag*) local_unnamed_addr #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #11

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @mkpath(i8* nocapture %buf, i8* %base) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @203, i32 0, i32 0))
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 8192, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1.216, i64 0, i64 0), i8* %base, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.37, i64 0, i64 0)) #11
  %cmp = icmp sgt i32 %call, 8191
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @204, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 40, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__PRETTY_FUNCTION__.mkpath, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: nounwind
declare i32 @snprintf(i8* nocapture, i64, i8* nocapture readonly, ...) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @fexist(i8* nocapture readonly %path) unnamed_addr #0 {
entry:
  %buf = alloca %struct.stat, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @205, i32 0, i32 0))
  %call = call i32 @stat(i8* %path, %struct.stat* nonnull %buf) #11
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %buf, i64 0, i32 3
  %0 = load i32, i32* %st_mode, align 8
  %and = and i32 %0, 61440
  %cmp1 = icmp eq i32 %and, 32768
  %conv = zext i1 %cmp1 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @dexist(i8* nocapture readonly %path) unnamed_addr #0 {
entry:
  %buf = alloca %struct.stat, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @206, i32 0, i32 0))
  %call = call i32 @lstat(i8* %path, %struct.stat* nonnull %buf) #11
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %buf, i64 0, i32 3
  %0 = load i32, i32* %st_mode, align 8
  %and = and i32 %0, 61440
  %cmp1 = icmp eq i32 %and, 16384
  %conv = zext i1 %cmp1 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @lstat(i8* nocapture readonly, %struct.stat* nocapture) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias i8* @cass_read_pchar(%struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %len = alloca i32, align 4
  %call = call fastcc i32 @cass_read_uint32.225(i32* nonnull %len, %struct._IO_FILE* %in)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %len, align 4
  %conv = zext i32 %0 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @207, i32 0, i32 0))
  %call1 = call noalias i8* @malloc(i64 %conv) #11
  %call3 = call fastcc i32 @cass_read_char(i8* %call1, i64 %conv, %struct._IO_FILE* %in)
  %cmp4 = icmp eq i32 %call3, %0
  br i1 %cmp4, label %return, label %if.then6

if.then6:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @208, i32 0, i32 0))
  call void @free(i8* %call1) #11
  br label %return

return:                                           ; preds = %if.end, %entry, %if.then6
  %retval.0 = phi i8* [ null, %if.then6 ], [ null, %entry ], [ %call1, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.225(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @209, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.226()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_char(i8* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @210, i32 0, i32 0))
  %call = call i64 @fread(i8* %buf, i64 1, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.226() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_write_pchar(i8* nocapture readnone %buf, %struct._IO_FILE* nocapture readnone %out) unnamed_addr #0 {
entry:
  call fastcc void @cass_write_uint32.229()
  unreachable
}

; Function Attrs: noinline noreturn nounwind uwtable
define internal fastcc void @cass_write_uint32.229() unnamed_addr #10 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @211, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 88, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__PRETTY_FUNCTION__.cass_write_uint32.516, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @param_get_int(i8* readonly %param, i8* nocapture readonly %key, i32 %def) unnamed_addr #0 {
entry:
  %cmp = icmp eq i8* %param, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @212, i32 0, i32 0))
  %call = call i8* @strstr(i8* nonnull %param, i8* %key) #15
  %cmp1 = icmp eq i8* %call, null
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @213, i32 0, i32 0))
  %call4 = call i64 @strlen(i8* %key) #15
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 %call4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @214, i32 0, i32 0))
  %call5 = call i64 @strtol(i8* nocapture %add.ptr, i8** null, i32 0) #11
  %conv = trunc i64 %call5 to i32
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i32 [ %conv, %if.end3 ], [ %def, %entry ], [ %def, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readonly
declare i8* @strstr(i8*, i8* nocapture) local_unnamed_addr #3

; Function Attrs: nounwind
declare i64 @strtol(i8* readonly, i8** nocapture, i32) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @param_get_float(i8* readonly %param, i8* nocapture readonly %key, float %def) unnamed_addr #0 {
entry:
  %f = alloca float, align 4
  %cmp = icmp eq i8* %param, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @215, i32 0, i32 0))
  %call = call i8* @strstr(i8* nonnull %param, i8* %key) #15
  %cmp1 = icmp eq i8* %call, null
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @216, i32 0, i32 0))
  %call4 = call i64 @strlen(i8* %key) #15
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 %call4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @217, i32 0, i32 0))
  %call5 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %add.ptr, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4.234, i64 0, i64 0), float* nonnull %f) #11
  %0 = load float, float* %f, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi float [ %0, %if.end3 ], [ %def, %entry ], [ %def, %if.end ]
  ret float %retval.0
}

; Function Attrs: nounwind
declare i32 @__isoc99_sscanf(i8* nocapture readonly, i8* nocapture readonly, ...) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @param_get_float_array(i8* readonly %param, i32* nocapture %_n, float* %f) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @218, i32 0, i32 0))
  %call = call i8* @strstr(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.328, i64 0, i64 0)) #15
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %p.0 = phi i8* [ %add.ptr, %if.end ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %p.0, align 1
  switch i8 %0, label %while.body [
    i8 40, label %for.cond
    i8 0, label %return
  ]

while.body:                                       ; preds = %while.cond
  %incdec.ptr = getelementptr inbounds i8, i8* %p.0, i64 1
  br label %while.cond

for.cond:                                         ; preds = %while.cond14, %while.cond
  %n.0 = phi i32 [ 0, %while.cond ], [ %inc, %while.cond14 ]
  %p.1 = phi i8* [ %p.0, %while.cond ], [ %p.2, %while.cond14 ]
  %incdec.ptr12 = getelementptr inbounds i8, i8* %p.1, i64 1
  %idxprom = zext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds float, float* %f, i64 %idxprom
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @219, i32 0, i32 0))
  %call13 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %incdec.ptr12, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4.234, i64 0, i64 0), float* %arrayidx) #11
  %inc = add i32 %n.0, 1
  br label %while.cond14

while.cond14:                                     ; preds = %while.body26, %for.cond
  %p.2 = phi i8* [ %incdec.ptr12, %for.cond ], [ %incdec.ptr27, %while.body26 ]
  %1 = load i8, i8* %p.2, align 1
  switch i8 %1, label %while.body26 [
    i8 44, label %for.cond
    i8 41, label %for.end
    i8 0, label %for.end
  ]

while.body26:                                     ; preds = %while.cond14
  %incdec.ptr27 = getelementptr inbounds i8, i8* %p.2, i64 1
  br label %while.cond14

for.end:                                          ; preds = %while.cond14, %while.cond14
  store i32 %inc, i32* %_n, align 4
  br label %return

return:                                           ; preds = %while.cond, %entry, %for.end
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_result_alloc_list(%struct.cass_result_t* nocapture %result, i32 %num_regions, i32 %topk) unnamed_addr #0 {
entry:
  %0 = bitcast %struct.cass_result_t* %result to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 32, i32 8, i1 false)
  %cmp = icmp eq i32 %num_regions, 0
  %flags = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 0
  br i1 %cmp, label %do.body, label %if.then36

do.body:                                          ; preds = %entry
  store i32 2, i32* %flags, align 8
  %inc = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  store i32 256, i32* %inc, align 8
  %size = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 %topk, i32* %size, align 4
  %len = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %len, align 8
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data, align 8
  %cmp7 = icmp eq i32 %topk, 0
  br i1 %cmp7, label %if.end107, label %if.then8

if.then8:                                         ; preds = %do.body
  %conv = zext i32 %topk to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @220, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %1 = bitcast %struct.cass_list_entry_t** %data to i8**
  store i8* %call, i8** %1, align 8
  %cmp15 = icmp eq i8* %call, null
  br i1 %cmp15, label %if.else, label %if.end107

if.else:                                          ; preds = %if.then8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @221, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5.237, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 143, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_result_alloc_list, i64 0, i64 0)) #16
  unreachable

if.then36:                                        ; preds = %entry
  store i32 8, i32* %flags, align 8
  %inc24 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  store i32 256, i32* %inc24, align 8
  %2 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 %num_regions, i32* %2, align 4
  %3 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %3, align 8
  %data33 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %4 = bitcast %struct.cass_list_entry_t** %data33 to %struct.cass_list_t**
  %conv37 = zext i32 %num_regions to i64
  %mul38 = mul nuw nsw i64 %conv37, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @222, i32 0, i32 0))
  %call39 = call noalias i8* @malloc(i64 %mul38) #11
  %5 = bitcast %struct.cass_list_entry_t** %data33 to i8**
  store i8* %call39, i8** %5, align 8
  %cmp46 = icmp eq i8* %call39, null
  br i1 %cmp46, label %if.else49, label %do.end52

if.else49:                                        ; preds = %if.then36
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @223, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.44, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 149, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_result_alloc_list, i64 0, i64 0)) #16
  unreachable

do.end52:                                         ; preds = %if.then36
  store i32 %num_regions, i32* %3, align 8
  %cmp81 = icmp eq i32 %topk, 0
  %conv84 = zext i32 %topk to i64
  %mul85 = shl nuw nsw i64 %conv84, 3
  %6 = zext i32 %num_regions to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end52
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %do.end52 ]
  %cmp56 = icmp ult i64 %indvars.iv, %6
  br i1 %cmp56, label %do.body58, label %if.end107

do.body58:                                        ; preds = %for.cond
  %7 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %inc62 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %7, i64 %indvars.iv, i32 0
  store i32 256, i32* %inc62, align 8
  %8 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %size68 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %8, i64 %indvars.iv, i32 1
  store i32 %topk, i32* %size68, align 4
  %9 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %len74 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %9, i64 %indvars.iv, i32 2
  store i32 0, i32* %len74, align 8
  %10 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %data80 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %10, i64 %indvars.iv, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data80, align 8
  br i1 %cmp81, label %for.inc, label %if.then83

if.then83:                                        ; preds = %do.body58
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @224, i32 0, i32 0))
  %call86 = call noalias i8* @malloc(i64 %mul85) #11
  %11 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %data92 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %11, i64 %indvars.iv, i32 3
  %12 = bitcast %struct.cass_list_entry_t** %data92 to i8**
  store i8* %call86, i8** %12, align 8
  %13 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  %data98 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %13, i64 %indvars.iv, i32 3
  %14 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data98, align 8
  %cmp99 = icmp eq %struct.cass_list_entry_t* %14, null
  br i1 %cmp99, label %if.else102, label %for.inc

if.else102:                                       ; preds = %if.then83
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @225, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.46, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 153, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__PRETTY_FUNCTION__.cass_result_alloc_list, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %if.then83, %do.body58
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end107:                                        ; preds = %for.cond, %if.then8, %do.body
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_result_free(%struct.cass_result_t* %result) unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 0
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 2
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %do.body

do.body:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %1 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data, align 8
  %cmp = icmp eq %struct.cass_list_entry_t* %1, null
  br i1 %cmp, label %do.end, label %if.then1

if.then1:                                         ; preds = %do.body
  %2 = bitcast %struct.cass_list_entry_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @226, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %do.end

do.end:                                           ; preds = %if.then1, %do.body
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data, align 8
  %len = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 0, i32* %size, align 4
  br label %if.end106

if.else:                                          ; preds = %entry
  %and13 = and i32 %0, 8
  %tobool14 = icmp eq i32 %and13, 0
  br i1 %tobool14, label %if.else54, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else
  %3 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  %data22 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %4 = bitcast %struct.cass_list_entry_t** %data22 to %struct.cass_list_t**
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %__array_foreach_index.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %5 = load i32, i32* %3, align 8
  %cmp19 = icmp ult i32 %__array_foreach_index.0, %5
  %6 = load %struct.cass_list_t*, %struct.cass_list_t** %4, align 8
  br i1 %cmp19, label %do.body23, label %do.body34

do.body23:                                        ; preds = %for.cond
  %idx.ext = zext i32 %__array_foreach_index.0 to i64
  %data24 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %6, i64 %idx.ext, i32 3
  %7 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data24, align 8
  %cmp25 = icmp eq %struct.cass_list_entry_t* %7, null
  br i1 %cmp25, label %for.inc, label %if.then26

if.then26:                                        ; preds = %do.body23
  %8 = bitcast %struct.cass_list_entry_t* %7 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @227, i32 0, i32 0))
  call void @free(i8* %8) #11
  br label %for.inc

for.inc:                                          ; preds = %do.body23, %if.then26
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data24, align 8
  %len30 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %6, i64 %idx.ext, i32 2
  store i32 0, i32* %len30, align 8
  %size31 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %6, i64 %idx.ext, i32 1
  store i32 0, i32* %size31, align 4
  %inc = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.body34:                                        ; preds = %for.cond
  %cmp38 = icmp eq %struct.cass_list_t* %6, null
  br i1 %cmp38, label %do.end53, label %if.then39

if.then39:                                        ; preds = %do.body34
  %9 = bitcast %struct.cass_list_t* %6 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @228, i32 0, i32 0))
  call void @free(i8* %9) #11
  br label %do.end53

do.end53:                                         ; preds = %if.then39, %do.body34
  store %struct.cass_list_t* null, %struct.cass_list_t** %4, align 8
  store i32 0, i32* %3, align 8
  %10 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 0, i32* %10, align 4
  br label %if.end106

if.else54:                                        ; preds = %if.else
  %and56 = and i32 %0, 1
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %if.else60, label %if.then58

if.then58:                                        ; preds = %if.else54
  %bitmap.idx = getelementptr %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  %11 = bitcast i32* %bitmap.idx to i8**
  %bitmap.idx.val = load i8*, i8** %11, align 8
  call fastcc void @bitmap_free_vec(i8* %bitmap.idx.val)
  br label %if.end106

if.else60:                                        ; preds = %if.else54
  %and62 = and i32 %0, 4
  %tobool63 = icmp eq i32 %and62, 0
  br i1 %tobool63, label %if.else102, label %for.cond67.preheader

for.cond67.preheader:                             ; preds = %if.else60
  %12 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  %data74 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %13 = bitcast %struct.cass_list_entry_t** %data74 to %struct.bitmap_t**
  br label %for.cond67

for.cond67:                                       ; preds = %for.cond67.preheader, %for.inc78
  %__array_foreach_index66.0 = phi i32 [ %inc79, %for.inc78 ], [ 0, %for.cond67.preheader ]
  %14 = load i32, i32* %12, align 8
  %cmp70 = icmp ult i32 %__array_foreach_index66.0, %14
  %15 = load %struct.bitmap_t*, %struct.bitmap_t** %13, align 8
  br i1 %cmp70, label %for.inc78, label %do.body82

for.inc78:                                        ; preds = %for.cond67
  %idx.ext75 = zext i32 %__array_foreach_index66.0 to i64
  %add.ptr76.idx = getelementptr %struct.bitmap_t, %struct.bitmap_t* %15, i64 %idx.ext75, i32 2
  %add.ptr76.idx.val = load i8*, i8** %add.ptr76.idx, align 8
  call fastcc void @bitmap_free_vec(i8* %add.ptr76.idx.val)
  %inc79 = add i32 %__array_foreach_index66.0, 1
  br label %for.cond67

do.body82:                                        ; preds = %for.cond67
  %cmp86 = icmp eq %struct.bitmap_t* %15, null
  br i1 %cmp86, label %do.end101, label %if.then87

if.then87:                                        ; preds = %do.body82
  %16 = bitcast %struct.bitmap_t* %15 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @229, i32 0, i32 0))
  call void @free(i8* %16) #11
  br label %do.end101

do.end101:                                        ; preds = %if.then87, %do.body82
  store %struct.bitmap_t* null, %struct.bitmap_t** %13, align 8
  store i32 0, i32* %12, align 8
  %17 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 0, i32* %17, align 4
  br label %if.end106

if.else102:                                       ; preds = %if.else60
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 227, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.13.247, i64 0, i64 0))
  br label %if.end106

if.end106:                                        ; preds = %do.end53, %do.end101, %if.else102, %if.then58, %do.end
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.cass_result_t* @cass_result_merge_lists(%struct.cass_result_t* nocapture readonly %src, %struct.cass_dataset_t* nocapture readonly %ds) unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %src, i64 0, i32 0
  %0 = load i32, i32* %flags, align 8
  %and = and i32 %0, 4
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @230, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.14.250, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 250, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.cass_result_merge_lists, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %and2 = and i32 %0, 1
  %cmp3 = icmp eq i32 %and2, 0
  br i1 %cmp3, label %if.end6, label %if.else5

if.else5:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @231, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.15.251, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 251, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.cass_result_merge_lists, i64 0, i64 0)) #16
  unreachable

if.end6:                                          ; preds = %if.end
  %and8 = and i32 %0, 2
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end12, label %if.else11

if.else11:                                        ; preds = %if.end6
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @232, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.16.252, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 252, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.cass_result_merge_lists, i64 0, i64 0)) #16
  unreachable

if.end12:                                         ; preds = %if.end6
  %and14 = and i32 %0, 8
  %tobool = icmp eq i32 %and14, 0
  br i1 %tobool, label %if.else16, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end12
  %1 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %src, i64 0, i32 1, i32 0, i32 2
  %2 = load i32, i32* %1, align 8
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %src, i64 0, i32 1, i32 0, i32 3
  %3 = bitcast %struct.cass_list_entry_t** %data to %struct.cass_list_t**
  br label %for.cond

if.else16:                                        ; preds = %if.end12
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @233, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.17.253, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.3.218, i64 0, i64 0), i32 253, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.cass_result_merge_lists, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv20 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next21, %for.inc ]
  %merged_topk.0 = phi i32 [ 0, %for.cond.preheader ], [ %add, %for.inc ]
  %wide.trip.count22 = zext i32 %2 to i64
  %exitcond23 = icmp eq i64 %indvars.iv20, %wide.trip.count22
  br i1 %exitcond23, label %do.body29, label %for.inc

for.inc:                                          ; preds = %for.cond
  %4 = load %struct.cass_list_t*, %struct.cass_list_t** %3, align 8
  %p.sroa.1.0..sroa_idx11 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %4, i64 %indvars.iv20, i32 2
  %p.sroa.1.0.copyload = load i32, i32* %p.sroa.1.0..sroa_idx11, align 8
  %add = add i32 %merged_topk.0, %p.sroa.1.0.copyload
  %indvars.iv.next21 = add nuw nsw i64 %indvars.iv20, 1
  br label %for.cond

do.body29:                                        ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @234, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 32, i64 1) #11
  %5 = bitcast i8* %call to %struct.cass_result_t*
  call fastcc void @cass_result_alloc_list(%struct.cass_result_t* %5, i32 0, i32 %merged_topk.0)
  %len28 = getelementptr inbounds i8, i8* %call, i64 16
  %6 = bitcast i8* %len28 to i32*
  store i32 %merged_topk.0, i32* %6, align 8
  %data35 = getelementptr inbounds i8, i8* %call, i64 24
  %7 = bitcast i8* %data35 to %struct.cass_list_entry_t**
  %8 = sext i32 %merged_topk.0 to i64
  br label %for.cond30

for.cond30:                                       ; preds = %for.inc38, %do.body29
  %indvars.iv18 = phi i64 [ %indvars.iv.next19, %for.inc38 ], [ 0, %do.body29 ]
  %cmp31 = icmp slt i64 %indvars.iv18, %8
  br i1 %cmp31, label %for.inc38, label %for.cond44.preheader

for.cond44.preheader:                             ; preds = %for.cond30
  %max_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 4
  %vec72 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  %9 = sext i32 %merged_topk.0 to i64
  br label %for.cond44

for.inc38:                                        ; preds = %for.cond30
  %10 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %7, align 8
  %id = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %10, i64 %indvars.iv18, i32 0
  store i32 -1, i32* %id, align 4
  %indvars.iv.next19 = add nuw nsw i64 %indvars.iv18, 1
  br label %for.cond30

for.cond44:                                       ; preds = %for.cond44.preheader, %for.inc132
  %__array_foreach_index43.0 = phi i32 [ %inc133, %for.inc132 ], [ 0, %for.cond44.preheader ]
  %11 = load i32, i32* %1, align 8
  %cmp48 = icmp ult i32 %__array_foreach_index43.0, %11
  br i1 %cmp48, label %do.body56, label %do.end135

do.body56:                                        ; preds = %for.cond44
  %12 = load %struct.cass_list_t*, %struct.cass_list_t** %3, align 8
  %idxprom54 = zext i32 %__array_foreach_index43.0 to i64
  %p50.sroa.1.0..sroa_idx7 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %12, i64 %idxprom54, i32 2
  %p50.sroa.1.0.copyload = load i32, i32* %p50.sroa.1.0..sroa_idx7, align 8
  %p50.sroa.28.0..sroa_idx9 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %12, i64 %idxprom54, i32 3
  %p50.sroa.28.0.copyload = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %p50.sroa.28.0..sroa_idx9, align 8
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc128, %do.body56
  %indvars.iv16 = phi i64 [ %indvars.iv.next17, %for.inc128 ], [ 0, %do.body56 ]
  %wide.trip.count = zext i32 %p50.sroa.1.0.copyload to i64
  %exitcond = icmp eq i64 %indvars.iv16, %wide.trip.count
  br i1 %exitcond, label %for.inc132, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond58
  %arrayidx64 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %p50.sroa.28.0.copyload, i64 %indvars.iv16
  %13 = bitcast %struct.cass_list_entry_t* %arrayidx64 to i64*
  %14 = load i64, i64* %13, align 4
  %p2.sroa.0.0.extract.trunc = trunc i64 %14 to i32
  %15 = load i32, i32* %max_vec, align 8
  %cmp69 = icmp ugt i32 %p2.sroa.0.0.extract.trunc, %15
  br i1 %cmp69, label %for.inc128, label %do.body75

do.body75:                                        ; preds = %lor.lhs.false
  %16 = load i8*, i8** %vec72, align 8
  %17 = load i32, i32* %vec_size, align 8
  %mul = mul i32 %17, %p2.sroa.0.0.extract.trunc
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %16, i64 %idx.ext
  %parent = getelementptr inbounds i8, i8* %add.ptr, i64 4
  %18 = bitcast i8* %parent to i32*
  %19 = load i32, i32* %18, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end97, %do.body75
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end97 ], [ 0, %do.body75 ]
  %cmp77 = icmp slt i64 %indvars.iv, %9
  %20 = trunc i64 %indvars.iv to i32
  br i1 %cmp77, label %while.body, label %if.end101

while.body:                                       ; preds = %while.cond
  %21 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %7, align 8
  %id84 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %21, i64 %indvars.iv, i32 0
  %22 = load i32, i32* %id84, align 4
  %cmp85 = icmp ugt i32 %19, %22
  br i1 %cmp85, label %if.end101, label %if.end87

if.end87:                                         ; preds = %while.body
  %cmp95 = icmp eq i32 %19, %22
  br i1 %cmp95, label %for.inc128, label %if.end97

if.end97:                                         ; preds = %if.end87
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %while.cond

if.end101:                                        ; preds = %while.cond, %while.body
  %cmp102 = icmp eq i32 %20, 0
  br i1 %cmp102, label %for.inc128, label %for.cond105.preheader

for.cond105.preheader:                            ; preds = %if.end101
  %sub = shl i64 %indvars.iv, 32
  %sext = add i64 %sub, -4294967296
  %23 = ashr exact i64 %sext, 32
  br label %for.cond105

for.cond105:                                      ; preds = %for.cond105.preheader, %for.inc119
  %indvars.iv14 = phi i64 [ 0, %for.cond105.preheader ], [ %indvars.iv.next15, %for.inc119 ]
  %cmp106 = icmp slt i64 %indvars.iv14, %23
  %24 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %7, align 8
  br i1 %cmp106, label %for.inc119, label %for.end121

for.inc119:                                       ; preds = %for.cond105
  %arrayidx112 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %24, i64 %indvars.iv14
  %indvars.iv.next15 = add nuw nsw i64 %indvars.iv14, 1
  %arrayidx118 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %24, i64 %indvars.iv.next15
  %25 = bitcast %struct.cass_list_entry_t* %arrayidx118 to i64*
  %26 = bitcast %struct.cass_list_entry_t* %arrayidx112 to i64*
  %27 = load i64, i64* %25, align 4
  store i64 %27, i64* %26, align 4
  br label %for.cond105

for.end121:                                       ; preds = %for.cond105
  %sext24 = shl i64 %indvars.iv14, 32
  %idxprom125 = ashr exact i64 %sext24, 32
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %24, i64 %idxprom125, i32 0
  store i32 %19, i32* %.sroa_idx, align 4
  %.sroa_idx2 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %24, i64 %idxprom125, i32 1
  %.sroa_cast = bitcast float* %.sroa_idx2 to i32*
  store i32 0, i32* %.sroa_cast, align 4
  br label %for.inc128

for.inc128:                                       ; preds = %if.end87, %for.end121, %if.end101, %lor.lhs.false
  %indvars.iv.next17 = add nuw nsw i64 %indvars.iv16, 1
  br label %for.cond58

for.inc132:                                       ; preds = %for.cond58
  %inc133 = add i32 %__array_foreach_index43.0, 1
  br label %for.cond44

do.end135:                                        ; preds = %for.cond44
  %flags136 = bitcast i8* %call to i32*
  %28 = load i32, i32* %flags136, align 8
  %or = or i32 %28, 256
  store i32 %or, i32* %flags136, align 8
  ret %struct.cass_result_t* %5
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.bitmap_t* @bitmap_new(i32 %x) unnamed_addr #0 {
entry:
  %add = add i32 %x, 31
  %div = lshr i32 %add, 3
  %div1 = and i32 %div, 536870908
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @235, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 16) #11
  %0 = bitcast i8* %call to %struct.bitmap_t*
  %count = getelementptr inbounds i8, i8* %call, i64 4
  %1 = bitcast i8* %count to i32*
  store i32 0, i32* %1, align 4
  %mul2 = shl nuw i32 %div1, 3
  %size = bitcast i8* %call to i32*
  store i32 %mul2, i32* %size, align 8
  %conv = zext i32 %div1 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @236, i32 0, i32 0))
  %call4 = call noalias i8* @malloc(i64 %conv) #11
  %vec = getelementptr inbounds i8, i8* %call, i64 8
  %2 = bitcast i8* %vec to i8**
  store i8* %call4, i8** %2, align 8
  call void @llvm.memset.p0i8.i64(i8* %call4, i8 0, i64 %conv, i32 1, i1 false)
  ret %struct.bitmap_t* %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @bitmap_clear(i32 %map.0.0.val, i8* nocapture %map.0.2.val) unnamed_addr #0 {
entry:
  %div = lshr i32 %map.0.0.val, 3
  %conv = zext i32 %div to i64
  call void @llvm.memset.p0i8.i64(i8* %map.0.2.val, i8 0, i64 %conv, i32 1, i1 false)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @bitmap_free_vec(i8* %map.0.2.val) unnamed_addr #0 {
entry:
  %cmp = icmp eq i8* %map.0.2.val, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @237, i32 0, i32 0))
  call void @free(i8* %map.0.2.val) #11
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @bitmap_free(%struct.bitmap_t** nocapture %map) unnamed_addr #0 {
entry:
  %0 = load %struct.bitmap_t*, %struct.bitmap_t** %map, align 8
  %tobool = icmp eq %struct.bitmap_t* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %vec = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %0, i64 0, i32 2
  %1 = load i8*, i8** %vec, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @238, i32 0, i32 0))
  call void @free(i8* %1) #11
  %2 = bitcast %struct.bitmap_t** %map to i8**
  %3 = load i8*, i8** %2, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @239, i32 0, i32 0))
  call void @free(i8* %3) #11
  store %struct.bitmap_t* null, %struct.bitmap_t** %map, align 8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @bitmap_get_count(i32 returned %map.0.1.val) unnamed_addr #7 {
entry:
  ret i32 %map.0.1.val
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @bitmap_get_size(i32 returned %map.0.0.val) unnamed_addr #7 {
entry:
  ret i32 %map.0.0.val
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @bitmap_contain(%struct.bitmap_t* nocapture readonly %map, i32 %item) unnamed_addr #6 {
entry:
  %size = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 0
  %0 = load i32, i32* %size, align 8
  %cmp = icmp ugt i32 %0, %item
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %vec = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 2
  %1 = load i8*, i8** %vec, align 8
  %shr = lshr i32 %item, 3
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %item, 7
  %shl = shl i32 1, %and
  %and1 = and i32 %conv, %shl
  %tobool = icmp eq i32 %and1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %return

return:                                           ; preds = %land.lhs.true, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @bitmap_insert(%struct.bitmap_t* nocapture %map, i32 %item) unnamed_addr #0 {
entry:
  %size = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 0
  %0 = load i32, i32* %size, align 8
  %cmp = icmp ugt i32 %0, %item
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @240, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3.268, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.4.269, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__PRETTY_FUNCTION__.bitmap_insert, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %vec = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 2
  %1 = load i8*, i8** %vec, align 8
  %shr = lshr i32 %item, 3
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %item, 7
  %shl = shl i32 1, %and
  %and1 = and i32 %conv, %shl
  %cmp2 = icmp eq i32 %and1, 0
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %count = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 1
  %3 = load i32, i32* %count, align 4
  %inc = add i32 %3, 1
  store i32 %inc, i32* %count, align 4
  %.pre = load i8, i8* %arrayidx, align 1
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %4 = phi i8 [ %.pre, %if.then4 ], [ %2, %if.end ]
  %conv12 = zext i8 %4 to i32
  %or = or i32 %conv12, %shl
  %conv13 = trunc i32 %or to i8
  store i8 %conv13, i8* %arrayidx, align 1
  ret void
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @bitmap_getNext(%struct.bitmap_t* nocapture readonly %map, i32 %cur) unnamed_addr #6 {
entry:
  %size = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 0
  %0 = load i32, i32* %size, align 8
  %cmp = icmp ugt i32 %0, %cur
  %inc = add i32 %cur, 1
  %inc. = select i1 %cmp, i32 %inc, i32 0
  %vec = getelementptr inbounds %struct.bitmap_t, %struct.bitmap_t* %map, i64 0, i32 2
  br label %while.cond

while.cond:                                       ; preds = %entry, %while.body
  %cur.addr.1 = phi i32 [ %inc4, %while.body ], [ %inc., %entry ]
  %cmp2 = icmp ult i32 %cur.addr.1, %0
  br i1 %cmp2, label %land.end, label %while.end

land.end:                                         ; preds = %while.cond
  %1 = load i8*, i8** %vec, align 8
  %shr = lshr i32 %cur.addr.1, 3
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %cur.addr.1, 7
  %shl = shl i32 1, %and
  %and3 = and i32 %conv, %shl
  %lnot = icmp eq i32 %and3, 0
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %inc4 = add i32 %cur.addr.1, 1
  br label %while.cond

while.end:                                        ; preds = %while.cond, %land.end
  ret i32 %cur.addr.1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_private_init(%struct.cass_map_t* %map, i32 %size) unnamed_addr #0 {
do.body:
  %inc = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 0
  store i32 256, i32* %inc, align 8
  %size2 = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 1
  store i32 %size, i32* %size2, align 4
  %len = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 2
  store i32 0, i32* %len, align 8
  %data = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 3
  store i8** null, i8*** %data, align 8
  %cmp = icmp eq i32 %size, 0
  br i1 %cmp, label %do.end16, label %if.then

if.then:                                          ; preds = %do.body
  %conv = zext i32 %size to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @241, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %0 = bitcast i8*** %data to i8**
  store i8* %call, i8** %0, align 8
  %cmp9 = icmp eq i8* %call, null
  br i1 %cmp9, label %if.else, label %do.end16

if.else:                                          ; preds = %if.then
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @242, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.276, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 29, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__.cass_map_private_init, i64 0, i64 0)) #16
  unreachable

do.end16:                                         ; preds = %do.body, %if.then
  store i32 16384, i32* %inc, align 8
  %vtable17 = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8
  %call18 = call fastcc %struct.CKHash_Table_* @ckh_alloc_table(i32 %size, %struct.anon.7* %vtable17)
  %htable = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 9
  store %struct.CKHash_Table_* %call18, %struct.CKHash_Table_** %htable, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_insert(%struct.cass_map_t* nocapture %map, i32* nocapture %id, i8* nocapture readonly %dataobj_name) unnamed_addr #0 {
entry:
  %flag = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 4
  %0 = load i32, i32* %flag, align 8
  %and = and i32 %0, 8
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @243, i32 0, i32 0))
  %call = call noalias i8* @strdup(i8* %dataobj_name) #11
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %do.body8

do.body8:                                         ; preds = %if.end
  %len = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 2
  %1 = load i32, i32* %len, align 8
  store i32 %1, i32* %id, align 4
  %2 = load i32, i32* %len, align 8
  %inc = add i32 %2, 1
  store i32 %inc, i32* %len, align 8
  %size = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 1
  %3 = load i32, i32* %size, align 4
  %cmp12 = icmp ult i32 %3, %inc
  br i1 %cmp12, label %if.end14, label %do.body8.do.end56_crit_edge

do.body8.do.end56_crit_edge:                      ; preds = %do.body8
  %data55.phi.trans.insert = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 3
  %.pre = load i8**, i8*** %data55.phi.trans.insert, align 8
  br label %do.end56

if.end14:                                         ; preds = %do.body8
  %inc20 = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 0
  %4 = load i32, i32* %inc20, align 8
  %add = add i32 %2, %4
  %neg = sub i32 0, %4
  %and28 = and i32 %add, %neg
  store i32 %and28, i32* %size, align 4
  %data = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 3
  %5 = load i8**, i8*** %data, align 8
  %cmp30 = icmp eq i8** %5, null
  br i1 %cmp30, label %if.else, label %if.then31

if.then31:                                        ; preds = %if.end14
  %6 = bitcast i8** %5 to i8*
  %7 = bitcast i8*** %data to i8**
  %conv = zext i32 %and28 to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @244, i32 0, i32 0))
  %call36 = call i8* @realloc(i8* %6, i64 %mul) #11
  store i8* %call36, i8** %7, align 8
  br label %if.end46

if.else:                                          ; preds = %if.end14
  %conv41 = zext i32 %and28 to i64
  %mul42 = shl nuw nsw i64 %conv41, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @245, i32 0, i32 0))
  %call43 = call noalias i8* @malloc(i64 %mul42) #11
  %8 = bitcast i8*** %data to i8**
  store i8* %call43, i8** %8, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.else, %if.then31
  %call43.sink = phi i8* [ %call43, %if.else ], [ %call36, %if.then31 ]
  %9 = bitcast i8* %call43.sink to i8**
  %cmp49 = icmp eq i8* %call43.sink, null
  br i1 %cmp49, label %if.else52, label %do.end56

if.else52:                                        ; preds = %if.end46
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @246, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.276, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 148, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.cass_map_insert, i64 0, i64 0)) #16
  unreachable

do.end56:                                         ; preds = %do.body8.do.end56_crit_edge, %if.end46
  %10 = phi i8** [ %.pre, %do.body8.do.end56_crit_edge ], [ %9, %if.end46 ]
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %10, i64 %idxprom
  store i8* %call, i8** %arrayidx, align 8
  %htable = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 9
  %11 = load %struct.CKHash_Table_*, %struct.CKHash_Table_** %htable, align 8
  %12 = load i32, i32* %id, align 4
  call fastcc void @ckh_insert(%struct.CKHash_Table_* %11, i32 %12)
  %dirty = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 7
  store i32 1, i32* %dirty, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %do.end56
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_release(%struct.cass_map_t* nocapture %map) unnamed_addr #0 {
entry:
  %dirty = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 7
  %0 = load i32, i32* %dirty, align 4
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %for.cond.preheader, label %if.else

for.cond.preheader:                               ; preds = %entry
  %len = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 2
  %data = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 3
  br label %for.cond

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @247, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.280, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 156, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__PRETTY_FUNCTION__.cass_map_release, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %__array_foreach_index.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %1 = load i32, i32* %len, align 8
  %cmp = icmp ult i32 %__array_foreach_index.0, %1
  %2 = load i8**, i8*** %data, align 8
  br i1 %cmp, label %for.body, label %do.body5

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %__array_foreach_index.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %2, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8
  %tobool2 = icmp eq i8* %3, null
  br i1 %tobool2, label %for.inc, label %if.then3

if.then3:                                         ; preds = %for.body
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @248, i32 0, i32 0))
  call void @free(i8* %3) #11
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.body5:                                         ; preds = %for.cond
  %cmp8 = icmp eq i8** %2, null
  br i1 %cmp8, label %do.end18, label %if.then9

if.then9:                                         ; preds = %do.body5
  %4 = bitcast i8** %2 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @249, i32 0, i32 0))
  call void @free(i8* %4) #11
  br label %do.end18

do.end18:                                         ; preds = %if.then9, %do.body5
  store i8** null, i8*** %data, align 8
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 1
  store i32 0, i32* %size, align 4
  %htable = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 9
  %5 = load %struct.CKHash_Table_*, %struct.CKHash_Table_** %htable, align 8
  call fastcc void @ckh_destruct_table(%struct.CKHash_Table_* %5)
  %loaded = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 6
  store i32 0, i32* %loaded, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_load(%struct.cass_map_t* %map) unnamed_addr #0 {
entry:
  call fastcc void @cass_map_load_private(%struct.cass_map_t* %map)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_load_private(%struct.cass_map_t* %map) unnamed_addr #0 {
entry:
  %tb_size = alloca i32, align 4
  %vid = alloca i32, align 4
  %buf = alloca [8192 x i8], align 16
  %loaded = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 6
  %0 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @250, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14.283, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 64, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__PRETTY_FUNCTION__.cass_map_load_private, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [8192 x i8], [8192 x i8]* %buf, i64 0, i64 0
  %env = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 3
  %1 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %base_dir = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %1, i64 0, i32 1
  %2 = load i8*, i8** %base_dir, align 8
  %name = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 2
  %3 = load i8*, i8** %name, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @251, i32 0, i32 0))
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 8192, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15.284, i64 0, i64 0), i8* %2, i8* %3) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @252, i32 0, i32 0))
  %call2 = call %struct._IO_FILE* @fopen(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23.358, i64 0, i64 0))
  %cmp = icmp eq %struct._IO_FILE* %call2, null
  br i1 %cmp, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call fastcc i32 @cass_read_uint32.286(i32* nonnull %tb_size, %struct._IO_FILE* nonnull %call2)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %if.end8, label %return

if.end8:                                          ; preds = %if.end4
  %4 = load i32, i32* %tb_size, align 4
  %cmp9 = icmp eq i32 %4, 0
  br i1 %cmp9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.end8
  call fastcc void @cass_map_private_init(%struct.cass_map_t* %map, i32 256)
  br label %if.end24

if.else12:                                        ; preds = %if.end8
  call fastcc void @cass_map_private_init(%struct.cass_map_t* %map, i32 %4)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else12
  %ix.0 = phi i32 [ 0, %if.else12 ], [ %inc, %for.inc ]
  %cmp14 = icmp ult i32 %ix.0, %4
  br i1 %cmp14, label %for.body, label %if.end24

for.body:                                         ; preds = %for.cond
  %call15 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* nonnull %call2)
  %cmp16 = icmp eq i8* %call15, null
  br i1 %cmp16, label %return, label %if.end18

if.end18:                                         ; preds = %for.body
  call fastcc void @cass_map_insert(%struct.cass_map_t* %map, i32* nonnull %vid, i8* nonnull %call15)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @253, i32 0, i32 0))
  call void @free(i8* %call15) #11
  %5 = load i32, i32* %vid, align 4
  %cmp20 = icmp eq i32 %5, %ix.0
  br i1 %cmp20, label %for.inc, label %if.else22

if.else22:                                        ; preds = %if.end18
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @254, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17.287, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 81, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__PRETTY_FUNCTION__.cass_map_load_private, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %if.end18
  %inc = add i32 %ix.0, 1
  br label %for.cond

if.end24:                                         ; preds = %for.cond, %if.then10
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @255, i32 0, i32 0))
  %call25 = call i32 @fclose(%struct._IO_FILE* nonnull %call2)
  store i32 1, i32* %loaded, align 8
  %dirty = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 7
  store i32 0, i32* %dirty, align 4
  br label %return

return:                                           ; preds = %for.body, %if.end4, %if.end, %if.end24
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.286(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @256, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.288()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.288() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_id_to_dataobj(%struct.cass_map_t* nocapture readonly %map, i32 %id, i8** nocapture %dataobj_name) unnamed_addr #0 {
entry:
  %flag = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 4
  %0 = load i32, i32* %flag, align 8
  %and = and i32 %0, 8
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @257, i32 0, i32 0))
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @local_buf, i64 0, i64 0), i64 8192, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5.291, i64 0, i64 0), i32 %id) #11
  store i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @local_buf, i64 0, i64 0), i8** %dataobj_name, align 8
  br label %return

lor.lhs.false:                                    ; preds = %entry
  %len = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 2
  %1 = load i32, i32* %len, align 8
  %cmp1 = icmp ugt i32 %1, %id
  br i1 %cmp1, label %if.end3, label %return

if.end3:                                          ; preds = %lor.lhs.false
  %data = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 8, i32 3
  %2 = load i8**, i8*** %data, align 8
  %idxprom = zext i32 %id to i64
  %arrayidx = getelementptr inbounds i8*, i8** %2, i64 %idxprom
  %3 = bitcast i8** %arrayidx to i64*
  %4 = load i64, i64* %3, align 8
  %5 = bitcast i8** %dataobj_name to i64*
  store i64 %4, i64* %5, align 8
  br label %return

return:                                           ; preds = %if.end3, %lor.lhs.false, %if.then
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_map_restore(%struct.cass_map_t** nocapture %_map, %struct._cass_env_t* %env, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %n = alloca i32, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @258, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 96, i64 1) #11
  %0 = bitcast i8* %call to %struct.cass_map_t*
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %env1 = getelementptr inbounds i8, i8* %call, i64 16
  %1 = bitcast i8* %env1 to %struct._cass_env_t**
  store %struct._cass_env_t* %env, %struct._cass_env_t** %1, align 8
  %refcnt = getelementptr inbounds i8, i8* %call, i64 4
  %2 = bitcast i8* %refcnt to i32*
  store i32 1, i32* %2, align 4
  %magic = bitcast i8* %call to i32*
  %call2 = call fastcc i32 @cass_read_int32.303(i32* %magic, i64 1, %struct._IO_FILE* %in)
  %cmp3 = icmp eq i32 %call2, 1
  br i1 %cmp3, label %if.end5, label %if.then64

if.end5:                                          ; preds = %if.end
  %3 = load i32, i32* %magic, align 8
  %cmp7 = icmp eq i32 %3, -559087325
  br i1 %cmp7, label %if.end9, label %if.else

if.else:                                          ; preds = %if.end5
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @259, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2.278, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 237, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.cass_map_restore, i64 0, i64 0)) #16
  unreachable

if.end9:                                          ; preds = %if.end5
  %call10 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %in)
  %name = getelementptr inbounds i8, i8* %call, i64 8
  %4 = bitcast i8* %name to i8**
  store i8* %call10, i8** %4, align 8
  %cmp12 = icmp eq i8* %call10, null
  br i1 %cmp12, label %if.then64, label %if.end14

if.end14:                                         ; preds = %if.end9
  %flag = getelementptr inbounds i8, i8* %call, i64 24
  %5 = bitcast i8* %flag to i32*
  %call15 = call fastcc i32 @cass_read_uint32.286(i32* %5, %struct._IO_FILE* %in)
  %cmp16 = icmp eq i32 %call15, 1
  br i1 %cmp16, label %if.end18, label %if.then64

if.end18:                                         ; preds = %if.end14
  %call19 = call fastcc i32 @cass_read_uint32.286(i32* nonnull %n, %struct._IO_FILE* %in)
  %cmp20 = icmp eq i32 %call19, 1
  br i1 %cmp20, label %do.body, label %if.then64

do.body:                                          ; preds = %if.end18
  %table_ids = getelementptr inbounds i8, i8* %call, i64 32
  %inc23 = bitcast i8* %table_ids to i32*
  store i32 256, i32* %inc23, align 8
  %6 = load i32, i32* %n, align 4
  %size = getelementptr inbounds i8, i8* %call, i64 36
  %7 = bitcast i8* %size to i32*
  store i32 %6, i32* %7, align 4
  %len = getelementptr inbounds i8, i8* %call, i64 40
  %8 = bitcast i8* %len to i32*
  store i32 0, i32* %8, align 8
  %data = getelementptr inbounds i8, i8* %call, i64 48
  %9 = bitcast i8* %data to i32**
  store i32* null, i32** %9, align 8
  %cmp27 = icmp eq i32 %6, 0
  br i1 %cmp27, label %if.end61, label %if.then28

if.then28:                                        ; preds = %do.body
  %conv = zext i32 %6 to i64
  %mul = shl nuw nsw i64 %conv, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @260, i32 0, i32 0))
  %call29 = call noalias i8* @malloc(i64 %mul) #11
  %10 = bitcast i8* %data to i8**
  store i8* %call29, i8** %10, align 8
  %cmp34 = icmp eq i8* %call29, null
  br i1 %cmp34, label %if.else37, label %if.then50

if.else37:                                        ; preds = %if.then28
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @261, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.3.279, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 248, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__PRETTY_FUNCTION__.cass_map_restore, i64 0, i64 0)) #16
  unreachable

if.then50:                                        ; preds = %if.then28
  %11 = bitcast i8* %call29 to i32*
  %call54 = call fastcc i32 @cass_read_int32.303(i32* %11, i64 %conv, %struct._IO_FILE* %in)
  %12 = load i32, i32* %n, align 4
  %cmp55 = icmp eq i32 %call54, %12
  br i1 %cmp55, label %if.end58, label %if.then64

if.end58:                                         ; preds = %if.then50
  store i32 %call54, i32* %8, align 8
  br label %if.end61

if.end61:                                         ; preds = %do.body, %if.end58
  %13 = bitcast %struct.cass_map_t** %_map to i8**
  store i8* %call, i8** %13, align 8
  br label %return

if.then64:                                        ; preds = %if.then50, %if.end18, %if.end14, %if.end9, %if.end
  %ret.0.ph = phi i32 [ -9995, %if.then50 ], [ -9995, %if.end18 ], [ -9995, %if.end14 ], [ -9998, %if.end9 ], [ -9998, %if.end ]
  call fastcc void @cass_map_free(%struct.cass_map_t* %0)
  br label %return

return:                                           ; preds = %if.then64, %entry, %if.end61
  %retval.0 = phi i32 [ 0, %if.end61 ], [ %ret.0.ph, %if.then64 ], [ -9998, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_int32.303(i32* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @262, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.288()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_map_free(%struct.cass_map_t* %map) unnamed_addr #0 {
entry:
  %cmp = icmp eq %struct.cass_map_t* %map, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @263, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13.306, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 297, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__PRETTY_FUNCTION__.cass_map_free, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %refcnt = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 1
  %0 = load i32, i32* %refcnt, align 4
  %dec = add i32 %0, -1
  store i32 %dec, i32* %refcnt, align 4
  %cmp2 = icmp eq i32 %dec, 0
  br i1 %cmp2, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %name = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 2
  %1 = load i8*, i8** %name, align 8
  %cmp5 = icmp eq i8* %1, null
  br i1 %cmp5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @264, i32 0, i32 0))
  call void @free(i8* %1) #11
  br label %if.end8

if.end8:                                          ; preds = %if.end4, %if.then6
  %dirty = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 7
  %2 = load i32, i32* %dirty, align 4
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %do.body, label %if.else10

if.else10:                                        ; preds = %if.end8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @265, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.280, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.1.277, i64 0, i64 0), i32 302, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__PRETTY_FUNCTION__.cass_map_free, i64 0, i64 0)) #16
  unreachable

do.body:                                          ; preds = %if.end8
  %data = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 5, i32 3
  %3 = load i32*, i32** %data, align 8
  %cmp12 = icmp eq i32* %3, null
  br i1 %cmp12, label %do.end, label %if.then13

if.then13:                                        ; preds = %do.body
  %4 = bitcast i32* %3 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @266, i32 0, i32 0))
  call void @free(i8* %4) #11
  br label %do.end

do.end:                                           ; preds = %if.then13, %do.body
  store i32* null, i32** %data, align 8
  %len = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 5, i32 2
  store i32 0, i32* %len, align 8
  %size = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 5, i32 1
  store i32 0, i32* %size, align 4
  %loaded = getelementptr inbounds %struct.cass_map_t, %struct.cass_map_t* %map, i64 0, i32 6
  %5 = load i32, i32* %loaded, align 8
  %tobool21 = icmp eq i32 %5, 0
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %do.end
  call fastcc void @cass_map_release(%struct.cass_map_t* nonnull %map)
  br label %if.end23

if.end23:                                         ; preds = %do.end, %if.then22
  %6 = bitcast %struct.cass_map_t* %map to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @267, i32 0, i32 0))
  call void @free(i8* %6) #11
  br label %return

return:                                           ; preds = %if.end, %if.end23
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @stimer_tick(%struct.stimer_t* nocapture %timer) unnamed_addr #0 {
entry:
  %start = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 0
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @268, i32 0, i32 0))
  %call = call i32 @gettimeofday(%struct.timespec* %start, %struct._cass_vecset_t* null) #11
  ret void
}

; Function Attrs: nounwind
declare i32 @gettimeofday(%struct.timespec* nocapture, %struct._cass_vecset_t* nocapture) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @stimer_tuck(%struct.stimer_t* nocapture %timer) unnamed_addr #0 {
if.end:
  %end = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 1
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @269, i32 0, i32 0))
  %call = call i32 @gettimeofday(%struct.timespec* %end, %struct._cass_vecset_t* null) #11
  %tv_sec = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 1, i32 0
  %0 = load i64, i64* %tv_sec, align 8
  %tv_sec2 = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 0, i32 0
  %1 = load i64, i64* %tv_sec2, align 8
  %sub = sub nsw i64 %0, %1
  %conv = sitofp i64 %sub to double
  %tv_usec = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 1, i32 1
  %2 = load i64, i64* %tv_usec, align 8
  %tv_usec5 = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 0, i32 1
  %3 = load i64, i64* %tv_usec5, align 8
  %sub6 = sub nsw i64 %2, %3
  %conv7 = sitofp i64 %sub6 to double
  %mul = fmul double %conv7, 1.000000e-06
  %add = fadd double %conv, %mul
  %conv8 = fptrunc double %add to float
  %diff = getelementptr inbounds %struct.stimer_t, %struct.stimer_t* %timer, i64 0, i32 2
  store float %conv8, float* %diff, align 8
  %conv10 = fpext float %conv8 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @270, i32 0, i32 0))
  %call11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.320, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i64 0, i64 0), double %conv10)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_init_private(%struct._cass_table.157* nocapture %table, i8* %param) #0 {
entry:
  %n = alloca i32, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @271, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 112, i64 1) #11
  %parent_cfg = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 14
  %0 = load %struct._cass_vecset_cfg_t*, %struct._cass_vecset_cfg_t** %parent_cfg, align 8
  %cmp = icmp eq %struct._cass_vecset_cfg_t* %0, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @272, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.321, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 40, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.LSH_init_private, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %vec_dim = getelementptr inbounds %struct._cass_vecset_cfg_t, %struct._cass_vecset_cfg_t* %0, i64 0, i32 4
  %1 = load i32, i32* %vec_dim, align 8
  %D2 = bitcast i8* %call to i32*
  store i32 %1, i32* %D2, align 8
  %call3 = call fastcc i32 @param_get_int(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2.323, i64 0, i64 0), i32 10)
  %M4 = getelementptr inbounds i8, i8* %call, i64 4
  %2 = bitcast i8* %M4 to i32*
  store i32 %call3, i32* %2, align 4
  %cmp5 = icmp ult i32 %call3, 33
  br i1 %cmp5, label %if.end9, label %if.else8

if.else8:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @273, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.3.324, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 43, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.LSH_init_private, i64 0, i64 0)) #16
  unreachable

if.end9:                                          ; preds = %if.end
  %call10 = call fastcc i32 @param_get_int(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4.325, i64 0, i64 0), i32 1)
  %L11 = getelementptr inbounds i8, i8* %call, i64 8
  %3 = bitcast i8* %L11 to i32*
  store i32 %call10, i32* %3, align 8
  %call12 = call fastcc i32 @param_get_int(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5.326, i64 0, i64 0), i32 1017881)
  %H13 = getelementptr inbounds i8, i8* %call, i64 12
  %4 = bitcast i8* %H13 to i32*
  store i32 %call12, i32* %4, align 4
  %conv14 = zext i32 %call10 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @274, i32 0, i32 0))
  %call15 = call noalias i8* @calloc(i64 4, i64 %conv14) #11
  %W = getelementptr inbounds i8, i8* %call, i64 24
  %5 = bitcast i8* %W to i8**
  store i8* %call15, i8** %5, align 8
  %call16 = call fastcc float @param_get_float(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.327, i64 0, i64 0), float 1.000000e+00)
  %6 = bitcast i8* %W to float**
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %indvars.iv17 = phi i64 [ %indvars.iv.next18, %for.inc ], [ 0, %if.end9 ]
  %wide.trip.count19 = zext i32 %call10 to i64
  %exitcond20 = icmp eq i64 %indvars.iv17, %wide.trip.count19
  br i1 %exitcond20, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %7 = load float*, float** %6, align 8
  %arrayidx = getelementptr inbounds float, float* %7, i64 %indvars.iv17
  store float %call16, float* %arrayidx, align 4
  %indvars.iv.next18 = add nuw nsw i64 %indvars.iv17, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @275, i32 0, i32 0))
  %call20 = call i8* @strstr(i8* %param, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.328, i64 0, i64 0)) #15
  %tobool = icmp eq i8* %call20, null
  br i1 %tobool, label %if.end24, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @276, i32 0, i32 0))
  %call21 = call i8* @strstr(i8* %param, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8.329, i64 0, i64 0)) #15
  %tobool22 = icmp eq i8* %call21, null
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 53, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.10.331, i64 0, i64 0))
  br label %if.end24

if.end24:                                         ; preds = %land.lhs.true, %for.end, %if.then23
  %8 = load float*, float** %6, align 8
  call fastcc void @param_get_float_array(i8* %param, i32* nonnull %n, float* %8)
  %mul = mul i32 %call10, %call3
  %call27 = call fastcc i8** @__matrix_alloc(i32 %mul, i32 %1, i32 4)
  %alphas = getelementptr inbounds i8, i8* %call, i64 32
  %9 = bitcast i8* %alphas to i8***
  store i8** %call27, i8*** %9, align 8
  %call28 = call fastcc i8** @__matrix_alloc(i32 %call10, i32 %call3, i32 4)
  %rnd = getelementptr inbounds i8, i8* %call, i64 48
  %10 = bitcast i8* %rnd to i8***
  store i8** %call28, i8*** %10, align 8
  %conv30 = zext i32 %mul to i64
  %mul31 = shl nuw nsw i64 %conv30, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @277, i32 0, i32 0))
  %call32 = call noalias i8* @malloc(i64 %mul31) #11
  %betas = getelementptr inbounds i8, i8* %call, i64 40
  %11 = bitcast i8* %betas to i8**
  store i8* %call32, i8** %11, align 8
  %call33 = call fastcc i8** @__matrix_alloc(i32 %call10, i32 %call3, i32 4)
  %tmp = getelementptr inbounds i8, i8* %call, i64 64
  %12 = bitcast i8* %tmp to i8***
  store i8** %call33, i8*** %12, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @278, i32 0, i32 0))
  %call35 = call noalias i8* @calloc(i64 4, i64 %conv14) #11
  %tmp2 = getelementptr inbounds i8, i8* %call, i64 72
  %13 = bitcast i8* %tmp2 to i8**
  store i8* %call35, i8** %13, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @279, i32 0, i32 0))
  %call36 = call %struct.gsl_rng_type* @gsl_rng_env_setup() #11
  %14 = load %struct.gsl_rng_type*, %struct.gsl_rng_type** @gsl_rng_default, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @280, i32 0, i32 0))
  %call37 = call %struct.gsl_rng* @gsl_rng_alloc(%struct.gsl_rng_type* %14) #11
  %15 = bitcast i8* %alphas to float***
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc57, %if.end24
  %indvars.iv13 = phi i64 [ %indvars.iv.next14, %for.inc57 ], [ 0, %if.end24 ]
  %wide.trip.count15 = zext i32 %mul to i64
  %exitcond16 = icmp eq i64 %indvars.iv13, %wide.trip.count15
  br i1 %exitcond16, label %for.cond60.preheader, label %for.cond43

for.cond60.preheader:                             ; preds = %for.cond38
  %16 = bitcast i8* %betas to float**
  br label %for.cond60

for.cond43:                                       ; preds = %for.cond38, %for.inc54
  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %for.inc54 ], [ 0, %for.cond38 ]
  %wide.trip.count11 = zext i32 %1 to i64
  %exitcond12 = icmp eq i64 %indvars.iv9, %wide.trip.count11
  br i1 %exitcond12, label %for.inc57, label %for.inc54

for.inc54:                                        ; preds = %for.cond43
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @281, i32 0, i32 0))
  %call47 = call double @gsl_ran_gaussian(%struct.gsl_rng* %call37, double 1.000000e+00) #11
  %conv48 = fptrunc double %call47 to float
  %17 = load float**, float*** %15, align 8
  %arrayidx51 = getelementptr inbounds float*, float** %17, i64 %indvars.iv13
  %18 = load float*, float** %arrayidx51, align 8
  %arrayidx53 = getelementptr inbounds float, float* %18, i64 %indvars.iv9
  store float %conv48, float* %arrayidx53, align 4
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  br label %for.cond43

for.inc57:                                        ; preds = %for.cond43
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  br label %for.cond38

for.cond60:                                       ; preds = %for.cond60.preheader, %for.inc75
  %indvars.iv5 = phi i64 [ 0, %for.cond60.preheader ], [ %indvars.iv.next6, %for.inc75 ]
  %wide.trip.count7 = zext i32 %mul to i64
  %exitcond8 = icmp eq i64 %indvars.iv5, %wide.trip.count7
  br i1 %exitcond8, label %for.end77, label %for.inc75

for.inc75:                                        ; preds = %for.cond60
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @282, i32 0, i32 0))
  %call65 = call double @gsl_rng_uniform(%struct.gsl_rng* %call37) #11
  %19 = load float*, float** %6, align 8
  %20 = trunc i64 %indvars.iv5 to i32
  %div = udiv i32 %20, %call3
  %idxprom67 = zext i32 %div to i64
  %arrayidx68 = getelementptr inbounds float, float* %19, i64 %idxprom67
  %21 = load float, float* %arrayidx68, align 4
  %conv69 = fpext float %21 to double
  %mul70 = fmul double %call65, %conv69
  %conv71 = fptrunc double %mul70 to float
  %22 = load float*, float** %16, align 8
  %arrayidx74 = getelementptr inbounds float, float* %22, i64 %indvars.iv5
  store float %conv71, float* %arrayidx74, align 4
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  br label %for.cond60

for.end77:                                        ; preds = %for.cond60
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @283, i32 0, i32 0))
  call void @gsl_rng_free(%struct.gsl_rng* %call37) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @284, i32 0, i32 0))
  call void @srand(i32 0) #11
  %23 = bitcast i8* %rnd to i32***
  br label %for.cond78

for.cond78:                                       ; preds = %for.inc95, %for.end77
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc95 ], [ 0, %for.end77 ]
  %wide.trip.count3 = zext i32 %call10 to i64
  %exitcond4 = icmp eq i64 %indvars.iv1, %wide.trip.count3
  br i1 %exitcond4, label %for.end97, label %for.cond82

for.cond82:                                       ; preds = %for.cond78, %for.inc92
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc92 ], [ 0, %for.cond78 ]
  %wide.trip.count = zext i32 %call3 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc95, label %for.inc92

for.inc92:                                        ; preds = %for.cond82
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @285, i32 0, i32 0))
  %call86 = call i32 @rand() #11
  %24 = load i32**, i32*** %23, align 8
  %arrayidx89 = getelementptr inbounds i32*, i32** %24, i64 %indvars.iv1
  %25 = load i32*, i32** %arrayidx89, align 8
  %arrayidx91 = getelementptr inbounds i32, i32* %25, i64 %indvars.iv
  store i32 %call86, i32* %arrayidx91, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond82

for.inc95:                                        ; preds = %for.cond82
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond78

for.end97:                                        ; preds = %for.cond78
  %est = getelementptr inbounds i8, i8* %call, i64 80
  %26 = bitcast i8* %est to %struct.LSH_est_t**
  store %struct.LSH_est_t* null, %struct.LSH_est_t** %26, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @286, i32 0, i32 0))
  %call98 = call i8* @strstr(i8* %param, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8.329, i64 0, i64 0)) #15
  %tobool99 = icmp eq i8* %call98, null
  br i1 %tobool99, label %if.end114, label %if.then100

if.then100:                                       ; preds = %for.end97
  %call105 = call fastcc i32 @param_get_int(i8* %param, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.11.332, i64 0, i64 0), i32 100)
  %call106 = call fastcc i32 @param_get_int(i8* %param, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.333, i64 0, i64 0), i32 100)
  %call107 = call fastcc float @param_get_float(i8* %param, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.334, i64 0, i64 0), float 0.000000e+00)
  %call108 = call fastcc float @param_get_float(i8* %param, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.335, i64 0, i64 0), float 1.000000e+02)
  %recall = getelementptr inbounds i8, i8* %call, i64 88
  %27 = bitcast i8* %recall to %struct.LSH_recall_t*
  %28 = load i32, i32* %2, align 4
  %29 = load i32, i32* %3, align 8
  %30 = load float*, float** %6, align 8
  %31 = load float, float* %30, align 4
  call fastcc void @LSH_recall_init(%struct.LSH_recall_t* %27, i32 %call105, float %call107, float %call108, i32 %28, i32 %29, i32 %call106, float %31)
  br label %if.end114

if.end114:                                        ; preds = %for.end97, %if.then100
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  store i8* %call, i8** %__private, align 8
  ret i32 0
}

declare %struct.gsl_rng_type* @gsl_rng_env_setup() local_unnamed_addr #2

declare %struct.gsl_rng* @gsl_rng_alloc(%struct.gsl_rng_type*) local_unnamed_addr #2

declare double @gsl_ran_gaussian(%struct.gsl_rng*, double) local_unnamed_addr #2

declare double @gsl_rng_uniform(%struct.gsl_rng*) local_unnamed_addr #2

declare void @gsl_rng_free(%struct.gsl_rng*) local_unnamed_addr #2

; Function Attrs: nounwind
declare void @srand(i32) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_free_private(%struct._cass_table.157* nocapture %table) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @LSH_release(%struct._cass_table.157* %table)
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %rnd = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 8
  %3 = bitcast i32*** %rnd to i8***
  %4 = load i8**, i8*** %3, align 8
  call fastcc void @__matrix_free(i8** %4)
  %betas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 7
  %5 = bitcast float** %betas to i8**
  %6 = load i8*, i8** %5, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @287, i32 0, i32 0))
  call void @free(i8* %6) #11
  %alphas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 6
  %7 = bitcast float*** %alphas to i8***
  %8 = load i8**, i8*** %7, align 8
  call fastcc void @__matrix_free(i8** %8)
  %W = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 5
  %9 = bitcast float** %W to i8**
  %10 = load i8*, i8** %9, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @288, i32 0, i32 0))
  call void @free(i8* %10) #11
  %tmp = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 10
  %11 = bitcast i32*** %tmp to i8***
  %12 = load i8**, i8*** %11, align 8
  call fastcc void @__matrix_free(i8** %12)
  %tmp2 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 11
  %13 = bitcast i32** %tmp2 to i8**
  %14 = load i8*, i8** %13, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @289, i32 0, i32 0))
  call void @free(i8* %14) #11
  %table1 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 13, i32 4
  %15 = load float**, float*** %table1, align 8
  %cmp = icmp eq float** %15, null
  br i1 %cmp, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %recall3 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 13
  call fastcc void @LSH_recall_cleanup(%struct.LSH_recall_t* %recall3)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then2
  %16 = bitcast %struct.LSH_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @290, i32 0, i32 0))
  call void @free(i8* %16) #11
  store i8* null, i8** %__private, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_release(%struct._cass_table.157* nocapture %table) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %for.cond.preheader, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dirty = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 11
  %3 = load i32, i32* %dirty, align 4
  %tobool1 = icmp eq i32 %3, 0
  br i1 %tobool1, label %for.cond.preheader, label %if.end

if.end:                                           ; preds = %land.lhs.true
  %call = call fastcc i32 @LSH_dump(%struct._cass_table.157* %table)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %for.cond.preheader, label %return

for.cond.preheader:                               ; preds = %if.end, %land.lhs.true, %entry
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 2
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 9
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %i.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %4 = load i32, i32* %L, align 8
  %cmp4 = icmp ult i32 %i.0, %4
  br i1 %cmp4, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %5 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %5, i64 %idxprom
  call fastcc void @ohash_cleanup(%struct.ohash_t* %arrayidx)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.ohash_t** %hash to i8**
  %7 = load i8*, i8** %6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @291, i32 0, i32 0))
  call void @free(i8* %7) #11
  store %struct.ohash_t* null, %struct.ohash_t** %hash, align 8
  br label %return

return:                                           ; preds = %if.end, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_recall_cleanup(%struct.LSH_recall_t* nocapture readonly %recall) unnamed_addr #0 {
entry:
  %table = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 4
  %0 = bitcast float*** %table to i8***
  %1 = load i8**, i8*** %0, align 8
  call fastcc void @__matrix_free(i8** %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @LSH_dump(%struct._cass_table.157* nocapture %table) unnamed_addr #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %count = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 4
  %2 = load i32, i32* %count, align 8
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 9
  %3 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %cmp1 = icmp eq %struct.ohash_t* %3, null
  br i1 %cmp1, label %if.else, label %if.end3

if.else:                                          ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @292, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.25.336, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 398, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__PRETTY_FUNCTION__.LSH_dump, i64 0, i64 0)) #16
  unreachable

if.end3:                                          ; preds = %if.end
  %filename = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 2
  %4 = load i8*, i8** %filename, align 8
  %call = call fastcc %struct._IO_FILE* @cass_open.338(i8* %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.26.337, i64 0, i64 0))
  %cmp4 = icmp eq %struct._IO_FILE* %call, null
  br i1 %cmp4, label %if.else6, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end3
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 2
  br label %for.cond

if.else6:                                         ; preds = %if.end3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @293, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27.339, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 400, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__PRETTY_FUNCTION__.LSH_dump, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %i.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %5 = load i32, i32* %L, align 8
  %cmp8 = icmp ult i32 %i.0, %5
  br i1 %cmp8, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %6 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %6, i64 %idxprom
  call fastcc void @ohash_dump_stream(%struct.ohash_t* %arrayidx)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call fastcc void @cass_close.341(%struct._IO_FILE* nonnull %call)
  %dirty = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 11
  store i32 0, i32* %dirty, align 4
  br label %return

return:                                           ; preds = %entry, %for.end
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ohash_cleanup(%struct.ohash_t* nocapture readonly %ohash) unnamed_addr #0 {
entry:
  %size = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 0
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %0 = load i32, i32* %size, align 8
  %1 = zext i32 %0 to i64
  %cmp = icmp ult i64 %indvars.iv, %1
  br i1 %cmp, label %do.body, label %for.end

do.body:                                          ; preds = %for.cond
  %2 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %2, i64 %indvars.iv, i32 3
  %3 = load i32*, i32** %data, align 8
  %cmp1 = icmp eq i32* %3, null
  br i1 %cmp1, label %for.inc, label %if.then

if.then:                                          ; preds = %do.body
  %4 = bitcast i32* %3 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @294, i32 0, i32 0))
  call void @free(i8* %4) #11
  %.pre = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.body, %if.then
  %5 = phi %struct.anon.5* [ %2, %do.body ], [ %.pre, %if.then ]
  %data9 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %5, i64 %indvars.iv, i32 3
  store i32* null, i32** %data9, align 8
  %6 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %len = getelementptr inbounds %struct.anon.5, %struct.anon.5* %6, i64 %indvars.iv, i32 2
  store i32 0, i32* %len, align 8
  %7 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %size16 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %7, i64 %indvars.iv, i32 1
  store i32 0, i32* %size16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = bitcast %struct.anon.5** %bucket to i8**
  %9 = load i8*, i8** %8, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @295, i32 0, i32 0))
  call void @free(i8* %9) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct._IO_FILE* @cass_open.338(i8* nocapture readonly %p, i8* nocapture readonly %m) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @296, i32 0, i32 0))
  %call = call %struct._IO_FILE* @fopen(i8* %p, i8* %m)
  ret %struct._IO_FILE* %call
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @cass_close.341(%struct._IO_FILE* nocapture %h) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @297, i32 0, i32 0))
  %call = call i32 @fclose(%struct._IO_FILE* %h)
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @LSH_hash2(%struct.LSH_t* nocapture readonly %lsh, i32** nocapture readonly %hash, i32* nocapture %hash2) unnamed_addr #8 {
entry:
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 2
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %rnd = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 8
  %H = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc16 ], [ 0, %entry ]
  %0 = load i32, i32* %L, align 8
  %1 = zext i32 %0 to i64
  %cmp = icmp ult i64 %indvars.iv1, %1
  br i1 %cmp, label %for.body, label %for.end18

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %hash2, i64 %indvars.iv1
  store i32 0, i32* %arrayidx, align 4
  %arrayidx9 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv1
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ]
  %2 = phi i32 [ %add, %for.inc ], [ 0, %for.body ]
  %3 = load i32, i32* %M, align 4
  %4 = zext i32 %3 to i64
  %cmp2 = icmp ult i64 %indvars.iv, %4
  br i1 %cmp2, label %for.inc, label %for.inc16

for.inc:                                          ; preds = %for.cond1
  %5 = load i32**, i32*** %rnd, align 8
  %arrayidx5 = getelementptr inbounds i32*, i32** %5, i64 %indvars.iv1
  %6 = load i32*, i32** %arrayidx5, align 8
  %arrayidx7 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv
  %7 = load i32, i32* %arrayidx7, align 4
  %8 = load i32*, i32** %arrayidx9, align 8
  %arrayidx11 = getelementptr inbounds i32, i32* %8, i64 %indvars.iv
  %9 = load i32, i32* %arrayidx11, align 4
  %mul = mul i32 %7, %9
  %add = add i32 %2, %mul
  store i32 %add, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond1

for.inc16:                                        ; preds = %for.cond1
  %10 = load i32, i32* %H, align 4
  %rem = urem i32 %2, %10
  store i32 %rem, i32* %arrayidx, align 4
  %indvars.iv.next2 = add nuw i64 %indvars.iv1, 1
  br label %for.cond

for.end18:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_hash(%struct.LSH_t* nocapture readonly %lsh, float* nocapture readonly %pnt, i32** nocapture readonly %hash) unnamed_addr #0 {
entry:
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 2
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %betas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 7
  %D = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 0
  %alphas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 6
  %W = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 5
  br label %for.cond

for.cond:                                         ; preds = %for.inc24, %entry
  %indvars.iv5 = phi i64 [ %indvars.iv.next6, %for.inc24 ], [ 0, %entry ]
  %l.0 = phi i64 [ %indvars.iv3, %for.inc24 ], [ 0, %entry ]
  %0 = load i32, i32* %L, align 8
  %1 = zext i32 %0 to i64
  %cmp = icmp ult i64 %indvars.iv5, %1
  br i1 %cmp, label %for.cond1.preheader, label %for.end26

for.cond1.preheader:                              ; preds = %for.cond
  %arrayidx17 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv5
  %sext = shl i64 %l.0, 32
  %2 = ashr exact i64 %sext, 32
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc21
  %indvars.iv3 = phi i64 [ %2, %for.cond1.preheader ], [ %indvars.iv.next4, %for.inc21 ]
  %indvars.iv1 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next2, %for.inc21 ]
  %3 = load i32, i32* %M, align 4
  %4 = zext i32 %3 to i64
  %cmp2 = icmp ult i64 %indvars.iv1, %4
  br i1 %cmp2, label %for.body3, label %for.inc24

for.body3:                                        ; preds = %for.cond1
  %5 = load float*, float** %betas, align 8
  %arrayidx = getelementptr inbounds float, float* %5, i64 %indvars.iv3
  %6 = load float, float* %arrayidx, align 4
  %7 = load i32, i32* %D, align 8
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body3
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body3 ]
  %s.0 = phi float [ %add, %for.inc ], [ %6, %for.body3 ]
  %wide.trip.count = zext i32 %7 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc21, label %for.inc

for.inc:                                          ; preds = %for.cond4
  %arrayidx8 = getelementptr inbounds float, float* %pnt, i64 %indvars.iv
  %8 = load float, float* %arrayidx8, align 4
  %9 = load float**, float*** %alphas, align 8
  %arrayidx10 = getelementptr inbounds float*, float** %9, i64 %indvars.iv3
  %10 = load float*, float** %arrayidx10, align 8
  %arrayidx12 = getelementptr inbounds float, float* %10, i64 %indvars.iv
  %11 = load float, float* %arrayidx12, align 4
  %mul = fmul float %8, %11
  %add = fadd float %s.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond4

for.inc21:                                        ; preds = %for.cond4
  %12 = load float*, float** %W, align 8
  %arrayidx14 = getelementptr inbounds float, float* %12, i64 %indvars.iv5
  %13 = load float, float* %arrayidx14, align 4
  %div = fdiv float %s.0, %13
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @298, i32 0, i32 0))
  %floorf = call float @floorf(float %div) #13
  %conv15 = fptoui float %floorf to i32
  %14 = load i32*, i32** %arrayidx17, align 8
  %arrayidx19 = getelementptr inbounds i32, i32* %14, i64 %indvars.iv1
  store i32 %conv15, i32* %arrayidx19, align 4
  %indvars.iv.next4 = add i64 %indvars.iv3, 1
  %indvars.iv.next2 = add nuw i64 %indvars.iv1, 1
  br label %for.cond1

for.inc24:                                        ; preds = %for.cond1
  %indvars.iv.next6 = add nuw i64 %indvars.iv5, 1
  br label %for.cond

for.end26:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_batch_insert(%struct._cass_table.157* nocapture readonly %table, %struct.cass_dataset_t* nocapture readonly %parent, i32 %start, i32 %end) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %parent, i64 0, i32 9
  %vec7 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %parent, i64 0, i32 6
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %parent, i64 0, i32 2
  %count = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %i.0 = phi i32 [ %start, %entry ], [ %inc10, %for.inc9 ]
  %cmp = icmp ugt i32 %i.0, %end
  br i1 %cmp, label %for.end11, label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc
  %j.0 = phi i32 [ %inc8, %for.inc ], [ 0, %for.cond1.preheader ]
  %2 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 0
  %3 = load i32, i32* %num_regions, align 4
  %cmp2 = icmp ult i32 %j.0, %3
  br i1 %cmp2, label %for.inc, label %for.inc9

for.inc:                                          ; preds = %for.cond1
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 1
  %4 = load i32, i32* %start_vecid, align 4
  %add = add i32 %j.0, %4
  %5 = load i8*, i8** %vec7, align 8
  %6 = load i32, i32* %vec_size, align 8
  %mul = mul i32 %add, %6
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %idx.ext
  %u = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %arraydecay = bitcast i8* %u to float*
  call fastcc void @LSH_insert(%struct.LSH_t* %1, float* %arraydecay, i32 %add)
  %7 = load i32, i32* %count, align 8
  %inc = add i32 %7, 1
  store i32 %inc, i32* %count, align 8
  %inc8 = add i32 %j.0, 1
  br label %for.cond1

for.inc9:                                         ; preds = %for.cond1
  %inc10 = add i32 %i.0, 1
  br label %for.cond

for.end11:                                        ; preds = %for.cond
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_insert(%struct.LSH_t* nocapture %lsh, float* nocapture readonly %pnt, i32 %tag) unnamed_addr #0 {
entry:
  %tmp = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 10
  %0 = load i32**, i32*** %tmp, align 8
  call fastcc void @LSH_hash(%struct.LSH_t* %lsh, float* %pnt, i32** %0)
  %1 = load i32**, i32*** %tmp, align 8
  %tmp2 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 11
  %2 = load i32*, i32** %tmp2, align 8
  call fastcc void @LSH_hash2(%struct.LSH_t* %lsh, i32** %1, i32* %2)
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 2
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 9
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %3 = load i32, i32* %L, align 8
  %4 = zext i32 %3 to i64
  %cmp = icmp ult i64 %indvars.iv, %4
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %5 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %arrayidx = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %5, i64 %indvars.iv
  %6 = load i32*, i32** %tmp2, align 8
  %arrayidx4 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv
  %7 = load i32, i32* %arrayidx4, align 4
  call fastcc void @ohash_insert(%struct.ohash_t* %arrayidx, i32 %7, i32 %tag)
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %count = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 4
  %8 = load i32, i32* %count, align 8
  %inc5 = add i32 %8, 1
  store i32 %inc5, i32* %count, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ohash_insert(%struct.ohash_t* readonly %ohash, i32 %hash, i32 %val) unnamed_addr #0 {
do.end:
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 1
  %0 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %size = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 0
  %1 = load i32, i32* %size, align 8
  %rem = urem i32 %hash, %1
  %idxprom = zext i32 %rem to i64
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %0, i64 %idxprom, i32 3
  %2 = load i32*, i32** %data, align 8
  %len6 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %0, i64 %idxprom, i32 2
  %3 = load i32, i32* %len6, align 8
  %conv = zext i32 %3 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %i.0 = phi i64 [ 0, %do.end ], [ %inc, %for.inc ]
  %cmp = icmp ult i64 %i.0, %conv
  br i1 %cmp, label %for.body, label %do.body30

for.body:                                         ; preds = %for.cond
  %arrayidx8 = getelementptr inbounds i32, i32* %2, i64 %i.0
  %4 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp eq i32 %4, %val
  br i1 %cmp9, label %do.body150, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i64 %i.0, 1
  br label %for.cond

do.body30:                                        ; preds = %for.cond
  %inc14 = add nuw nsw i64 %conv, 1
  %inc29 = add i32 %3, 1
  store i32 %inc29, i32* %len6, align 8
  %5 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %6 = load i32, i32* %size, align 8
  %rem33 = urem i32 %hash, %6
  %idxprom34 = zext i32 %rem33 to i64
  %size36 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %5, i64 %idxprom34, i32 1
  %7 = load i32, i32* %size36, align 4
  %len42 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %5, i64 %idxprom34, i32 2
  %8 = load i32, i32* %len42, align 8
  %cmp43 = icmp ult i32 %7, %8
  br i1 %cmp43, label %if.end46, label %do.end148

if.end46:                                         ; preds = %do.body30
  store i32 %8, i32* %size36, align 4
  %9 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %10 = load i32, i32* %size, align 8
  %rem61 = urem i32 %hash, %10
  %idxprom62 = zext i32 %rem61 to i64
  %inc64 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %9, i64 %idxprom62, i32 0
  %11 = load i32, i32* %inc64, align 8
  %sub = add i32 %11, -1
  %size70 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %9, i64 %idxprom62, i32 1
  %12 = load i32, i32* %size70, align 4
  %add = add i32 %12, %sub
  store i32 %add, i32* %size70, align 4
  %13 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %14 = load i32, i32* %size, align 8
  %rem73 = urem i32 %hash, %14
  %idxprom74 = zext i32 %rem73 to i64
  %inc76 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %13, i64 %idxprom74, i32 0
  %15 = load i32, i32* %inc76, align 8
  %neg = sub i32 0, %15
  %size83 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %13, i64 %idxprom74, i32 1
  %16 = load i32, i32* %size83, align 4
  %and = and i32 %16, %neg
  store i32 %and, i32* %size83, align 4
  %17 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %18 = load i32, i32* %size, align 8
  %rem86 = urem i32 %hash, %18
  %idxprom87 = zext i32 %rem86 to i64
  %data89 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %17, i64 %idxprom87, i32 3
  %19 = load i32*, i32** %data89, align 8
  %cmp90 = icmp eq i32* %19, null
  br i1 %cmp90, label %if.else, label %if.then92

if.then92:                                        ; preds = %if.end46
  %20 = bitcast i32* %19 to i8*
  %size104 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %17, i64 %idxprom87, i32 1
  %21 = load i32, i32* %size104, align 4
  %conv105 = zext i32 %21 to i64
  %mul = shl nuw nsw i64 %conv105, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @299, i32 0, i32 0))
  %call = call i8* @realloc(i8* %20, i64 %mul) #11
  %22 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %23 = load i32, i32* %size, align 8
  %rem108 = urem i32 %hash, %23
  %idxprom109 = zext i32 %rem108 to i64
  %data111 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %22, i64 %idxprom109, i32 3
  br label %if.end127

if.else:                                          ; preds = %if.end46
  %size117 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %17, i64 %idxprom87, i32 1
  %24 = load i32, i32* %size117, align 4
  %conv118 = zext i32 %24 to i64
  %mul119 = shl nuw nsw i64 %conv118, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @300, i32 0, i32 0))
  %call120 = call noalias i8* @malloc(i64 %mul119) #11
  br label %if.end127

if.end127:                                        ; preds = %if.else, %if.then92
  %data89.sink = phi i32** [ %data89, %if.else ], [ %data111, %if.then92 ]
  %call120.sink = phi i8* [ %call120, %if.else ], [ %call, %if.then92 ]
  %25 = bitcast i32** %data89.sink to i8**
  store i8* %call120.sink, i8** %25, align 8
  %26 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %27 = load i32, i32* %size, align 8
  %rem130 = urem i32 %hash, %27
  %idxprom131 = zext i32 %rem130 to i64
  %data133 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %26, i64 %idxprom131, i32 3
  %28 = load i32*, i32** %data133, align 8
  %cmp134 = icmp eq i32* %28, null
  br i1 %cmp134, label %if.else137, label %do.end148

if.else137:                                       ; preds = %if.end127
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @301, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.52, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.53, i64 0, i64 0), i32 53, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__PRETTY_FUNCTION__.ohash_insert, i64 0, i64 0)) #16
  unreachable

do.end148:                                        ; preds = %do.body30, %if.end127
  %29 = phi i32 [ %6, %do.body30 ], [ %27, %if.end127 ]
  %30 = phi %struct.anon.5* [ %5, %do.body30 ], [ %26, %if.end127 ]
  %rem142 = urem i32 %hash, %29
  %idxprom143 = zext i32 %rem142 to i64
  %data145 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %30, i64 %idxprom143, i32 3
  %31 = load i32*, i32** %data145, align 8
  %idxprom146 = sext i32 %3 to i64
  %arrayidx147 = getelementptr inbounds i32, i32* %31, i64 %idxprom146
  store i32 %val, i32* %arrayidx147, align 4
  %.pre = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %.pre1 = load i32, i32* %size, align 8
  br label %do.body150

do.body150:                                       ; preds = %for.body, %do.end148
  %32 = phi i32 [ %.pre1, %do.end148 ], [ %1, %for.body ]
  %33 = phi %struct.anon.5* [ %.pre, %do.end148 ], [ %0, %for.body ]
  %len.0 = phi i64 [ %inc14, %do.end148 ], [ %conv, %for.body ]
  %conv151 = trunc i64 %len.0 to i32
  %rem154 = urem i32 %hash, %32
  %idxprom155 = zext i32 %rem154 to i64
  %len157 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %33, i64 %idxprom155, i32 2
  store i32 %conv151, i32* %len157, align 8
  %34 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %35 = load i32, i32* %size, align 8
  %rem160 = urem i32 %hash, %35
  %idxprom161 = zext i32 %rem160 to i64
  %size163 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %34, i64 %idxprom161, i32 1
  %36 = load i32, i32* %size163, align 4
  %conv164 = zext i32 %36 to i64
  %cmp165 = icmp ugt i64 %len.0, %conv164
  br i1 %cmp165, label %if.else168, label %do.end170

if.else168:                                       ; preds = %do.body150
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @302, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.54, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.53, i64 0, i64 0), i32 55, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__PRETTY_FUNCTION__.ohash_insert, i64 0, i64 0)) #16
  unreachable

do.end170:                                        ; preds = %do.body150
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_restore_private(%struct._cass_table.157* nocapture %table, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %recall = alloca i32, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @303, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 112, i64 1) #11
  %D1 = bitcast i8* %call to i32*
  %call2 = call fastcc i32 @cass_read_uint32.342(i32* %D1, i64 1, %struct._IO_FILE* %fin)
  %M3 = getelementptr inbounds i8, i8* %call, i64 4
  %0 = bitcast i8* %M3 to i32*
  %call4 = call fastcc i32 @cass_read_uint32.342(i32* %0, i64 1, %struct._IO_FILE* %fin)
  %add = add nsw i32 %call2, %call4
  %L5 = getelementptr inbounds i8, i8* %call, i64 8
  %1 = bitcast i8* %L5 to i32*
  %call6 = call fastcc i32 @cass_read_uint32.342(i32* %1, i64 1, %struct._IO_FILE* %fin)
  %add7 = add nsw i32 %add, %call6
  %H = getelementptr inbounds i8, i8* %call, i64 12
  %2 = bitcast i8* %H to i32*
  %call8 = call fastcc i32 @cass_read_uint32.342(i32* %2, i64 1, %struct._IO_FILE* %fin)
  %add9 = add nsw i32 %add7, %call8
  %count = getelementptr inbounds i8, i8* %call, i64 16
  %3 = bitcast i8* %count to i32*
  %call10 = call fastcc i32 @cass_read_uint32.342(i32* %3, i64 1, %struct._IO_FILE* %fin)
  %add11 = add nsw i32 %add9, %call10
  %cmp = icmp eq i32 %add11, 5
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @304, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.15.343, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 261, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %1, align 8
  %conv = zext i32 %4 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @305, i32 0, i32 0))
  %call13 = call noalias i8* @calloc(i64 4, i64 %conv) #11
  %W = getelementptr inbounds i8, i8* %call, i64 24
  %5 = bitcast i8* %W to i8**
  store i8* %call13, i8** %5, align 8
  %.cast = bitcast i8* %call13 to float*
  %call17 = call fastcc i32 @cass_read_float.344(float* %.cast, i64 %conv, %struct._IO_FILE* %fin)
  %cmp19 = icmp eq i32 %call17, %4
  br i1 %cmp19, label %if.end23, label %if.else22

if.else22:                                        ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @306, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.16.345, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 265, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end23:                                         ; preds = %if.end
  %6 = load i32, i32* %0, align 4
  %7 = load i32, i32* %D1, align 8
  %mul = mul i32 %4, %6
  %call27 = call fastcc i8** @__matrix_alloc(i32 %mul, i32 %7, i32 4)
  %alphas = getelementptr inbounds i8, i8* %call, i64 32
  %8 = bitcast i8* %alphas to i8***
  store i8** %call27, i8*** %8, align 8
  %conv29 = zext i32 %mul to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @307, i32 0, i32 0))
  %call30 = call noalias i8* @calloc(i64 4, i64 %conv29) #11
  %betas = getelementptr inbounds i8, i8* %call, i64 40
  %9 = bitcast i8* %betas to i8**
  store i8* %call30, i8** %9, align 8
  %hash = getelementptr inbounds i8, i8* %call, i64 56
  %10 = bitcast i8* %hash to %struct.ohash_t**
  store %struct.ohash_t* null, %struct.ohash_t** %10, align 8
  %call31 = call fastcc i8** @__matrix_alloc(i32 %4, i32 %6, i32 4)
  %tmp = getelementptr inbounds i8, i8* %call, i64 64
  %11 = bitcast i8* %tmp to i8***
  store i8** %call31, i8*** %11, align 8
  %mul33 = shl nuw nsw i64 %conv, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @308, i32 0, i32 0))
  %call34 = call noalias i8* @malloc(i64 %mul33) #11
  %tmp2 = getelementptr inbounds i8, i8* %call, i64 72
  %12 = bitcast i8* %tmp2 to i8**
  store i8* %call34, i8** %12, align 8
  %13 = bitcast i8** %call27 to float**
  %14 = load float*, float** %13, align 8
  %mul37 = mul i32 %mul, %7
  %conv38 = zext i32 %mul37 to i64
  %call39 = call fastcc i32 @cass_read_float.344(float* %14, i64 %conv38, %struct._IO_FILE* %fin)
  %cmp42 = icmp eq i32 %call39, %mul37
  br i1 %cmp42, label %if.end46, label %if.else45

if.else45:                                        ; preds = %if.end23
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @309, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.17.346, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 279, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end46:                                         ; preds = %if.end23
  %15 = bitcast i8* %betas to float**
  %16 = load float*, float** %15, align 8
  %call50 = call fastcc i32 @cass_read_float.344(float* %16, i64 %conv29, %struct._IO_FILE* %fin)
  %cmp52 = icmp eq i32 %call50, %mul
  br i1 %cmp52, label %if.end56, label %if.else55

if.else55:                                        ; preds = %if.end46
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @310, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.18.347, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 281, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end56:                                         ; preds = %if.end46
  %call57 = call fastcc i8** @__matrix_alloc(i32 %4, i32 %6, i32 4)
  %rnd = getelementptr inbounds i8, i8* %call, i64 48
  %17 = bitcast i8* %rnd to i8***
  store i8** %call57, i8*** %17, align 8
  %.cast1 = bitcast i8** %call57 to i32**
  %18 = load i32*, i32** %.cast1, align 8
  %call62 = call fastcc i32 @cass_read_uint32.342(i32* %18, i64 %conv29, %struct._IO_FILE* %fin)
  %cmp64 = icmp eq i32 %call62, %mul
  br i1 %cmp64, label %if.end68, label %if.else67

if.else67:                                        ; preds = %if.end56
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @311, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.18.347, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 286, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end68:                                         ; preds = %if.end56
  %call69 = call fastcc i32 @cass_read_int32.348(i32* nonnull %recall, %struct._IO_FILE* %fin)
  %cmp70 = icmp eq i32 %call69, 1
  br i1 %cmp70, label %if.end74, label %if.else73

if.else73:                                        ; preds = %if.end68
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @312, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1.461, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end74:                                         ; preds = %if.end68
  %19 = load i32, i32* %recall, align 4
  %tobool = icmp eq i32 %19, 0
  br i1 %tobool, label %if.end82, label %if.then75

if.then75:                                        ; preds = %if.end74
  %recall76 = getelementptr inbounds i8, i8* %call, i64 88
  %20 = bitcast i8* %recall76 to %struct.LSH_recall_t*
  %call77 = call fastcc i32 @LSH_recall_load(%struct.LSH_recall_t* %20, %struct._IO_FILE* %fin)
  %cmp78 = icmp eq i32 %call77, 0
  br i1 %cmp78, label %if.end82, label %if.then80

if.then80:                                        ; preds = %if.then75
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @313, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 293, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__PRETTY_FUNCTION__.LSH_restore_private, i64 0, i64 0)) #16
  unreachable

if.end82:                                         ; preds = %if.then75, %if.end74
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  store i8* %call, i8** %__private, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.342(i32* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @314, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.351()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_float.344(float* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast float* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @315, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.351()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %buf, i64 %indvars.iv
  %2 = bitcast float* %arrayidx to i32*
  %3 = load i32, i32* %2, align 4
  %or13 = call i32 @llvm.bswap.i32(i32 %3)
  store i32 %or13, i32* %2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_int32.348(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @316, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.351()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.351() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_checkpoint_private(%struct._cass_table.157* nocapture readnone %table, %struct._IO_FILE* nocapture readnone %fout) #0 {
entry:
  call fastcc void @cass_write_uint32.352()
  unreachable
}

; Function Attrs: noinline noreturn nounwind uwtable
define internal fastcc void @cass_write_uint32.352() unnamed_addr #10 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @317, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 88, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__PRETTY_FUNCTION__.cass_write_uint32.516, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @LSH_load(%struct._cass_table.157* nocapture readonly %table) #0 {
entry:
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 9
  %2 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %cmp = icmp eq %struct.ohash_t* %2, null
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @318, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.22.357, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 349, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__PRETTY_FUNCTION__.LSH_load, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %count = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 4
  %3 = load i32, i32* %count, align 8
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %L = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 2
  %4 = load i32, i32* %L, align 8
  %conv = zext i32 %4 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @319, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 16, i64 %conv) #11
  %5 = bitcast %struct.ohash_t** %hash to i8**
  store i8* %call, i8** %5, align 8
  %H = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then2
  %i.0 = phi i32 [ 0, %if.then2 ], [ %inc, %for.inc ]
  %6 = load i32, i32* %L, align 8
  %cmp5 = icmp ult i32 %i.0, %6
  br i1 %cmp5, label %for.inc, label %return

for.inc:                                          ; preds = %for.cond
  %7 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %7, i64 %idxprom
  %8 = load i32, i32* %H, align 4
  call fastcc void @ohash_init(%struct.ohash_t* %arrayidx, i32 %8)
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end8:                                          ; preds = %if.end
  %filename = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 2
  %9 = load i8*, i8** %filename, align 8
  %call9 = call fastcc %struct._IO_FILE* @cass_open.338(i8* %9, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23.358, i64 0, i64 0))
  %cmp10 = icmp eq %struct._IO_FILE* %call9, null
  br i1 %cmp10, label %return, label %if.end13

if.end13:                                         ; preds = %if.end8
  %L14 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %1, i64 0, i32 2
  %10 = load i32, i32* %L14, align 8
  %conv15 = zext i32 %10 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @320, i32 0, i32 0))
  %call16 = call noalias i8* @calloc(i64 16, i64 %conv15) #11
  %11 = bitcast %struct.ohash_t** %hash to i8**
  store i8* %call16, i8** %11, align 8
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc32, %if.end13
  %i.1 = phi i32 [ 0, %if.end13 ], [ %inc33, %for.inc32 ]
  %12 = load i32, i32* %L14, align 8
  %cmp20 = icmp ult i32 %i.1, %12
  br i1 %cmp20, label %for.inc32, label %for.end34

for.inc32:                                        ; preds = %for.cond18
  %13 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %idxprom24 = zext i32 %i.1 to i64
  %arrayidx25 = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %13, i64 %idxprom24
  call fastcc void @ohash_init_with_stream(%struct.ohash_t* %arrayidx25, %struct._IO_FILE* nonnull %call9)
  %inc33 = add i32 %i.1, 1
  br label %for.cond18

for.end34:                                        ; preds = %for.cond18
  call fastcc void @cass_close.341(%struct._IO_FILE* nonnull %call9)
  br label %return

return:                                           ; preds = %for.cond, %if.end8, %for.end34
  %retval.0 = phi i32 [ 0, %for.end34 ], [ -9995, %if.end8 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ohash_init(%struct.ohash_t* nocapture %ohash, i32 %size) unnamed_addr #0 {
entry:
  %size1 = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 0
  store i32 %size, i32* %size1, align 8
  %conv = zext i32 %size to i64
  %mul = mul nuw nsw i64 %conv, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @321, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 1
  %0 = bitcast %struct.anon.5** %bucket to i8**
  store i8* %call, i8** %0, align 8
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else, label %for.cond

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @322, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.56, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.53, i64 0, i64 0), i32 21, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__PRETTY_FUNCTION__.ohash_init, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %wide.trip.count = zext i32 %size to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %1 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %inc = getelementptr inbounds %struct.anon.5, %struct.anon.5* %1, i64 %indvars.iv, i32 0
  store i32 256, i32* %inc, align 8
  %2 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %size10 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %2, i64 %indvars.iv, i32 1
  store i32 0, i32* %size10, align 4
  %3 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %len = getelementptr inbounds %struct.anon.5, %struct.anon.5* %3, i64 %indvars.iv, i32 2
  store i32 0, i32* %len, align 8
  %4 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %4, i64 %indvars.iv, i32 3
  store i32* null, i32** %data, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc double @LSH_est(%struct.LSH_est_t* nocapture readonly %est, double %a, double %b, i32 %K) unnamed_addr #0 {
entry:
  %0 = call double @llvm.fabs.f64(double %a) #17
  %cmpinf = fcmp ueq double %0, 0x7FF0000000000000
  %1 = call double @llvm.fabs.f64(double %b) #17
  %cmpinf1 = fcmp ueq double %1, 0x7FF0000000000000
  %or.cond = or i1 %cmpinf, %cmpinf1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %a_min = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 2
  %2 = load double, double* %a_min, align 8
  %a_delta = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 6
  %b_min = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 4
  %3 = load double, double* %b_min, align 8
  %4 = insertelement <2 x double> undef, double %a, i32 0
  %5 = insertelement <2 x double> %4, double %b, i32 1
  %6 = insertelement <2 x double> undef, double %2, i32 0
  %7 = insertelement <2 x double> %6, double %3, i32 1
  %8 = fsub <2 x double> %5, %7
  %9 = bitcast double* %a_delta to <2 x double>*
  %10 = load <2 x double>, <2 x double>* %9, align 8
  %11 = fdiv <2 x double> %8, %10
  %12 = fptosi <2 x double> %11 to <2 x i32>
  %13 = extractelement <2 x i32> %12, i32 0
  %14 = extractelement <2 x i32> %12, i32 1
  %15 = or i32 %13, %14
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %return, label %if.end11

if.end11:                                         ; preds = %if.end
  %a_step = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 0
  %17 = load i32, i32* %a_step, align 8
  %cmp12 = icmp slt i32 %13, %17
  %sub16 = add nsw i32 %17, -1
  %conv.sub16 = select i1 %cmp12, i32 %13, i32 %sub16
  %cmp19 = icmp slt i32 %14, %17
  %B.0 = select i1 %cmp19, i32 %14, i32 %sub16
  %a_table = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 8
  %18 = load double**, double*** %a_table, align 8
  %idxprom = sext i32 %conv.sub16 to i64
  %arrayidx = getelementptr inbounds double*, double** %18, i64 %idxprom
  %19 = load double*, double** %arrayidx, align 8
  %idxprom25 = sext i32 %B.0 to i64
  %arrayidx26 = getelementptr inbounds double, double* %19, i64 %idxprom25
  %20 = load double, double* %arrayidx26, align 8
  %b_table = getelementptr inbounds %struct.LSH_est_t, %struct.LSH_est_t* %est, i64 0, i32 9
  %21 = load double**, double*** %b_table, align 8
  %arrayidx28 = getelementptr inbounds double*, double** %21, i64 %idxprom
  %22 = load double*, double** %arrayidx28, align 8
  %arrayidx30 = getelementptr inbounds double, double* %22, i64 %idxprom25
  %23 = load double, double* %arrayidx30, align 8
  %conv31 = sitofp i32 %K to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @323, i32 0, i32 0))
  %call = call double @pow(double %conv31, double %23) #11
  %mul = fmul double %20, %call
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end11
  %retval.0 = phi double [ %mul, %if.end11 ], [ 0.000000e+00, %entry ], [ 0.000000e+00, %if.end ]
  ret double %retval.0
}

; Function Attrs: nounwind readnone
declare double @llvm.fabs.f64(double) #12

; Function Attrs: nounwind
declare double @pow(double, double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @__LSH_query(%struct._cass_table.157* nocapture readonly %table, %struct.cass_query_t* readonly %query, %struct.cass_result_t* %result) #0 {
entry:
  %query2 = alloca %struct.LSH_query_t, align 8
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %loaded = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 10
  %2 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @324, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 526, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %env = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 3
  %3 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %vec_dist1 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %3, i64 0, i32 6
  %vec_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 7
  %4 = load i32, i32* %vec_dist_id, align 8
  %call = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %vec_dist1, i32 %4)
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else3, label %if.end4

if.else3:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @325, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.30, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 528, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end4:                                          ; preds = %if.end
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %5 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  %6 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %5, align 8
  %cmp5 = icmp eq %struct._cass_vec_dist_class* %6, @vec_dist_L2_float
  br i1 %cmp5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 529, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.31, i64 0, i64 0))
  br label %if.end7

if.end7:                                          ; preds = %if.end4, %if.then6
  %parent_id = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 4
  %7 = load i32, i32* %parent_id, align 8
  %cmp8 = icmp eq i32 %7, -1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 531, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.32, i64 0, i64 0))
  %.pre = load i32, i32* %parent_id, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %8 = phi i32 [ %.pre, %if.then9 ], [ %7, %if.end7 ]
  %9 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %table12 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %9, i64 0, i32 2
  %call14 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %table12, i32 %8)
  %cmp15 = icmp eq i8* %call14, null
  br i1 %cmp15, label %if.else17, label %if.end18

if.else17:                                        ; preds = %if.end10
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @326, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.33, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 533, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end18:                                         ; preds = %if.end10
  %loaded19 = getelementptr inbounds i8, i8* %call14, i64 80
  %10 = bitcast i8* %loaded19 to i32*
  %11 = load i32, i32* %10, align 8
  %tobool20 = icmp eq i32 %11, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 534, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.34, i64 0, i64 0))
  br label %if.end22

if.end22:                                         ; preds = %if.end18, %if.then21
  %opr = getelementptr inbounds i8, i8* %call14, i64 72
  %12 = bitcast i8* %opr to %struct._cass_table_opr.152**
  %13 = load %struct._cass_table_opr.152*, %struct._cass_table_opr.152** %12, align 8
  %type = getelementptr inbounds %struct._cass_table_opr.152, %struct._cass_table_opr.152* %13, i64 0, i32 1
  %14 = load i32, i32* %type, align 8
  %and = and i32 %14, 1
  %tobool23 = icmp eq i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end22
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 535, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.35, i64 0, i64 0))
  br label %if.end25

if.end25:                                         ; preds = %if.end22, %if.then24
  %__private26 = getelementptr inbounds i8, i8* %call14, i64 88
  %15 = bitcast i8* %__private26 to %struct.cass_dataset_t**
  %16 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %15, align 8
  %topk = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 3
  %17 = load i32, i32* %topk, align 4
  %cmp27 = icmp eq i32 %17, 0
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 540, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.36.360, i64 0, i64 0))
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  %extra_params = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 5
  %18 = load i8*, i8** %extra_params, align 8
  %call30 = call fastcc i32 @param_get_int(i8* %18, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4.325, i64 0, i64 0), i32 1)
  %19 = load i8*, i8** %extra_params, align 8
  %call32 = call fastcc i32 @param_get_int(i8* %19, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.37, i64 0, i64 0), i32 0)
  %20 = load i8*, i8** %extra_params, align 8
  %call34 = call fastcc float @param_get_float(i8* %20, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8.329, i64 0, i64 0), float 0.000000e+00)
  call fastcc void @LSH_query_init(%struct.LSH_query_t* nonnull %query2, %struct.LSH_t* %1, %struct.cass_dataset_t* %16, i32 %17, i32 %call30, i32 %call32)
  %flags = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 0
  %21 = load i32, i32* %flags, align 8
  %and35 = and i32 %21, 4
  %cmp36 = icmp eq i32 %and35, 0
  br i1 %cmp36, label %if.end39, label %if.else38

if.else38:                                        ; preds = %if.end29
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @327, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.38, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 550, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end39:                                         ; preds = %if.end29
  %and41 = and i32 %21, 1
  %cmp42 = icmp eq i32 %and41, 0
  br i1 %cmp42, label %if.end45, label %if.else44

if.else44:                                        ; preds = %if.end39
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @328, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.39, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 551, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end45:                                         ; preds = %if.end39
  %and47 = and i32 %21, 2
  %cmp48 = icmp eq i32 %and47, 0
  br i1 %cmp48, label %if.end51, label %if.else50

if.else50:                                        ; preds = %if.end45
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @329, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.40, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 552, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end51:                                         ; preds = %if.end45
  %and53 = and i32 %21, 8
  %tobool54 = icmp eq i32 %and53, 0
  br i1 %tobool54, label %if.else56, label %if.end57

if.else56:                                        ; preds = %if.end51
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @330, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.41, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 553, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end57:                                         ; preds = %if.end51
  %candidate = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 6
  %22 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate, align 8
  %cmp58 = icmp eq %struct.cass_result_t* %22, null
  br i1 %cmp58, label %if.end61, label %if.else60

if.else60:                                        ; preds = %if.end57
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @331, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.42, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 554, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end61:                                         ; preds = %if.end57
  %flags62 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 0
  store i32 8, i32* %flags62, align 8
  %dataset = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 1
  %23 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset, align 8
  %vecset63 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %23, i64 0, i32 9
  %24 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset63, align 8
  %vecset_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query, i64 0, i32 2
  %25 = load i32, i32* %vecset_id, align 8
  %idx.ext = zext i32 %25 to i64
  %add.ptr = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %24, i64 %idx.ext
  %26 = load i32, i32* %flags, align 8
  %and65 = and i32 %26, 1024
  %tobool66 = icmp eq i32 %and65, 0
  br i1 %tobool66, label %do.body, label %if.then67

if.then67:                                        ; preds = %if.end61
  %27 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  %28 = load i32, i32* %27, align 8
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %add.ptr, i64 0, i32 0
  %29 = load i32, i32* %num_regions, align 4
  %cmp68 = icmp ult i32 %28, %29
  br i1 %cmp68, label %if.else70, label %if.then67.for.cond.preheader_crit_edge

if.then67.for.cond.preheader_crit_edge:           ; preds = %if.then67
  %.pre18 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %.pre19 = bitcast %struct.cass_list_entry_t** %.pre18 to %struct.cass_list_t**
  br label %for.cond.preheader

if.else70:                                        ; preds = %if.then67
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @332, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.43, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 562, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

do.body:                                          ; preds = %if.end61
  store i32 264, i32* %flags62, align 8
  %inc = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 0
  store i32 256, i32* %inc, align 8
  %num_regions76 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %add.ptr, i64 0, i32 0
  %30 = load i32, i32* %num_regions76, align 4
  %31 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 1
  store i32 %30, i32* %31, align 4
  %32 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %32, align 8
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %result, i64 0, i32 1, i32 0, i32 3
  %33 = bitcast %struct.cass_list_entry_t** %data to %struct.cass_list_t**
  store %struct.cass_list_t* null, %struct.cass_list_t** %33, align 8
  %34 = load i32, i32* %num_regions76, align 4
  %cmp85 = icmp eq i32 %34, 0
  br i1 %cmp85, label %do.end, label %if.then86

if.then86:                                        ; preds = %do.body
  %conv = zext i32 %34 to i64
  %mul = mul nuw nsw i64 %conv, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @333, i32 0, i32 0))
  %call88 = call noalias i8* @malloc(i64 %mul) #11
  %35 = bitcast %struct.cass_list_entry_t** %data to i8**
  store i8* %call88, i8** %35, align 8
  %cmp95 = icmp eq i8* %call88, null
  br i1 %cmp95, label %if.else98, label %if.then86.do.end_crit_edge

if.then86.do.end_crit_edge:                       ; preds = %if.then86
  %.pre10 = load i32, i32* %num_regions76, align 4
  br label %do.end

if.else98:                                        ; preds = %if.then86
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @334, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.44, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 567, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

do.end:                                           ; preds = %if.then86.do.end_crit_edge, %do.body
  %36 = phi i32 [ %.pre10, %if.then86.do.end_crit_edge ], [ 0, %do.body ]
  store i32 %36, i32* %32, align 8
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then67.for.cond.preheader_crit_edge, %do.end
  %.pre-phi = phi %struct.cass_list_t** [ %.pre19, %if.then67.for.cond.preheader_crit_edge ], [ %33, %do.end ]
  %num_regions106.pre-phi = phi i32* [ %num_regions, %if.then67.for.cond.preheader_crit_edge ], [ %num_regions76, %do.end ]
  %cmp185 = fcmp oeq float %call34, 0.000000e+00
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %24, i64 %idx.ext, i32 1
  %topk220 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query2, i64 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc224
  %i.0 = phi i32 [ %inc225, %for.inc224 ], [ 0, %for.cond.preheader ]
  %37 = load i32, i32* %num_regions106.pre-phi, align 4
  %cmp107 = icmp ult i32 %i.0, %37
  %38 = load i32, i32* %flags, align 8
  br i1 %cmp107, label %for.body, label %for.end226

for.body:                                         ; preds = %for.cond
  %and110 = and i32 %38, 1024
  %tobool111 = icmp eq i32 %and110, 0
  %39 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %idxprom128 = zext i32 %i.0 to i64
  br i1 %tobool111, label %do.body124, label %if.then112

if.then112:                                       ; preds = %for.body
  %size116 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %39, i64 %idxprom128, i32 1
  %40 = load i32, i32* %size116, align 4
  %41 = load i32, i32* %topk, align 4
  %cmp118 = icmp ult i32 %40, %41
  br i1 %cmp118, label %if.else121, label %if.end177

if.else121:                                       ; preds = %if.then112
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @335, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.45, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 575, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

do.body124:                                       ; preds = %for.body
  %inc130 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %39, i64 %idxprom128, i32 0
  store i32 256, i32* %inc130, align 8
  %42 = load i32, i32* %topk, align 4
  %43 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %size137 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %43, i64 %idxprom128, i32 1
  store i32 %42, i32* %size137, align 4
  %44 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %len143 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %44, i64 %idxprom128, i32 2
  store i32 0, i32* %len143, align 8
  %45 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data149 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %45, i64 %idxprom128, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data149, align 8
  %46 = load i32, i32* %topk, align 4
  %cmp151 = icmp eq i32 %46, 0
  br i1 %cmp151, label %do.body124.if.end177_crit_edge, label %if.then153

do.body124.if.end177_crit_edge:                   ; preds = %do.body124
  %.pre17 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  br label %if.end177

if.then153:                                       ; preds = %do.body124
  %conv155 = zext i32 %46 to i64
  %mul156 = shl nuw nsw i64 %conv155, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @336, i32 0, i32 0))
  %call157 = call noalias i8* @malloc(i64 %mul156) #11
  %47 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data163 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %47, i64 %idxprom128, i32 3
  %48 = bitcast %struct.cass_list_entry_t** %data163 to i8**
  store i8* %call157, i8** %48, align 8
  %49 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data169 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %49, i64 %idxprom128, i32 3
  %50 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data169, align 8
  %cmp170 = icmp eq %struct.cass_list_entry_t* %50, null
  br i1 %cmp170, label %if.else173, label %if.then153.if.end177_crit_edge

if.then153.if.end177_crit_edge:                   ; preds = %if.then153
  %.pre16 = load i32, i32* %topk, align 4
  br label %if.end177

if.else173:                                       ; preds = %if.then153
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @337, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.46, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 579, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__.__LSH_query, i64 0, i64 0)) #16
  unreachable

if.end177:                                        ; preds = %do.body124.if.end177_crit_edge, %if.then153.if.end177_crit_edge, %if.then112
  %51 = phi %struct.cass_list_t* [ %.pre17, %do.body124.if.end177_crit_edge ], [ %49, %if.then153.if.end177_crit_edge ], [ %39, %if.then112 ]
  %52 = phi i32 [ 0, %do.body124.if.end177_crit_edge ], [ %.pre16, %if.then153.if.end177_crit_edge ], [ %41, %if.then112 ]
  %len184 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %51, i64 %idxprom128, i32 2
  store i32 %52, i32* %len184, align 8
  %53 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset, align 8
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %53, i64 0, i32 6
  %54 = load i8*, i8** %vec, align 8
  %55 = load i32, i32* %start_vecid, align 4
  %add = add i32 %55, %i.0
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %53, i64 0, i32 2
  %56 = load i32, i32* %vec_size, align 8
  %mul190 = mul i32 %add, %56
  %idx.ext191 = zext i32 %mul190 to i64
  %add.ptr192 = getelementptr inbounds i8, i8* %54, i64 %idx.ext191
  %u193 = getelementptr inbounds i8, i8* %add.ptr192, i64 8
  %arraydecay = bitcast i8* %u193 to float*
  br i1 %cmp185, label %if.then187, label %if.else194

if.then187:                                       ; preds = %if.end177
  call fastcc void @LSH_query(%struct.LSH_query_t* nonnull %query2, float* %arraydecay)
  br label %for.cond208

if.else194:                                       ; preds = %if.end177
  call fastcc void @LSH_query_recall(%struct.LSH_query_t* nonnull %query2, float* %arraydecay, float %call34)
  br label %for.cond208

for.cond208:                                      ; preds = %if.then187, %if.else194, %for.inc
  %indvars.iv26 = phi i64 [ %indvars.iv.next27, %for.inc ], [ 0, %if.else194 ], [ 0, %if.then187 ]
  %wide.trip.count = zext i32 %17 to i64
  %exitcond = icmp eq i64 %indvars.iv26, %wide.trip.count
  br i1 %exitcond, label %for.inc224, label %for.inc

for.inc:                                          ; preds = %for.cond208
  %57 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data217 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %57, i64 %idxprom128, i32 3
  %58 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data217, align 8
  %arrayidx219 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %58, i64 %indvars.iv26
  %59 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk220, align 8
  %arrayidx222 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %59, i64 %indvars.iv26
  %60 = bitcast %struct.cass_list_entry_t* %arrayidx222 to i64*
  %61 = bitcast %struct.cass_list_entry_t* %arrayidx219 to i64*
  %62 = load i64, i64* %60, align 4
  store i64 %62, i64* %61, align 4
  %indvars.iv.next27 = add nuw nsw i64 %indvars.iv26, 1
  br label %for.cond208

for.inc224:                                       ; preds = %for.cond208
  %inc225 = add i32 %i.0, 1
  br label %for.cond

for.end226:                                       ; preds = %for.cond
  %and228 = and i32 %38, 16
  %tobool229 = icmp eq i32 %and228, 0
  br i1 %tobool229, label %if.end338, label %for.cond231

for.cond231:                                      ; preds = %for.end226, %for.inc333
  %63 = phi i32 [ %.pre11, %for.inc333 ], [ %37, %for.end226 ]
  %j.1 = phi i32 [ %inc334, %for.inc333 ], [ 0, %for.end226 ]
  %cmp233 = icmp ult i32 %j.1, %63
  br i1 %cmp233, label %do.body236, label %for.end335

do.body236:                                       ; preds = %for.cond231
  %64 = load i32, i32* %topk, align 4
  %idxprom243 = zext i32 %j.1 to i64
  %65 = sext i32 %64 to i64
  br label %while.cond

while.cond:                                       ; preds = %for.end323, %do.body236
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.end323 ], [ %65, %do.body236 ]
  %cmp238 = icmp sgt i64 %indvars.iv, 0
  br i1 %cmp238, label %while.body, label %for.inc333

while.body:                                       ; preds = %while.cond
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %66 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data245 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %66, i64 %idxprom243, i32 3
  %67 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data245, align 8
  %arrayidx247 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %67, i64 %indvars.iv.next
  %.sroa_idx3 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %arrayidx247, i64 0, i32 0
  %68 = load i32, i32* %.sroa_idx3, align 4
  %.sroa_idx5 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %67, i64 %indvars.iv.next, i32 1
  %.sroa_cast6 = bitcast float* %.sroa_idx5 to i32*
  %69 = load i32, i32* %.sroa_cast6, align 4
  %70 = bitcast %struct.cass_list_entry_t* %67 to i64*
  %71 = bitcast %struct.cass_list_entry_t* %arrayidx247 to i64*
  %72 = load i64, i64* %70, align 4
  store i64 %72, i64* %71, align 4
  %73 = bitcast i32 %69 to float
  br label %for.cond263

for.cond263:                                      ; preds = %if.end306, %while.body
  %iiii.0 = phi i32 [ 0, %while.body ], [ %llll.0, %if.end306 ]
  %shl = shl i32 %iiii.0, 1
  %add264 = or i32 %shl, 1
  %74 = sext i32 %add264 to i64
  %cmp265 = icmp slt i64 %74, %indvars.iv.next
  br i1 %cmp265, label %if.end268, label %for.cond263.for.end323_crit_edge

for.cond263.for.end323_crit_edge:                 ; preds = %for.cond263
  %.pre14 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data329.phi.trans.insert = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %.pre14, i64 %idxprom243, i32 3
  %.pre15 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data329.phi.trans.insert, align 8
  br label %for.end323

if.end268:                                        ; preds = %for.cond263
  %add269 = add nsw i32 %add264, 1
  %75 = sext i32 %add269 to i64
  %cmp270 = icmp slt i64 %75, %indvars.iv.next
  %76 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data277 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %76, i64 %idxprom243, i32 3
  %77 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data277, align 8
  br i1 %cmp270, label %land.lhs.true, label %if.end292

land.lhs.true:                                    ; preds = %if.end268
  %idxprom278 = sext i32 %add269 to i64
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom278, i32 1
  %78 = load float, float* %dist, align 4
  %idxprom286 = sext i32 %add264 to i64
  %dist288 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom286, i32 1
  %79 = load float, float* %dist288, align 4
  %cmp289 = fcmp ogt float %78, %79
  br i1 %cmp289, label %if.then291, label %if.end292

if.then291:                                       ; preds = %land.lhs.true
  br label %if.end292

if.end292:                                        ; preds = %if.end268, %if.then291, %land.lhs.true
  %llll.0 = phi i32 [ %add269, %if.then291 ], [ %add264, %land.lhs.true ], [ %add264, %if.end268 ]
  %idxprom300 = sext i32 %llll.0 to i64
  %dist302 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom300, i32 1
  %80 = load float, float* %dist302, align 4
  %cmp303 = fcmp ogt float %73, %80
  br i1 %cmp303, label %for.end323, label %if.end306

if.end306:                                        ; preds = %if.end292
  %idxprom313 = sext i32 %iiii.0 to i64
  %arrayidx314 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom313
  %arrayidx322 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %77, i64 %idxprom300
  %81 = bitcast %struct.cass_list_entry_t* %arrayidx322 to i64*
  %82 = bitcast %struct.cass_list_entry_t* %arrayidx314 to i64*
  %83 = load i64, i64* %81, align 4
  store i64 %83, i64* %82, align 4
  br label %for.cond263

for.end323:                                       ; preds = %if.end292, %for.cond263.for.end323_crit_edge
  %84 = phi %struct.cass_list_entry_t* [ %.pre15, %for.cond263.for.end323_crit_edge ], [ %77, %if.end292 ]
  %idxprom330 = sext i32 %iiii.0 to i64
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %84, i64 %idxprom330, i32 0
  store i32 %68, i32* %.sroa_idx, align 4
  %.sroa_idx2 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %84, i64 %idxprom330, i32 1
  %.sroa_cast = bitcast float* %.sroa_idx2 to i32*
  store i32 %69, i32* %.sroa_cast, align 4
  br label %while.cond

for.inc333:                                       ; preds = %while.cond
  %inc334 = add i32 %j.1, 1
  %.pre11 = load i32, i32* %num_regions106.pre-phi, align 4
  br label %for.cond231

for.end335:                                       ; preds = %for.cond231
  %85 = load i32, i32* %flags62, align 8
  %or337 = or i32 %85, 16
  store i32 %or337, i32* %flags62, align 8
  br label %if.end338

if.end338:                                        ; preds = %for.end226, %for.end335
  call fastcc void @LSH_query_cleanup(%struct.LSH_query_t* nonnull %query2)
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @__LSH_batch_query(%struct._cass_table.157* nocapture readonly %table, i32 %count, %struct.cass_query_t** nocapture readonly %queries, %struct.cass_result_t** nocapture readonly %results) #0 {
entry:
  %query2 = alloca %struct.LSH_query_t, align 8
  %__private = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 12
  %0 = bitcast i8** %__private to %struct.LSH_t**
  %1 = load %struct.LSH_t*, %struct.LSH_t** %0, align 8
  %2 = load %struct.cass_query_t*, %struct.cass_query_t** %queries, align 8
  %loaded = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 10
  %3 = load i32, i32* %loaded, align 8
  %tobool = icmp eq i32 %3, 0
  br i1 %tobool, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @338, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 638, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %env = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 3
  %4 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %vec_dist1 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %4, i64 0, i32 6
  %vec_dist_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %2, i64 0, i32 7
  %5 = load i32, i32* %vec_dist_id, align 8
  %call = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %vec_dist1, i32 %5)
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else3, label %if.end4

if.else3:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @339, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.30, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 640, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end4:                                          ; preds = %if.end
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %6 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  %7 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %6, align 8
  %cmp5 = icmp eq %struct._cass_vec_dist_class* %7, @vec_dist_L2_float
  br i1 %cmp5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 641, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.31, i64 0, i64 0))
  br label %if.end7

if.end7:                                          ; preds = %if.end4, %if.then6
  %parent_id = getelementptr inbounds %struct._cass_table.157, %struct._cass_table.157* %table, i64 0, i32 4
  %8 = load i32, i32* %parent_id, align 8
  %cmp8 = icmp eq i32 %8, -1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 643, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.32, i64 0, i64 0))
  %.pre = load i32, i32* %parent_id, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %9 = phi i32 [ %.pre, %if.then9 ], [ %8, %if.end7 ]
  %10 = load %struct._cass_env_t*, %struct._cass_env_t** %env, align 8
  %table12 = getelementptr inbounds %struct._cass_env_t, %struct._cass_env_t* %10, i64 0, i32 2
  %call14 = call fastcc i8* @cass_reg_get(%struct.cass_reg_t* %table12, i32 %9)
  %cmp15 = icmp eq i8* %call14, null
  br i1 %cmp15, label %if.else17, label %if.end18

if.else17:                                        ; preds = %if.end10
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @340, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.33, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 645, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end18:                                         ; preds = %if.end10
  %loaded19 = getelementptr inbounds i8, i8* %call14, i64 80
  %11 = bitcast i8* %loaded19 to i32*
  %12 = load i32, i32* %11, align 8
  %tobool20 = icmp eq i32 %12, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 646, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.34, i64 0, i64 0))
  br label %if.end22

if.end22:                                         ; preds = %if.end18, %if.then21
  %opr = getelementptr inbounds i8, i8* %call14, i64 72
  %13 = bitcast i8* %opr to %struct._cass_table_opr.152**
  %14 = load %struct._cass_table_opr.152*, %struct._cass_table_opr.152** %13, align 8
  %type = getelementptr inbounds %struct._cass_table_opr.152, %struct._cass_table_opr.152* %14, i64 0, i32 1
  %15 = load i32, i32* %type, align 8
  %and = and i32 %15, 1
  %tobool23 = icmp eq i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end22
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 647, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.35, i64 0, i64 0))
  br label %if.end25

if.end25:                                         ; preds = %if.end22, %if.then24
  %__private26 = getelementptr inbounds i8, i8* %call14, i64 88
  %16 = bitcast i8* %__private26 to %struct.cass_dataset_t**
  %17 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %16, align 8
  %topk = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %2, i64 0, i32 3
  %18 = load i32, i32* %topk, align 4
  %cmp27 = icmp eq i32 %18, 0
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  call void (i8*, i32, i8*, i8*, ...) @__debug(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 653, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.330, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.36.360, i64 0, i64 0))
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  %extra_params = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %2, i64 0, i32 5
  %19 = load i8*, i8** %extra_params, align 8
  %call30 = call fastcc i32 @param_get_int(i8* %19, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.4.325, i64 0, i64 0), i32 1)
  %20 = load i8*, i8** %extra_params, align 8
  %call32 = call fastcc i32 @param_get_int(i8* %20, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.37, i64 0, i64 0), i32 0)
  call fastcc void @LSH_query_init(%struct.LSH_query_t* nonnull %query2, %struct.LSH_t* %1, %struct.cass_dataset_t* %17, i32 %18, i32 %call30, i32 %call32)
  %flags = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %2, i64 0, i32 0
  %21 = load i32, i32* %flags, align 8
  %and33 = and i32 %21, 4
  %cmp34 = icmp eq i32 %and33, 0
  br i1 %cmp34, label %if.end37, label %if.else36

if.else36:                                        ; preds = %if.end29
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @341, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.38, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 661, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end37:                                         ; preds = %if.end29
  %and39 = and i32 %21, 1
  %cmp40 = icmp eq i32 %and39, 0
  br i1 %cmp40, label %if.end43, label %if.else42

if.else42:                                        ; preds = %if.end37
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @342, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.39, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 662, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end43:                                         ; preds = %if.end37
  %and45 = and i32 %21, 2
  %cmp46 = icmp eq i32 %and45, 0
  br i1 %cmp46, label %if.end49, label %if.else48

if.else48:                                        ; preds = %if.end43
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @343, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.40, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 663, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end49:                                         ; preds = %if.end43
  %and51 = and i32 %21, 8
  %tobool52 = icmp eq i32 %and51, 0
  br i1 %tobool52, label %if.else54, label %if.end55

if.else54:                                        ; preds = %if.end49
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @344, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.41, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 664, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end55:                                         ; preds = %if.end49
  %candidate = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %2, i64 0, i32 6
  %22 = load %struct.cass_result_t*, %struct.cass_result_t** %candidate, align 8
  %cmp56 = icmp eq %struct.cass_result_t* %22, null
  br i1 %cmp56, label %for.cond.preheader, label %if.else58

for.cond.preheader:                               ; preds = %if.end55
  %23 = zext i32 %count to i64
  br label %for.cond

if.else58:                                        ; preds = %if.end55
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @345, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.42, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 665, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc192
  %indvars.iv46 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next47, %for.inc192 ]
  %vec_count.0 = phi i32 [ 0, %for.cond.preheader ], [ %add, %for.inc192 ]
  %query.0 = phi %struct.cass_query_t* [ %2, %for.cond.preheader ], [ %25, %for.inc192 ]
  %cmp60 = icmp ult i64 %indvars.iv46, %23
  br i1 %cmp60, label %for.body, label %for.end194

for.body:                                         ; preds = %for.cond
  %arrayidx61 = getelementptr inbounds %struct.cass_result_t*, %struct.cass_result_t** %results, i64 %indvars.iv46
  %24 = load %struct.cass_result_t*, %struct.cass_result_t** %arrayidx61, align 8
  %arrayidx63 = getelementptr inbounds %struct.cass_query_t*, %struct.cass_query_t** %queries, i64 %indvars.iv46
  %25 = load %struct.cass_query_t*, %struct.cass_query_t** %arrayidx63, align 8
  %flags64 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 0
  store i32 8, i32* %flags64, align 8
  %dataset = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %25, i64 0, i32 1
  %26 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset, align 8
  %vecset65 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %26, i64 0, i32 9
  %27 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset65, align 8
  %vecset_id = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %25, i64 0, i32 2
  %28 = load i32, i32* %vecset_id, align 8
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %27, i64 %idx.ext
  %flags66 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %25, i64 0, i32 0
  %29 = load i32, i32* %flags66, align 8
  %and67 = and i32 %29, 1024
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %do.body, label %if.then69

if.then69:                                        ; preds = %for.body
  %30 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 2
  %31 = load i32, i32* %30, align 8
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %add.ptr, i64 0, i32 0
  %32 = load i32, i32* %num_regions, align 4
  %cmp70 = icmp ult i32 %31, %32
  br i1 %cmp70, label %if.else72, label %if.then69.for.cond108.preheader_crit_edge

if.then69.for.cond108.preheader_crit_edge:        ; preds = %if.then69
  %.pre20 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 3
  %.pre21 = bitcast %struct.cass_list_entry_t** %.pre20 to %struct.cass_list_t**
  br label %for.cond108.preheader

if.else72:                                        ; preds = %if.then69
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @346, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.43, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 677, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

do.body:                                          ; preds = %for.body
  store i32 264, i32* %flags64, align 8
  %inc = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 0
  store i32 256, i32* %inc, align 8
  %num_regions78 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %add.ptr, i64 0, i32 0
  %33 = load i32, i32* %num_regions78, align 4
  %34 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 1
  store i32 %33, i32* %34, align 4
  %35 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 2
  store i32 0, i32* %35, align 8
  %data = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %24, i64 0, i32 1, i32 0, i32 3
  %36 = bitcast %struct.cass_list_entry_t** %data to %struct.cass_list_t**
  store %struct.cass_list_t* null, %struct.cass_list_t** %36, align 8
  %37 = load i32, i32* %num_regions78, align 4
  %cmp87 = icmp eq i32 %37, 0
  br i1 %cmp87, label %do.end, label %if.then88

if.then88:                                        ; preds = %do.body
  %conv = zext i32 %37 to i64
  %mul = mul nuw nsw i64 %conv, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @347, i32 0, i32 0))
  %call90 = call noalias i8* @malloc(i64 %mul) #11
  %38 = bitcast %struct.cass_list_entry_t** %data to i8**
  store i8* %call90, i8** %38, align 8
  %cmp97 = icmp eq i8* %call90, null
  br i1 %cmp97, label %if.else100, label %if.then88.do.end_crit_edge

if.then88.do.end_crit_edge:                       ; preds = %if.then88
  %.pre18 = load i32, i32* %num_regions78, align 4
  br label %do.end

if.else100:                                       ; preds = %if.then88
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @348, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.44, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 682, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

do.end:                                           ; preds = %if.then88.do.end_crit_edge, %do.body
  %39 = phi i32 [ %.pre18, %if.then88.do.end_crit_edge ], [ 0, %do.body ]
  store i32 %39, i32* %35, align 8
  br label %for.cond108.preheader

for.cond108.preheader:                            ; preds = %if.then69.for.cond108.preheader_crit_edge, %do.end
  %.pre-phi = phi %struct.cass_list_t** [ %.pre21, %if.then69.for.cond108.preheader_crit_edge ], [ %36, %do.end ]
  %num_regions109.pre-phi = phi i32* [ %num_regions, %if.then69.for.cond108.preheader_crit_edge ], [ %num_regions78, %do.end ]
  %topk137 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %25, i64 0, i32 3
  br label %for.cond108

for.cond108:                                      ; preds = %for.cond108.preheader, %for.inc
  %j.0 = phi i32 [ %inc190, %for.inc ], [ 0, %for.cond108.preheader ]
  %40 = load i32, i32* %num_regions109.pre-phi, align 4
  %cmp110 = icmp ult i32 %j.0, %40
  br i1 %cmp110, label %for.body112, label %for.inc192

for.body112:                                      ; preds = %for.cond108
  %41 = load i32, i32* %flags66, align 8
  %and114 = and i32 %41, 1024
  %tobool115 = icmp eq i32 %and114, 0
  %42 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %idxprom134 = zext i32 %j.0 to i64
  br i1 %tobool115, label %do.body130, label %if.then116

if.then116:                                       ; preds = %for.body112
  %size122 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %42, i64 %idxprom134, i32 1
  %43 = load i32, i32* %size122, align 4
  %44 = load i32, i32* %topk137, align 4
  %cmp124 = icmp ult i32 %43, %44
  br i1 %cmp124, label %if.else127, label %for.inc

if.else127:                                       ; preds = %if.then116
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @349, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.47, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 690, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

do.body130:                                       ; preds = %for.body112
  %inc136 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %42, i64 %idxprom134, i32 0
  store i32 256, i32* %inc136, align 8
  %45 = load i32, i32* %topk137, align 4
  %46 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %size143 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %46, i64 %idxprom134, i32 1
  store i32 %45, i32* %size143, align 4
  %47 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %len149 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %47, i64 %idxprom134, i32 2
  store i32 0, i32* %len149, align 8
  %48 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data155 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %48, i64 %idxprom134, i32 3
  store %struct.cass_list_entry_t* null, %struct.cass_list_entry_t** %data155, align 8
  %49 = load i32, i32* %topk137, align 4
  %cmp157 = icmp eq i32 %49, 0
  br i1 %cmp157, label %do.body130.for.inc_crit_edge, label %if.then159

do.body130.for.inc_crit_edge:                     ; preds = %do.body130
  %.pre19 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  br label %for.inc

if.then159:                                       ; preds = %do.body130
  %conv161 = zext i32 %49 to i64
  %mul162 = shl nuw nsw i64 %conv161, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @350, i32 0, i32 0))
  %call163 = call noalias i8* @malloc(i64 %mul162) #11
  %50 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data169 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %50, i64 %idxprom134, i32 3
  %51 = bitcast %struct.cass_list_entry_t** %data169 to i8**
  store i8* %call163, i8** %51, align 8
  %52 = load %struct.cass_list_t*, %struct.cass_list_t** %.pre-phi, align 8
  %data175 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %52, i64 %idxprom134, i32 3
  %53 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %data175, align 8
  %cmp176 = icmp eq %struct.cass_list_entry_t* %53, null
  br i1 %cmp176, label %if.else179, label %for.inc

if.else179:                                       ; preds = %if.then159
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @351, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.48, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 694, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %do.body130.for.inc_crit_edge, %if.then116, %if.then159
  %54 = phi %struct.cass_list_t* [ %.pre19, %do.body130.for.inc_crit_edge ], [ %42, %if.then116 ], [ %52, %if.then159 ]
  %len189 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %54, i64 %idxprom134, i32 2
  store i32 %18, i32* %len189, align 8
  %inc190 = add i32 %j.0, 1
  br label %for.cond108

for.inc192:                                       ; preds = %for.cond108
  %add = add i32 %vec_count.0, %40
  %indvars.iv.next47 = add nuw nsw i64 %indvars.iv46, 1
  br label %for.cond

for.end194:                                       ; preds = %for.cond
  %conv195 = zext i32 %vec_count.0 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @352, i32 0, i32 0))
  %call196 = call noalias i8* @calloc(i64 8, i64 %conv195) #11
  %55 = bitcast i8* %call196 to float**
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @353, i32 0, i32 0))
  %call198 = call noalias i8* @calloc(i64 8, i64 %conv195) #11
  %56 = bitcast i8* %call198 to %struct.cass_list_entry_t**
  br label %for.cond199

for.cond199:                                      ; preds = %for.inc238, %for.end194
  %indvars.iv42 = phi i64 [ %indvars.iv.next43, %for.inc238 ], [ 0, %for.end194 ]
  %query.1 = phi %struct.cass_query_t* [ %58, %for.inc238 ], [ %query.0, %for.end194 ]
  %k.0 = phi i32 [ %73, %for.inc238 ], [ 0, %for.end194 ]
  %wide.trip.count44 = zext i32 %count to i64
  %exitcond45 = icmp eq i64 %indvars.iv42, %wide.trip.count44
  br i1 %exitcond45, label %for.end240, label %for.body202

for.body202:                                      ; preds = %for.cond199
  %arrayidx204 = getelementptr inbounds %struct.cass_result_t*, %struct.cass_result_t** %results, i64 %indvars.iv42
  %57 = load %struct.cass_result_t*, %struct.cass_result_t** %arrayidx204, align 8
  %arrayidx206 = getelementptr inbounds %struct.cass_query_t*, %struct.cass_query_t** %queries, i64 %indvars.iv42
  %58 = load %struct.cass_query_t*, %struct.cass_query_t** %arrayidx206, align 8
  %dataset207 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %58, i64 0, i32 1
  %59 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %dataset207, align 8
  %vecset208 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %59, i64 0, i32 9
  %60 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset208, align 8
  %vecset_id209 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %58, i64 0, i32 2
  %61 = load i32, i32* %vecset_id209, align 8
  %idx.ext210 = zext i32 %61 to i64
  %num_regions213 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %60, i64 %idx.ext210, i32 0
  %62 = load i32, i32* %num_regions213, align 4
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %60, i64 %idx.ext210, i32 1
  %data228 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %57, i64 0, i32 1, i32 0, i32 3
  %63 = bitcast %struct.cass_list_entry_t** %data228 to %struct.cass_list_t**
  br label %for.cond212

for.cond212:                                      ; preds = %for.inc235, %for.body202
  %indvars.iv38 = phi i64 [ %indvars.iv.next39, %for.inc235 ], [ 0, %for.body202 ]
  %k.1 = phi i32 [ %inc234, %for.inc235 ], [ %k.0, %for.body202 ]
  %wide.trip.count40 = zext i32 %62 to i64
  %exitcond41 = icmp eq i64 %indvars.iv38, %wide.trip.count40
  br i1 %exitcond41, label %for.inc238, label %for.inc235

for.inc235:                                       ; preds = %for.cond212
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %59, i64 0, i32 6
  %64 = load i8*, i8** %vec, align 8
  %65 = load i32, i32* %start_vecid, align 4
  %66 = trunc i64 %indvars.iv38 to i32
  %add218 = add i32 %65, %66
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %59, i64 0, i32 2
  %67 = load i32, i32* %vec_size, align 8
  %mul220 = mul i32 %add218, %67
  %idx.ext221 = zext i32 %mul220 to i64
  %add.ptr222 = getelementptr inbounds i8, i8* %64, i64 %idx.ext221
  %u223 = getelementptr inbounds i8, i8* %add.ptr222, i64 8
  %idxprom224 = zext i32 %k.1 to i64
  %arrayidx225 = getelementptr inbounds float*, float** %55, i64 %idxprom224
  %68 = bitcast float** %arrayidx225 to i8**
  store i8* %u223, i8** %68, align 8
  %69 = load %struct.cass_list_t*, %struct.cass_list_t** %63, align 8
  %data231 = getelementptr inbounds %struct.cass_list_t, %struct.cass_list_t* %69, i64 %indvars.iv38, i32 3
  %70 = bitcast %struct.cass_list_entry_t** %data231 to i64*
  %71 = load i64, i64* %70, align 8
  %arrayidx233 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %56, i64 %idxprom224
  %72 = bitcast %struct.cass_list_entry_t** %arrayidx233 to i64*
  store i64 %71, i64* %72, align 8
  %inc234 = add i32 %k.1, 1
  %indvars.iv.next39 = add nuw nsw i64 %indvars.iv38, 1
  br label %for.cond212

for.inc238:                                       ; preds = %for.cond212
  %73 = add i32 %k.0, %62
  %indvars.iv.next43 = add nuw nsw i64 %indvars.iv42, 1
  br label %for.cond199

for.end240:                                       ; preds = %for.cond199
  %cmp241 = icmp eq i32 %k.0, %vec_count.0
  br i1 %cmp241, label %if.end245, label %if.else244

if.else244:                                       ; preds = %for.end240
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @354, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.49, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.1.322, i64 0, i64 0), i32 718, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @__PRETTY_FUNCTION__.__LSH_batch_query, i64 0, i64 0)) #16
  unreachable

if.end245:                                        ; preds = %for.end240
  %extra_params246 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %query.1, i64 0, i32 5
  %74 = load i8*, i8** %extra_params246, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @355, i32 0, i32 0))
  %call247 = call i8* @strstr(i8* %74, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.50, i64 0, i64 0)) #15
  %tobool248 = icmp eq i8* %call247, null
  br i1 %tobool248, label %if.else250, label %if.then249

if.then249:                                       ; preds = %if.end245
  call fastcc void @LSH_query_batch_ca(%struct.LSH_query_t* nonnull %query2, i32 %vec_count.0, float** %55, %struct.cass_list_entry_t** %56)
  br label %if.end251

if.else250:                                       ; preds = %if.end245
  call fastcc void @LSH_query_batch(%struct.LSH_query_t* nonnull %query2, i32 %vec_count.0, float** %55, %struct.cass_list_entry_t** %56)
  br label %if.end251

if.end251:                                        ; preds = %if.else250, %if.then249
  %75 = load %struct.cass_query_t*, %struct.cass_query_t** %queries, align 8
  %flags253 = getelementptr inbounds %struct.cass_query_t, %struct.cass_query_t* %75, i64 0, i32 0
  %76 = load i32, i32* %flags253, align 8
  %and254 = and i32 %76, 16
  %tobool255 = icmp eq i32 %and254, 0
  br i1 %tobool255, label %if.end335, label %for.cond257.preheader

for.cond257.preheader:                            ; preds = %if.end251
  %77 = sext i32 %18 to i64
  br label %for.cond257

for.cond257:                                      ; preds = %for.cond257.preheader, %for.inc321
  %indvars.iv34 = phi i64 [ 0, %for.cond257.preheader ], [ %indvars.iv.next35, %for.inc321 ]
  %wide.trip.count36 = zext i32 %vec_count.0 to i64
  %exitcond37 = icmp eq i64 %indvars.iv34, %wide.trip.count36
  br i1 %exitcond37, label %for.cond324, label %while.cond.preheader

while.cond.preheader:                             ; preds = %for.cond257
  %arrayidx265 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %56, i64 %indvars.iv34
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %for.end315
  %indvars.iv32 = phi i64 [ %77, %while.cond.preheader ], [ %indvars.iv.next33, %for.end315 ]
  %cmp262 = icmp sgt i64 %indvars.iv32, 0
  br i1 %cmp262, label %while.body, label %for.inc321

while.body:                                       ; preds = %while.cond
  %indvars.iv.next33 = add nsw i64 %indvars.iv32, -1
  %78 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx265, align 8
  %arrayidx267 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %indvars.iv.next33
  %.sroa_idx3 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %arrayidx267, i64 0, i32 0
  %79 = load i32, i32* %.sroa_idx3, align 4
  %.sroa_idx5 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %indvars.iv.next33, i32 1
  %.sroa_cast6 = bitcast float* %.sroa_idx5 to i32*
  %80 = load i32, i32* %.sroa_cast6, align 4
  %81 = bitcast %struct.cass_list_entry_t* %78 to i64*
  %82 = bitcast %struct.cass_list_entry_t* %arrayidx267 to i64*
  %83 = load i64, i64* %81, align 4
  store i64 %83, i64* %82, align 4
  %84 = bitcast i32 %80 to float
  br label %for.cond275

for.cond275:                                      ; preds = %if.end306, %while.body
  %iiii.0 = phi i32 [ 0, %while.body ], [ %llll.0, %if.end306 ]
  %shl = shl i32 %iiii.0, 1
  %add276 = or i32 %shl, 1
  %85 = sext i32 %add276 to i64
  %cmp277 = icmp slt i64 %85, %indvars.iv.next33
  br i1 %cmp277, label %if.end280, label %for.end315

if.end280:                                        ; preds = %for.cond275
  %add281 = add nsw i32 %add276, 1
  %86 = sext i32 %add281 to i64
  %cmp282 = icmp slt i64 %86, %indvars.iv.next33
  br i1 %cmp282, label %land.lhs.true, label %if.end296

land.lhs.true:                                    ; preds = %if.end280
  %idxprom286 = sext i32 %add281 to i64
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom286, i32 1
  %87 = load float, float* %dist, align 4
  %idxprom290 = sext i32 %add276 to i64
  %dist292 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom290, i32 1
  %88 = load float, float* %dist292, align 4
  %cmp293 = fcmp ogt float %87, %88
  br i1 %cmp293, label %if.then295, label %if.end296

if.then295:                                       ; preds = %land.lhs.true
  br label %if.end296

if.end296:                                        ; preds = %if.then295, %land.lhs.true, %if.end280
  %llll.0 = phi i32 [ %add281, %if.then295 ], [ %add276, %land.lhs.true ], [ %add276, %if.end280 ]
  %idxprom300 = sext i32 %llll.0 to i64
  %dist302 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom300, i32 1
  %89 = load float, float* %dist302, align 4
  %cmp303 = fcmp ogt float %84, %89
  br i1 %cmp303, label %for.end315, label %if.end306

if.end306:                                        ; preds = %if.end296
  %idxprom309 = sext i32 %iiii.0 to i64
  %arrayidx310 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom309
  %arrayidx314 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom300
  %90 = bitcast %struct.cass_list_entry_t* %arrayidx314 to i64*
  %91 = bitcast %struct.cass_list_entry_t* %arrayidx310 to i64*
  %92 = load i64, i64* %90, align 4
  store i64 %92, i64* %91, align 4
  br label %for.cond275

for.end315:                                       ; preds = %if.end296, %for.cond275
  %idxprom318 = sext i32 %iiii.0 to i64
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom318, i32 0
  store i32 %79, i32* %.sroa_idx, align 4
  %.sroa_idx2 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %78, i64 %idxprom318, i32 1
  %.sroa_cast = bitcast float* %.sroa_idx2 to i32*
  store i32 %80, i32* %.sroa_cast, align 4
  br label %while.cond

for.inc321:                                       ; preds = %while.cond
  %indvars.iv.next35 = add nuw nsw i64 %indvars.iv34, 1
  br label %for.cond257

for.cond324:                                      ; preds = %for.cond257, %for.inc332
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc332 ], [ 0, %for.cond257 ]
  %wide.trip.count = zext i32 %count to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %if.end335, label %for.inc332

for.inc332:                                       ; preds = %for.cond324
  %arrayidx329 = getelementptr inbounds %struct.cass_result_t*, %struct.cass_result_t** %results, i64 %indvars.iv
  %93 = load %struct.cass_result_t*, %struct.cass_result_t** %arrayidx329, align 8
  %flags330 = getelementptr inbounds %struct.cass_result_t, %struct.cass_result_t* %93, i64 0, i32 0
  %94 = load i32, i32* %flags330, align 8
  %or331 = or i32 %94, 16
  store i32 %or331, i32* %flags330, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond324

if.end335:                                        ; preds = %for.cond324, %if.end251
  call fastcc void @LSH_query_cleanup(%struct.LSH_query_t* nonnull %query2)
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_recall_init(%struct.LSH_recall_t* nocapture %recall, i32 %d_step, float %d_min, float %d_max, i32 %M, i32 %L, i32 %T, float %W) unnamed_addr #0 {
entry:
  %call = call fastcc %struct.ptb_vec_t* @gen_score(i32 %M)
  %cmp = icmp eq %struct.ptb_vec_t* %call, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @356, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.365, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 59, i8* getelementptr inbounds ([77 x i8], [77 x i8]* @__PRETTY_FUNCTION__.LSH_recall_init, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %conv = sext i32 %T to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @357, i32 0, i32 0))
  %call1 = call noalias i8* @calloc(i64 24, i64 %conv) #11
  %0 = bitcast i8* %call1 to %struct.ptb_vec_t*
  %cmp2 = icmp eq i8* %call1, null
  br i1 %cmp2, label %if.else5, label %if.end6

if.else5:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @358, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.367, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 61, i8* getelementptr inbounds ([77 x i8], [77 x i8]* @__PRETTY_FUNCTION__.LSH_recall_init, i64 0, i64 0)) #16
  unreachable

if.end6:                                          ; preds = %if.end
  call fastcc void @gen_perturb_set(%struct.ptb_vec_t* nonnull %call, %struct.ptb_vec_t* %0, i32 %M, i32 %T)
  %d_step8 = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 0
  store i32 %d_step, i32* %d_step8, align 8
  %d_min9 = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 2
  store float %d_min, float* %d_min9, align 8
  %d_max10 = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 3
  store float %d_max, float* %d_max10, align 4
  %T11 = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 1
  store i32 %T, i32* %T11, align 4
  %add = add nsw i32 %T, 1
  %call12 = call fastcc i8** @__matrix_alloc(i32 %add, i32 %d_step, i32 4)
  %1 = bitcast i8** %call12 to float**
  %table13 = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 4
  %2 = bitcast float*** %table13 to i8***
  store i8** %call12, i8*** %2, align 8
  %sub = fsub float %d_max, %d_min
  %conv17 = sitofp i32 %d_step to float
  %conv20 = fpext float %W to double
  %conv24 = sitofp i32 %M to double
  %mul35 = shl nsw i32 %M, 1
  %conv81 = sitofp i32 %L to float
  %3 = sext i32 %mul35 to i64
  %4 = sext i32 %T to i64
  %5 = sext i32 %T to i64
  %6 = sext i32 %d_step to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc98, %if.end6
  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %for.inc98 ], [ 0, %if.end6 ]
  %cmp14 = icmp slt i64 %indvars.iv10, %6
  br i1 %cmp14, label %for.body, label %for.end100

for.body:                                         ; preds = %for.cond
  %7 = trunc i64 %indvars.iv10 to i32
  %conv16 = sitofp i32 %7 to float
  %mul = fmul float %sub, %conv16
  %div = fdiv float %mul, %conv17
  %add18 = fadd float %div, %d_min
  %conv19 = fpext float %add18 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @359, i32 0, i32 0))
  %call21 = call double @sqrt(double %conv19) #11
  %div22 = fdiv double %conv20, %call21
  %call23 = call fastcc double @p_col_helper(double %div22)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @360, i32 0, i32 0))
  %call25 = call double @pow(double %call23, double %conv24) #11
  %sub26 = fsub double 1.000000e+00, %call25
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @361, i32 0, i32 0))
  %call27 = call double @log(double %sub26) #11
  %conv28 = fptrunc double %call27 to float
  %8 = load float*, float** %1, align 8
  %arrayidx29 = getelementptr inbounds float, float* %8, i64 %indvars.iv10
  store float %conv28, float* %arrayidx29, align 4
  br label %for.cond30

for.cond30:                                       ; preds = %for.inc74, %for.body
  %indvars.iv5 = phi i64 [ %indvars.iv.next6, %for.inc74 ], [ 1, %for.body ]
  %cmp31 = icmp sgt i64 %indvars.iv5, %4
  br i1 %cmp31, label %for.cond77, label %for.cond34.preheader

for.cond34.preheader:                             ; preds = %for.cond30
  %9 = add nsw i64 %indvars.iv5, -1
  %set = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %9, i32 0
  br label %for.cond34

for.cond34:                                       ; preds = %for.cond34.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond34.preheader ], [ %indvars.iv.next, %for.inc ]
  %r.0 = phi double [ 1.000000e+00, %for.cond34.preheader ], [ %r.1, %for.inc ]
  %l.0 = phi i32 [ 0, %for.cond34.preheader ], [ %l.1, %for.inc ]
  %cmp36 = icmp slt i64 %indvars.iv, %3
  br i1 %cmp36, label %for.body38, label %for.end

for.body38:                                       ; preds = %for.cond34
  %10 = load i64, i64* %set, align 8
  %11 = trunc i64 %indvars.iv to i32
  %shl = shl i32 1, %11
  %conv42 = sext i32 %shl to i64
  %and = and i64 %10, %conv42
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %for.inc, label %if.then43

if.then43:                                        ; preds = %for.body38
  %key1 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %call, i64 %indvars.iv, i32 4
  %12 = load float, float* %key1, align 4
  %conv46 = fpext float %12 to double
  %call47 = call fastcc double @p_col_p_helper(double %div22, double %conv46)
  %mul48 = fmul double %r.0, %call47
  %inc = add nsw i32 %l.0, 1
  br label %for.inc

for.inc:                                          ; preds = %if.then43, %for.body38
  %r.1 = phi double [ %mul48, %if.then43 ], [ %r.0, %for.body38 ]
  %l.1 = phi i32 [ %inc, %if.then43 ], [ %l.0, %for.body38 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond34

for.end:                                          ; preds = %for.cond34
  %cmp51 = icmp sgt i32 %l.0, 0
  br i1 %cmp51, label %for.inc74, label %if.else54

if.else54:                                        ; preds = %for.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @362, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3.368, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 86, i8* getelementptr inbounds ([77 x i8], [77 x i8]* @__PRETTY_FUNCTION__.LSH_recall_init, i64 0, i64 0)) #16
  unreachable

for.inc74:                                        ; preds = %for.end
  %sub56 = sub nsw i32 %M, %l.0
  %conv57 = sitofp i32 %sub56 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @363, i32 0, i32 0))
  %call58 = call double @pow(double %call23, double %conv57) #11
  %mul59 = fmul double %r.0, %call58
  %arrayidx623 = getelementptr inbounds i8*, i8** %call12, i64 %9
  %arrayidx62 = bitcast i8** %arrayidx623 to float**
  %13 = load float*, float** %arrayidx62, align 8
  %arrayidx64 = getelementptr inbounds float, float* %13, i64 %indvars.iv10
  %14 = load float, float* %arrayidx64, align 4
  %conv65 = fpext float %14 to double
  %sub66 = fsub double 1.000000e+00, %mul59
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @364, i32 0, i32 0))
  %call67 = call double @log(double %sub66) #11
  %add68 = fadd double %conv65, %call67
  %conv69 = fptrunc double %add68 to float
  %arrayidx714 = getelementptr inbounds i8*, i8** %call12, i64 %indvars.iv5
  %arrayidx71 = bitcast i8** %arrayidx714 to float**
  %15 = load float*, float** %arrayidx71, align 8
  %arrayidx73 = getelementptr inbounds float, float* %15, i64 %indvars.iv10
  store float %conv69, float* %arrayidx73, align 4
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  br label %for.cond30

for.cond77:                                       ; preds = %for.cond30, %for.inc95
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc95 ], [ 0, %for.cond30 ]
  %cmp78 = icmp sgt i64 %indvars.iv8, %5
  br i1 %cmp78, label %for.inc98, label %for.inc95

for.inc95:                                        ; preds = %for.cond77
  %arrayidx831 = getelementptr inbounds i8*, i8** %call12, i64 %indvars.iv8
  %arrayidx83 = bitcast i8** %arrayidx831 to float**
  %16 = load float*, float** %arrayidx83, align 8
  %arrayidx85 = getelementptr inbounds float, float* %16, i64 %indvars.iv10
  %17 = load float, float* %arrayidx85, align 4
  %mul86 = fmul float %conv81, %17
  %conv87 = fpext float %mul86 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @365, i32 0, i32 0))
  %call88 = call double @exp(double %conv87) #11
  %sub89 = fsub double 1.000000e+00, %call88
  %conv90 = fptrunc double %sub89 to float
  %18 = load float*, float** %arrayidx83, align 8
  %arrayidx94 = getelementptr inbounds float, float* %18, i64 %indvars.iv10
  store float %conv90, float* %arrayidx94, align 4
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  br label %for.cond77

for.inc98:                                        ; preds = %for.cond77
  %indvars.iv.next11 = add nuw nsw i64 %indvars.iv10, 1
  br label %for.cond

for.end100:                                       ; preds = %for.cond
  %19 = bitcast %struct.ptb_vec_t* %call to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @366, i32 0, i32 0))
  call void @free(i8* %19) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @367, i32 0, i32 0))
  call void @free(i8* %call1) #11
  ret void
}

; Function Attrs: nounwind
declare double @sqrt(double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc double @p_col_helper(double %x) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @368, i32 0, i32 0))
  %call = call double @gsl_cdf_ugaussian_P(double %x) #11
  %mul = fmul double %call, 2.000000e+00
  %sub = fadd double %mul, -1.000000e+00
  %0 = fmul double %x, %x
  %div = fmul double %0, -5.000000e-01
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @369, i32 0, i32 0))
  %call4 = call double @exp(double %div) #11
  %sub5 = fadd double %call4, -1.000000e+00
  %mul6 = fmul double %sub5, 0x3FE9884533D43651
  %div7 = fdiv double %mul6, %x
  %add = fadd double %sub, %div7
  ret double %add
}

; Function Attrs: nounwind
declare double @log(double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc double @p_col_p_helper(double %x, double %k) unnamed_addr #0 {
entry:
  %add = fadd double %k, 1.000000e+00
  %mul = fmul double %add, %x
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @370, i32 0, i32 0))
  %call = call double @gsl_cdf_ugaussian_P(double %mul) #11
  %mul1 = fmul double %k, %x
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @371, i32 0, i32 0))
  %call2 = call double @gsl_cdf_ugaussian_P(double %mul1) #11
  %sub = fsub double %call, %call2
  ret double %sub
}

; Function Attrs: nounwind
declare double @exp(double) local_unnamed_addr #1

declare double @gsl_cdf_ugaussian_P(double) local_unnamed_addr #2

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @LSH_recall_load(%struct.LSH_recall_t* nocapture %recall, %struct._IO_FILE* nocapture %fin) unnamed_addr #0 {
entry:
  %row = alloca i32, align 4
  %col = alloca i32, align 4
  %___size = alloca i32, align 4
  %___p = alloca i8**, align 8
  %d_step = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 0
  %call = call fastcc i32 @cass_read_uint32.379(i32* %d_step, %struct._IO_FILE* %fin)
  %T = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 1
  %call1 = call fastcc i32 @cass_read_uint32.379(i32* %T, %struct._IO_FILE* %fin)
  %add = add nsw i32 %call, %call1
  %d_min = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 2
  %call2 = call fastcc i32 @cass_read_float.380(float* %d_min, %struct._IO_FILE* %fin)
  %add3 = add nsw i32 %add, %call2
  %d_max = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 3
  %call4 = call fastcc i32 @cass_read_float.380(float* %d_max, %struct._IO_FILE* %fin)
  %add5 = add nsw i32 %add3, %call4
  %cmp = icmp eq i32 %add5, 4
  br i1 %cmp, label %do.body, label %return

do.body:                                          ; preds = %entry
  call fastcc void @matrix_load_stream(%struct._IO_FILE* %fin, i32* nonnull %___size, i32* nonnull %row, i32* nonnull %col, i8*** nonnull %___p)
  %0 = load i32, i32* %___size, align 4
  %cmp7 = icmp eq i32 %0, 4
  br i1 %cmp7, label %do.end, label %if.else

if.else:                                          ; preds = %do.body
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @372, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.4.381, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 128, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__PRETTY_FUNCTION__.LSH_recall_load, i64 0, i64 0)) #16
  unreachable

do.end:                                           ; preds = %do.body
  %1 = bitcast i8*** %___p to i64*
  %2 = load i64, i64* %1, align 8
  %table = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 4
  %3 = bitcast float*** %table to i64*
  store i64 %2, i64* %3, align 8
  %4 = load i32, i32* %row, align 4
  %5 = load i32, i32* %T, align 4
  %add12 = add i32 %5, 1
  %cmp13 = icmp eq i32 %4, %add12
  br i1 %cmp13, label %if.end17, label %if.else16

if.else16:                                        ; preds = %do.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @373, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.5.382, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 130, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__PRETTY_FUNCTION__.LSH_recall_load, i64 0, i64 0)) #16
  unreachable

if.end17:                                         ; preds = %do.end
  %6 = load i32, i32* %col, align 4
  %7 = load i32, i32* %d_step, align 8
  %cmp19 = icmp eq i32 %6, %7
  br i1 %cmp19, label %return, label %if.else22

if.else22:                                        ; preds = %if.end17
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @374, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6.383, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.1.366, i64 0, i64 0), i32 131, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__PRETTY_FUNCTION__.LSH_recall_load, i64 0, i64 0)) #16
  unreachable

return:                                           ; preds = %if.end17, %entry
  %retval.0 = phi i32 [ -9995, %entry ], [ 0, %if.end17 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.379(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @375, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.384()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_float.380(float* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast float* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @376, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.384()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %buf, i64 %indvars.iv
  %2 = bitcast float* %arrayidx to i32*
  %3 = load i32, i32* %2, align 4
  %or13 = call i32 @llvm.bswap.i32(i32 %3)
  store i32 %or13, i32* %2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.384() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal float @dist_trivial_dist(i32 %n, i8* nocapture readnone %p1, i8* nocapture readnone %p2, i8* nocapture readnone %p3) #7 {
entry:
  ret float 0.000000e+00
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal float @__dist_L1_int32(i32 %D, i32* nocapture readonly %v1, i32* nocapture readonly %v2) #6 {
entry:
  %call = call fastcc i32 @dist_L1_int32_t(i32 %D, i32* %v1, i32* %v2)
  %conv = sitofp i32 %call to float
  ret float %conv
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @dist_L1_int32_t(i32 %D, i32* nocapture readonly %P1, i32* nocapture readonly %P2) unnamed_addr #6 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %result.0 = phi i32 [ %add, %for.body ], [ 0, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %P1, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %P2, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx3, align 4
  %sub = sub nsw i32 %0, %1
  %cmp4 = icmp sgt i32 %sub, -1
  %sub5 = sub nsw i32 0, %sub
  %sub.sub5 = select i1 %cmp4, i32 %sub, i32 %sub5
  %add = add nsw i32 %result.0, %sub.sub5
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %result.0
}

; Function Attrs: noinline nounwind uwtable
define internal float @__dist_L2_int32(i32 %D, i32* nocapture readonly %v1, i32* nocapture readonly %v2) #0 {
entry:
  %call = call fastcc i32 @dist_L2_int32_t(i32 %D, i32* %v1, i32* %v2)
  %conv = sitofp i32 %call to float
  ret float %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @dist_L2_int32_t(i32 %D, i32* nocapture readonly %P1, i32* nocapture readonly %P2) unnamed_addr #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %result.0 = phi i32 [ %add, %for.inc ], [ 0, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %P1, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %P2, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx3, align 4
  %sub = sub nsw i32 %0, %1
  %mul = mul nsw i32 %sub, %sub
  %add = add nsw i32 %result.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv = sitofp i32 %result.0 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @377, i32 0, i32 0))
  %call = call double @sqrt(double %conv) #11
  %conv4 = fptosi double %call to i32
  ret i32 %conv4
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal float @__dist_hamming(i32 %n, i8* nocapture readonly %c1, i8* nocapture readonly %c2) #6 {
entry:
  %call = call fastcc i32 @dist_hamming(i32 %n, i8* %c1, i8* %c2)
  %conv = sitofp i32 %call to float
  ret float %conv
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @dist_hamming(i32 %n, i8* nocapture readonly %c1, i8* nocapture readonly %c2) unnamed_addr #6 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %dist.0 = phi i32 [ %add, %for.inc ], [ 0, %entry ]
  %wide.trip.count = zext i32 %n to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8, i8* %c1, i64 %indvars.iv
  %0 = load i8, i8* %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds i8, i8* %c2, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx2, align 1
  %xor1 = xor i8 %0, %1
  %idxprom4 = zext i8 %xor1 to i64
  %arrayidx5 = getelementptr inbounds [257 x i32], [257 x i32]* @chunk_cnt, i64 0, i64 %idxprom4
  %2 = load i32, i32* %arrayidx5, align 4
  %add = add i32 %dist.0, %2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %dist.0
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal float @sdist_trivial(%struct.cass_dataset_t* nocapture readnone %ds1, i32 %p1, %struct.cass_dataset_t* nocapture readnone %ds2, i32 %p2, %struct.cass_vec_dist_t* nocapture readnone %vec_dist, i8* nocapture readnone %p) #7 {
entry:
  ret float 0.000000e+00
}

; Function Attrs: noinline nounwind uwtable
define internal float @sdist_single(%struct.cass_dataset_t* nocapture readonly %ds1, i32 %p1, %struct.cass_dataset_t* nocapture readonly %ds2, i32 %p2, %struct.cass_vec_dist_t* %vec_dist, i8* nocapture readnone %p) #0 {
entry:
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 6
  %0 = load i8*, i8** %vec, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 2
  %1 = load i32, i32* %vec_size, align 8
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 9
  %2 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %idxprom = zext i32 %p1 to i64
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 1
  %3 = load i32, i32* %start_vecid, align 4
  %mul = mul i32 %1, %3
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %vec1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 6
  %4 = load i8*, i8** %vec1, align 8
  %vec_size2 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 2
  %5 = load i32, i32* %vec_size2, align 8
  %vecset3 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 9
  %6 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset3, align 8
  %idxprom4 = zext i32 %p2 to i64
  %start_vecid6 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %6, i64 %idxprom4, i32 1
  %7 = load i32, i32* %start_vecid6, align 4
  %mul7 = mul i32 %5, %7
  %idx.ext8 = zext i32 %mul7 to i64
  %add.ptr9 = getelementptr i8, i8* %4, i64 %idx.ext8
  %__class = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %vec_dist, i64 0, i32 2
  %8 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %__class, align 8
  %dist = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %8, i64 0, i32 3
  %9 = load float (i32, i8*, i8*, i8*)*, float (i32, i8*, i8*, i8*)** %dist, align 8
  %vec_dim = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 3
  %10 = load i32, i32* %vec_dim, align 4
  %u = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %u10 = getelementptr inbounds i8, i8* %add.ptr9, i64 8
  %11 = bitcast %struct.cass_vec_dist_t* %vec_dist to i8*
  %call = call float %9(i32 %10, i8* %u, i8* %u10, i8* %11) #11
  ret float %call
}

; Function Attrs: noinline nounwind uwtable
define internal float @sdist_emd(%struct.cass_dataset_t* nocapture readonly %ds1, i32 %p1, %struct.cass_dataset_t* nocapture readonly %ds2, i32 %p2, %struct.cass_vec_dist_t* %vec_dist, i8* nocapture readnone %p) #0 {
entry:
  %sig1 = alloca %struct.signature_t, align 8
  %sig2 = alloca %struct.signature_t, align 8
  %vec_dim = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 3
  %0 = load i32, i32* %vec_dim, align 4
  %vec_dim1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 3
  %1 = load i32, i32* %vec_dim1, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @378, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.8.385, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.9.386, i64 0, i64 0), i32 308, i8* getelementptr inbounds ([121 x i8], [121 x i8]* @__PRETTY_FUNCTION__.sdist_emd, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 9
  %2 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %idxprom = zext i32 %p1 to i64
  %vecset3 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 9
  %3 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset3, align 8
  %idxprom4 = zext i32 %p2 to i64
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 0
  %4 = load i32, i32* %num_regions, align 4
  %n = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig1, i64 0, i32 0
  store i32 %4, i32* %n, align 8
  %num_regions6 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %3, i64 %idxprom4, i32 0
  %5 = load i32, i32* %num_regions6, align 4
  %n7 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig2, i64 0, i32 0
  store i32 %5, i32* %n7, align 8
  %conv = sext i32 %4 to i64
  %6 = alloca i8*, i64 %conv, align 16
  %Features = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig1, i64 0, i32 1
  store i8** %6, i8*** %Features, align 8
  %7 = alloca float, i64 %conv, align 16
  %Weights = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig1, i64 0, i32 2
  store float* %7, float** %Weights, align 8
  %conv13 = sext i32 %5 to i64
  %8 = alloca i8*, i64 %conv13, align 16
  %Features15 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig2, i64 0, i32 1
  store i8** %8, i8*** %Features15, align 8
  %9 = alloca float, i64 %conv13, align 16
  %Weights19 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %sig2, i64 0, i32 2
  store float* %9, float** %Weights19, align 8
  %vec20 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 6
  %10 = load i8*, i8** %vec20, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 2
  %11 = load i32, i32* %vec_size, align 8
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 1
  %12 = load i32, i32* %start_vecid, align 4
  %mul21 = mul i32 %11, %12
  %idx.ext = zext i32 %mul21 to i64
  %add.ptr = getelementptr i8, i8* %10, i64 %idx.ext
  %13 = sext i32 %4 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc ], [ 0, %if.end ]
  %vec.0.in = phi i8* [ %add.ptr33, %for.inc ], [ %add.ptr, %if.end ]
  %cmp23 = icmp slt i64 %indvars.iv1, %13
  br i1 %cmp23, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %u = getelementptr inbounds i8, i8* %vec.0.in, i64 8
  %arrayidx27 = getelementptr inbounds i8*, i8** %6, i64 %indvars.iv1
  store i8* %u, i8** %arrayidx27, align 8
  %14 = bitcast i8* %vec.0.in to i32*
  %15 = load i32, i32* %14, align 4
  %arrayidx30 = getelementptr inbounds float, float* %7, i64 %indvars.iv1
  %16 = bitcast float* %arrayidx30 to i32*
  store i32 %15, i32* %16, align 4
  %idx.ext32 = zext i32 %11 to i64
  %add.ptr33 = getelementptr i8, i8* %vec.0.in, i64 %idx.ext32
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %vec34 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 6
  %17 = load i8*, i8** %vec34, align 8
  %vec_size35 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 2
  %18 = load i32, i32* %vec_size35, align 8
  %start_vecid36 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %3, i64 %idxprom4, i32 1
  %19 = load i32, i32* %start_vecid36, align 4
  %mul37 = mul i32 %18, %19
  %idx.ext38 = zext i32 %mul37 to i64
  %add.ptr39 = getelementptr i8, i8* %17, i64 %idx.ext38
  %20 = sext i32 %5 to i64
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc58, %for.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc58 ], [ 0, %for.end ]
  %vec.1.in = phi i8* [ %add.ptr57, %for.inc58 ], [ %add.ptr39, %for.end ]
  %cmp42 = icmp slt i64 %indvars.iv, %20
  br i1 %cmp42, label %for.inc58, label %for.end60

for.inc58:                                        ; preds = %for.cond40
  %u45 = getelementptr inbounds i8, i8* %vec.1.in, i64 8
  %arrayidx50 = getelementptr inbounds i8*, i8** %8, i64 %indvars.iv
  store i8* %u45, i8** %arrayidx50, align 8
  %21 = bitcast i8* %vec.1.in to i32*
  %22 = load i32, i32* %21, align 4
  %arrayidx54 = getelementptr inbounds float, float* %9, i64 %indvars.iv
  %23 = bitcast float* %arrayidx54 to i32*
  store i32 %22, i32* %23, align 4
  %idx.ext56 = zext i32 %18 to i64
  %add.ptr57 = getelementptr i8, i8* %vec.1.in, i64 %idx.ext56
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond40

for.end60:                                        ; preds = %for.cond40
  %__class = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %vec_dist, i64 0, i32 2
  %24 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %__class, align 8
  %dist = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %24, i64 0, i32 3
  %25 = load float (i32, i8*, i8*, i8*)*, float (i32, i8*, i8*, i8*)** %dist, align 8
  %26 = load i32, i32* %vec_dim, align 4
  %27 = bitcast %struct.cass_vec_dist_t* %vec_dist to i8*
  %call = call fastcc float @emd(%struct.signature_t* nonnull %sig1, %struct.signature_t* nonnull %sig2, float (i32, i8*, i8*, i8*)* %25, i32 %26, i8* %27)
  ret float %call
}

; Function Attrs: noinline nounwind uwtable
define internal float @sdist_myemd(%struct.cass_dataset_t* nocapture readonly %ds1, i32 %p1, %struct.cass_dataset_t* nocapture readonly %ds2, i32 %p2, %struct.cass_vec_dist_t* %vec_dist, i8* nocapture readnone %p) #0 {
entry:
  %vec_dim = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 3
  %0 = load i32, i32* %vec_dim, align 4
  %vec_dim1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 3
  %1 = load i32, i32* %vec_dim1, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @379, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.8.385, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.9.386, i64 0, i64 0), i32 367, i8* getelementptr inbounds ([123 x i8], [123 x i8]* @__PRETTY_FUNCTION__.sdist_myemd, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 9
  %2 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %idxprom = zext i32 %p1 to i64
  %vecset3 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 9
  %3 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset3, align 8
  %idxprom4 = zext i32 %p2 to i64
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 0
  %4 = load i32, i32* %num_regions, align 4
  %num_regions6 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %3, i64 %idxprom4, i32 0
  %5 = load i32, i32* %num_regions6, align 4
  %add = add nsw i32 %4, 1
  %conv = sext i32 %add to i64
  %6 = alloca float, i64 %conv, align 16
  %add7 = add nsw i32 %5, 1
  %conv8 = sext i32 %add7 to i64
  %7 = alloca float, i64 %conv8, align 16
  %vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 6
  %8 = load i8*, i8** %vec, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds1, i64 0, i32 2
  %9 = load i32, i32* %vec_size, align 8
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %2, i64 %idxprom, i32 1
  %10 = load i32, i32* %start_vecid, align 4
  %mul10 = mul i32 %9, %10
  %idx.ext = zext i32 %mul10 to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  %11 = sext i32 %4 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %indvars.iv6 = phi i64 [ %indvars.iv.next7, %for.inc ], [ 0, %if.end ]
  %vec1.0.in = phi i8* [ %add.ptr20, %for.inc ], [ %add.ptr, %if.end ]
  %srow.0 = phi float [ %add17, %for.inc ], [ 0.000000e+00, %if.end ]
  %cmp11 = icmp slt i64 %indvars.iv6, %11
  br i1 %cmp11, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %12 = bitcast i8* %vec1.0.in to i32*
  %13 = load i32, i32* %12, align 4
  %arrayidx14 = getelementptr inbounds float, float* %6, i64 %indvars.iv6
  %14 = bitcast float* %arrayidx14 to i32*
  store i32 %13, i32* %14, align 4
  %idx.ext19 = zext i32 %9 to i64
  %add.ptr20 = getelementptr i8, i8* %vec1.0.in, i64 %idx.ext19
  %15 = bitcast i32 %13 to float
  %add17 = fadd float %srow.0, %15
  %indvars.iv.next7 = add nuw nsw i64 %indvars.iv6, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %vec21 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 6
  %16 = load i8*, i8** %vec21, align 8
  %vec_size22 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds2, i64 0, i32 2
  %17 = load i32, i32* %vec_size22, align 8
  %start_vecid23 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %3, i64 %idxprom4, i32 1
  %18 = load i32, i32* %start_vecid23, align 4
  %mul24 = mul i32 %17, %18
  %idx.ext25 = zext i32 %mul24 to i64
  %add.ptr26 = getelementptr i8, i8* %16, i64 %idx.ext25
  %19 = sext i32 %5 to i64
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc40, %for.end
  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %for.inc40 ], [ 0, %for.end ]
  %vec2.0.in = phi i8* [ %add.ptr39, %for.inc40 ], [ %add.ptr26, %for.end ]
  %scol.0 = phi float [ %add36, %for.inc40 ], [ 0.000000e+00, %for.end ]
  %cmp28 = icmp slt i64 %indvars.iv4, %19
  br i1 %cmp28, label %for.inc40, label %for.end42

for.inc40:                                        ; preds = %for.cond27
  %20 = bitcast i8* %vec2.0.in to i32*
  %21 = load i32, i32* %20, align 4
  %arrayidx33 = getelementptr inbounds float, float* %7, i64 %indvars.iv4
  %22 = bitcast float* %arrayidx33 to i32*
  store i32 %21, i32* %22, align 4
  %idx.ext38 = zext i32 %17 to i64
  %add.ptr39 = getelementptr i8, i8* %vec2.0.in, i64 %idx.ext38
  %23 = bitcast i32 %21 to float
  %add36 = fadd float %scol.0, %23
  %indvars.iv.next5 = add nuw nsw i64 %indvars.iv4, 1
  br label %for.cond27

for.end42:                                        ; preds = %for.cond27
  %call = call fastcc i8** @__matrix_alloc(i32 %add, i32 %add7, i32 4)
  %24 = load i8*, i8** %vec, align 8
  %25 = load i32, i32* %vec_size, align 8
  %26 = load i32, i32* %start_vecid, align 4
  %mul48 = mul i32 %25, %26
  %idx.ext49 = zext i32 %mul48 to i64
  %add.ptr50 = getelementptr i8, i8* %24, i64 %idx.ext49
  %__class = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %vec_dist, i64 0, i32 2
  %27 = bitcast %struct.cass_vec_dist_t* %vec_dist to i8*
  %28 = sext i32 %5 to i64
  %29 = sext i32 %4 to i64
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc83, %for.end42
  %indvars.iv2 = phi i64 [ %indvars.iv.next3, %for.inc83 ], [ 0, %for.end42 ]
  %vec1.1.in = phi i8* [ %add.ptr82, %for.inc83 ], [ %add.ptr50, %for.end42 ]
  %cmp52 = icmp slt i64 %indvars.iv2, %29
  br i1 %cmp52, label %for.body54, label %for.end85

for.body54:                                       ; preds = %for.cond51
  %30 = load i8*, i8** %vec21, align 8
  %31 = load i32, i32* %vec_size22, align 8
  %32 = load i32, i32* %start_vecid23, align 4
  %mul58 = mul i32 %31, %32
  %idx.ext59 = zext i32 %mul58 to i64
  %add.ptr60 = getelementptr i8, i8* %30, i64 %idx.ext59
  %u = getelementptr inbounds i8, i8* %vec1.1.in, i64 8
  %arrayidx711 = getelementptr inbounds i8*, i8** %call, i64 %indvars.iv2
  %arrayidx71 = bitcast i8** %arrayidx711 to float**
  br label %for.cond61

for.cond61:                                       ; preds = %for.inc77, %for.body54
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc77 ], [ 0, %for.body54 ]
  %vec2.1.in = phi i8* [ %add.ptr76, %for.inc77 ], [ %add.ptr60, %for.body54 ]
  %cmp62 = icmp slt i64 %indvars.iv, %28
  br i1 %cmp62, label %for.inc77, label %for.inc83

for.inc77:                                        ; preds = %for.cond61
  %33 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %__class, align 8
  %dist = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %33, i64 0, i32 3
  %34 = load float (i32, i8*, i8*, i8*)*, float (i32, i8*, i8*, i8*)** %dist, align 8
  %35 = load i32, i32* %vec_dim, align 4
  %u66 = getelementptr inbounds i8, i8* %vec2.1.in, i64 8
  %call69 = call float %34(i32 %35, i8* %u, i8* %u66, i8* %27) #11
  %36 = load float*, float** %arrayidx71, align 8
  %arrayidx73 = getelementptr inbounds float, float* %36, i64 %indvars.iv
  store float %call69, float* %arrayidx73, align 4
  %37 = load i32, i32* %vec_size22, align 8
  %idx.ext75 = zext i32 %37 to i64
  %add.ptr76 = getelementptr i8, i8* %vec2.1.in, i64 %idx.ext75
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond61

for.inc83:                                        ; preds = %for.cond61
  %38 = load i32, i32* %vec_size, align 8
  %idx.ext81 = zext i32 %38 to i64
  %add.ptr82 = getelementptr i8, i8* %vec1.1.in, i64 %idx.ext81
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1
  br label %for.cond51

for.end85:                                        ; preds = %for.cond51
  %39 = bitcast i8** %call to float**
  %cmp86 = fcmp ogt float %srow.0, %scol.0
  br i1 %cmp86, label %if.then88, label %if.else99

if.then88:                                        ; preds = %for.end85
  %sub = fsub float %srow.0, %scol.0
  %idxprom89 = sext i32 %5 to i64
  %arrayidx90 = getelementptr inbounds float, float* %7, i64 %idxprom89
  store float %sub, float* %arrayidx90, align 4
  %cmp94 = fcmp ogt float %sub, 0.000000e+00
  br i1 %cmp94, label %if.then96, label %if.end111

if.then96:                                        ; preds = %if.then88
  br label %if.end111

if.else99:                                        ; preds = %for.end85
  %sub100 = fsub float %scol.0, %srow.0
  %idxprom101 = sext i32 %4 to i64
  %arrayidx102 = getelementptr inbounds float, float* %6, i64 %idxprom101
  store float %sub100, float* %arrayidx102, align 4
  %cmp106 = fcmp ogt float %sub100, 0.000000e+00
  br i1 %cmp106, label %if.then108, label %if.end111

if.then108:                                       ; preds = %if.else99
  br label %if.end111

if.end111:                                        ; preds = %if.else99, %if.then108, %if.then88, %if.then96
  %ss.0 = phi float [ %scol.0, %if.then96 ], [ %scol.0, %if.then88 ], [ %srow.0, %if.then108 ], [ %srow.0, %if.else99 ]
  %nrow.1 = phi i32 [ %4, %if.then96 ], [ %4, %if.then88 ], [ %add, %if.then108 ], [ %4, %if.else99 ]
  %ncol.1 = phi i32 [ %add7, %if.then96 ], [ %5, %if.then88 ], [ %5, %if.then108 ], [ %5, %if.else99 ]
  %call112 = call fastcc float @tp_solve(i32 %nrow.1, float* nonnull %6, i32 %ncol.1, float* nonnull %7, float** %39)
  call fastcc void @__matrix_free(i8** %call)
  %div = fdiv float %call112, %ss.0
  ret float %div
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_simple_describe(i8* nocapture readonly %_dist, %struct._IO_FILE* nocapture %fout) #0 {
entry:
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %0 = bitcast i8* %name to i8**
  %1 = load i8*, i8** %0, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @380, i32 0, i32 0))
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %fout, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12.390, i64 0, i64 0), i8* %1)
  %__class = getelementptr inbounds i8, i8* %_dist, i64 16
  %2 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  %3 = load %struct._cass_vec_dist_class*, %struct._cass_vec_dist_class** %2, align 8
  %name1 = getelementptr inbounds %struct._cass_vec_dist_class, %struct._cass_vec_dist_class* %3, i64 0, i32 0
  %4 = load i8*, i8** %name1, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @381, i32 0, i32 0))
  %call2 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %fout, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.13.391, i64 0, i64 0), i8* %4)
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_trivial_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @382, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_trivial, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_simple_checkpoint(i8* nocapture readonly %_dist, %struct._IO_FILE* nocapture readnone %fout) #0 {
entry:
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %0 = bitcast i8* %name to i8**
  %1 = load i8*, i8** %0, align 8
  %call = call fastcc i32 @cass_write_pchar(i8* %1, %struct._IO_FILE* %fout)
  ret i32 %call
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_trivial_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_trivial_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @383, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal void @dist_simple_free(i8* nocapture %_dist) #0 {
entry:
  %refcnt = bitcast i8* %_dist to i32*
  %0 = load i32, i32* %refcnt, align 8
  %dec = add i32 %0, -1
  store i32 %dec, i32* %refcnt, align 8
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %1 = bitcast i8* %name to i8**
  %2 = load i8*, i8** %1, align 8
  %cmp2 = icmp eq i8* %2, null
  br i1 %cmp2, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @384, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @385, i32 0, i32 0))
  call void @free(i8* %_dist) #11
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L1_int_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @386, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_L1_int, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L1_int_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_L1_int_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @387, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L2_int_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @388, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_L2_int, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L2_int_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_L2_int_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @389, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal float @dist_L1_float(i32 %D, float* nocapture readonly %P1, float* nocapture readonly %P2) #6 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %result.0 = phi float [ %add, %for.body ], [ 0.000000e+00, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %P1, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds float, float* %P2, i64 %indvars.iv
  %1 = load float, float* %arrayidx3, align 4
  %sub = fsub float %0, %1
  %cmp4 = fcmp ult float %sub, 0.000000e+00
  %sub5 = fsub float -0.000000e+00, %sub
  %cond = select i1 %cmp4, float %sub5, float %sub
  %add = fadd float %result.0, %cond
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret float %result.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L1_float_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @390, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_L1_float, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L1_float_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_L1_float_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @391, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal float @dist_L2_float(i32 %D, float* nocapture readonly %P1, float* nocapture readonly %P2) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %result.0 = phi float [ %add, %for.inc ], [ 0.000000e+00, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %P1, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds float, float* %P2, i64 %indvars.iv
  %1 = load float, float* %arrayidx3, align 4
  %sub = fsub float %0, %1
  %mul = fmul float %sub, %sub
  %add = fadd float %result.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @392, i32 0, i32 0))
  %sqrtf = call float @sqrtf(float %result.0) #1
  ret float %sqrtf
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L2_float_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @393, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_L2_float, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_L2_float_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_L2_float_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @394, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal float @dist_cos_float(i32 %D, float* nocapture readonly %P1, float* nocapture readonly %P2) #6 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %result.0 = phi float [ %add, %for.inc ], [ 0.000000e+00, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %P1, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds float, float* %P2, i64 %indvars.iv
  %1 = load float, float* %arrayidx2, align 4
  %mul = fmul float %0, %1
  %add = fadd float %result.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret float %result.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_cos_float_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @395, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_cos_float, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_cos_float_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_cos_float_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @396, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_hamming_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @397, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 16
  %0 = bitcast i8* %__class to %struct._cass_vec_dist_class**
  store %struct._cass_vec_dist_class* @vec_dist_hamming, %struct._cass_vec_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @dist_hamming_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @dist_hamming_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vec_dist_t**
  %1 = load %struct.cass_vec_dist_t*, %struct.cass_vec_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vec_dist_t, %struct.cass_vec_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vec_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @398, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_simple_describe(i8* nocapture readonly %_dist, %struct._IO_FILE* nocapture %fout) #0 {
entry:
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %0 = bitcast i8* %name to i8**
  %1 = load i8*, i8** %0, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @399, i32 0, i32 0))
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %fout, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12.390, i64 0, i64 0), i8* %1)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @400, i32 0, i32 0))
  %2 = call i64 @fwrite(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.14.412, i64 0, i64 0), i64 15, i64 1, %struct._IO_FILE* %fout)
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_trivial_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @401, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 32, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 24
  %0 = bitcast i8* %__class to %struct._cass_vecset_dist_class**
  store %struct._cass_vecset_dist_class* @vecset_dist_trivial, %struct._cass_vecset_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_simple_checkpoint(i8* nocapture readonly %_dist, %struct._IO_FILE* nocapture readnone %fout) #0 {
entry:
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %0 = bitcast i8* %name to i8**
  %1 = load i8*, i8** %0, align 8
  %call = call fastcc i32 @cass_write_pchar(i8* %1, %struct._IO_FILE* %fout)
  ret i32 %call
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_trivial_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @sdist_trivial_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vecset_dist_t**
  %1 = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vecset_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @402, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal void @sdist_simple_free(i8* nocapture %_dist) #0 {
entry:
  %refcnt = bitcast i8* %_dist to i32*
  %0 = load i32, i32* %refcnt, align 8
  %dec = add i32 %0, -1
  store i32 %dec, i32* %refcnt, align 8
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %name = getelementptr inbounds i8, i8* %_dist, i64 8
  %1 = bitcast i8* %name to i8**
  %2 = load i8*, i8** %1, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @403, i32 0, i32 0))
  call void @free(i8* %2) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @404, i32 0, i32 0))
  call void @free(i8* %_dist) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_single_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @405, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 32, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 24
  %0 = bitcast i8* %__class to %struct._cass_vecset_dist_class**
  store %struct._cass_vecset_dist_class* @vecset_dist_single, %struct._cass_vecset_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_single_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @sdist_single_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vecset_dist_t**
  %1 = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vecset_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @406, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_emd_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @407, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 32, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 24
  %0 = bitcast i8* %__class to %struct._cass_vecset_dist_class**
  store %struct._cass_vecset_dist_class* @vecset_dist_emd, %struct._cass_vecset_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_emd_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @sdist_emd_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vecset_dist_t**
  %1 = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vecset_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @408, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_myemd_construct(i8** nocapture %_dist, i8* nocapture readnone %param) #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @409, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 32, i64 1) #11
  %refcnt = bitcast i8* %call to i32*
  store i32 1, i32* %refcnt, align 8
  %__class = getelementptr inbounds i8, i8* %call, i64 24
  %0 = bitcast i8* %__class to %struct._cass_vecset_dist_class**
  store %struct._cass_vecset_dist_class* @vecset_dist_myemd, %struct._cass_vecset_dist_class** %0, align 8
  store i8* %call, i8** %_dist, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @sdist_myemd_restore(i8** nocapture %_dist, %struct._IO_FILE* nocapture %fin) #0 {
entry:
  %call = call i32 @sdist_myemd_construct(i8** %_dist, i8* null)
  %0 = bitcast i8** %_dist to %struct.cass_vecset_dist_t**
  %1 = load %struct.cass_vecset_dist_t*, %struct.cass_vecset_dist_t** %0, align 8
  %call1 = call fastcc i8* @cass_read_pchar(%struct._IO_FILE* %fin)
  %name = getelementptr inbounds %struct.cass_vecset_dist_t, %struct.cass_vecset_dist_t* %1, i64 0, i32 1
  store i8* %call1, i8** %name, align 8
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.cass_vecset_dist_t* %1 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @410, i32 0, i32 0))
  call void @free(i8* %2) #11
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ -9995, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc float @tp_cost(i32 %nrow, i32 %ncol, float** nocapture readonly %cost, %struct.sol** nocapture readonly %sol) unnamed_addr #6 {
entry:
  %0 = sext i32 %ncol to i64
  %1 = sext i32 %nrow to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc14, %entry
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc14 ], [ 0, %entry ]
  %c.0 = phi float [ %c.1, %for.inc14 ], [ 0.000000e+00, %entry ]
  %cmp = icmp slt i64 %indvars.iv1, %1
  br i1 %cmp, label %for.cond1.preheader, label %for.end16

for.cond1.preheader:                              ; preds = %for.cond
  %arrayidx = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %indvars.iv1
  %arrayidx7 = getelementptr inbounds float*, float** %cost, i64 %indvars.iv1
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]
  %c.1 = phi float [ %c.0, %for.cond1.preheader ], [ %c.2, %for.inc ]
  %cmp2 = icmp slt i64 %indvars.iv, %0
  br i1 %cmp2, label %for.body3, label %for.inc14

for.body3:                                        ; preds = %for.cond1
  %2 = load %struct.sol*, %struct.sol** %arrayidx, align 8
  %flow = getelementptr inbounds %struct.sol, %struct.sol* %2, i64 %indvars.iv, i32 3
  %3 = load i32, i32* %flow, align 4
  %tobool = icmp eq i32 %3, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body3
  %4 = load float*, float** %arrayidx7, align 8
  %arrayidx9 = getelementptr inbounds float, float* %4, i64 %indvars.iv
  %5 = load float, float* %arrayidx9, align 4
  %value = getelementptr inbounds %struct.sol, %struct.sol* %2, i64 %indvars.iv, i32 2
  %6 = load float, float* %value, align 8
  %mul = fmul float %5, %6
  %add = fadd float %c.1, %mul
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body3
  %c.2 = phi float [ %add, %if.then ], [ %c.1, %for.body3 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond1

for.inc14:                                        ; preds = %for.cond1
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end16:                                        ; preds = %for.cond
  ret float %c.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @tp_solve(i32 %nrow, float* nocapture %row, i32 %ncol, float* nocapture %col, float** nocapture readonly %cost) unnamed_addr #0 {
entry:
  %sol = alloca %struct.sol**, align 8
  call fastcc void @tp_init_vogel(i32 %nrow, float* %row, i32 %ncol, float* %col, float** %cost, %struct.sol*** nonnull %sol)
  %conv = sext i32 %nrow to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @411, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 16, i64 %conv) #11
  %0 = bitcast i8* %call to %struct.U*
  %conv1 = sext i32 %ncol to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @412, i32 0, i32 0))
  %call2 = call noalias i8* @calloc(i64 16, i64 %conv1) #11
  %1 = bitcast i8* %call2 to %struct.U*
  %2 = load %struct.sol**, %struct.sol*** %sol, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %entry
  %call3 = call fastcc i32 @tp_update(i32 %nrow, i32 %ncol, float** %cost, %struct.sol** %2, %struct.U* %0, %struct.U* %1)
  %tobool = icmp eq i32 %call3, 0
  br i1 %tobool, label %for.cond, label %for.end

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @413, i32 0, i32 0))
  call void @free(i8* %call) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @414, i32 0, i32 0))
  call void @free(i8* %call2) #11
  %call4 = call fastcc float @tp_cost(i32 %nrow, i32 %ncol, float** %cost, %struct.sol** %2)
  %.cast = bitcast %struct.sol** %2 to i8**
  call fastcc void @__matrix_free(i8** %.cast)
  ret float %call4
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @tp_init_vogel(i32 %nrow, float* nocapture %row, i32 %ncol, float* nocapture %col, float** nocapture readonly %cost, %struct.sol*** nocapture %_sol) unnamed_addr #0 {
do.end4:
  %conv = sext i32 %nrow to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @415, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 1, i64 %conv) #11
  %conv2 = sext i32 %ncol to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @416, i32 0, i32 0))
  %call3 = call noalias i8* @calloc(i64 1, i64 %conv2) #11
  %call5 = call fastcc i8** @__matrix_alloc(i32 %nrow, i32 %ncol, i32 40)
  %0 = sext i32 %ncol to i64
  %1 = sext i32 %nrow to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc23, %do.end4
  %indvars.iv124 = phi i64 [ %indvars.iv.next125, %for.inc23 ], [ 0, %do.end4 ]
  %cmp = icmp slt i64 %indvars.iv124, %1
  br i1 %cmp, label %for.cond7.preheader, label %while.cond.preheader

for.cond7.preheader:                              ; preds = %for.cond
  %arrayidx9 = getelementptr inbounds i8*, i8** %call5, i64 %indvars.iv124
  %arrayidx = bitcast i8** %arrayidx9 to %struct.sol**
  br label %for.cond7

while.cond.preheader:                             ; preds = %for.cond
  %2 = sext i32 %ncol to i64
  %3 = sext i32 %nrow to i64
  %4 = sext i32 %nrow to i64
  %5 = sext i32 %ncol to i64
  br label %while.cond.outer

for.cond7:                                        ; preds = %for.cond7.preheader, %for.inc
  %indvars.iv122 = phi i64 [ 0, %for.cond7.preheader ], [ %indvars.iv.next123, %for.inc ]
  %cmp8 = icmp slt i64 %indvars.iv122, %0
  br i1 %cmp8, label %for.inc, label %for.inc23

for.inc:                                          ; preds = %for.cond7
  %6 = load %struct.sol*, %struct.sol** %arrayidx, align 8
  %i13 = getelementptr inbounds %struct.sol, %struct.sol* %6, i64 %indvars.iv122, i32 0
  %7 = trunc i64 %indvars.iv124 to i32
  store i32 %7, i32* %i13, align 8
  %8 = load %struct.sol*, %struct.sol** %arrayidx, align 8
  %j18 = getelementptr inbounds %struct.sol, %struct.sol* %8, i64 %indvars.iv122, i32 1
  %9 = trunc i64 %indvars.iv122 to i32
  store i32 %9, i32* %j18, align 4
  %10 = load %struct.sol*, %struct.sol** %arrayidx, align 8
  %flow = getelementptr inbounds %struct.sol, %struct.sol* %10, i64 %indvars.iv122, i32 3
  store i32 0, i32* %flow, align 4
  %indvars.iv.next123 = add nuw nsw i64 %indvars.iv122, 1
  br label %for.cond7

for.inc23:                                        ; preds = %for.cond7
  %indvars.iv.next125 = add nuw nsw i64 %indvars.iv124, 1
  br label %for.cond

while.cond:                                       ; preds = %while.cond.outer, %do.end235
  %lr.0 = phi i32 [ %dec, %do.end235 ], [ %lr.0.ph, %while.cond.outer ]
  %add = add nsw i32 %lr.0, %lc.0.ph
  %cmp26 = icmp sgt i32 %add, 2
  br i1 %cmp26, label %for.cond28, label %while.end

for.cond28:                                       ; preds = %while.cond, %for.inc92
  %indvars.iv116 = phi i64 [ %indvars.iv.next117, %for.inc92 ], [ 0, %while.cond ]
  %mcol.1 = phi i32 [ %mcol.4, %for.inc92 ], [ -1, %while.cond ]
  %mrow.0 = phi i32 [ %mrow.3, %for.inc92 ], [ -1, %while.cond ]
  %max.0 = phi float [ %max.3, %for.inc92 ], [ 0.000000e+00, %while.cond ]
  %cmp29 = icmp slt i64 %indvars.iv116, %3
  br i1 %cmp29, label %for.body31, label %for.cond95

for.body31:                                       ; preds = %for.cond28
  %arrayidx33 = getelementptr inbounds i8, i8* %call, i64 %indvars.iv116
  %11 = load i8, i8* %arrayidx33, align 1
  %tobool = icmp eq i8 %11, 0
  br i1 %tobool, label %for.cond34.preheader, label %for.inc92

for.cond34.preheader:                             ; preds = %for.body31
  %arrayidx62 = getelementptr inbounds float*, float** %cost, i64 %indvars.iv116
  br label %for.cond34

for.cond34:                                       ; preds = %for.cond34.preheader, %for.inc71
  %indvars.iv114 = phi i64 [ 0, %for.cond34.preheader ], [ %indvars.iv.next115, %for.inc71 ]
  %m1.0 = phi float [ 0.000000e+00, %for.cond34.preheader ], [ %m1.3, %for.inc71 ]
  %m2.0 = phi float [ 0.000000e+00, %for.cond34.preheader ], [ %m2.3, %for.inc71 ]
  %m1_idx.0 = phi i32 [ -1, %for.cond34.preheader ], [ %m1_idx.3, %for.inc71 ]
  %m2_idx.0 = phi i32 [ -1, %for.cond34.preheader ], [ %m2_idx.3, %for.inc71 ]
  %cmp35 = icmp slt i64 %indvars.iv114, %2
  br i1 %cmp35, label %for.body37, label %for.end73

for.body37:                                       ; preds = %for.cond34
  %arrayidx39 = getelementptr inbounds i8, i8* %call3, i64 %indvars.iv114
  %12 = load i8, i8* %arrayidx39, align 1
  %tobool40 = icmp eq i8 %12, 0
  br i1 %tobool40, label %if.then41, label %for.inc71

if.then41:                                        ; preds = %for.body37
  %cmp42 = icmp slt i32 %m2_idx.0, 0
  br i1 %cmp42, label %if.then50, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then41
  %13 = load float*, float** %arrayidx62, align 8
  %arrayidx47 = getelementptr inbounds float, float* %13, i64 %indvars.iv114
  %14 = load float, float* %arrayidx47, align 4
  %cmp48 = fcmp olt float %14, %m2.0
  br i1 %cmp48, label %if.then50, label %for.inc71

if.then50:                                        ; preds = %lor.lhs.false, %if.then41
  %cmp51 = icmp slt i32 %m1_idx.0, 0
  %.pre59 = load float*, float** %arrayidx62, align 8
  %arrayidx64.phi.trans.insert = getelementptr inbounds float, float* %.pre59, i64 %indvars.iv114
  %.pre60 = load float, float* %arrayidx64.phi.trans.insert, align 4
  %cmp58 = fcmp olt float %.pre60, %m1.0
  %or.cond = or i1 %cmp51, %cmp58
  %15 = trunc i64 %indvars.iv114 to i32
  %.pre60.m1.0 = select i1 %or.cond, float %.pre60, float %m1.0
  %m1.0..pre60 = select i1 %or.cond, float %m1.0, float %.pre60
  %.m1_idx.0 = select i1 %or.cond, i32 %15, i32 %m1_idx.0
  %m1_idx.0. = select i1 %or.cond, i32 %m1_idx.0, i32 %15
  br label %for.inc71

for.inc71:                                        ; preds = %if.then50, %for.body37, %lor.lhs.false
  %m1.3 = phi float [ %m1.0, %for.body37 ], [ %m1.0, %lor.lhs.false ], [ %.pre60.m1.0, %if.then50 ]
  %m2.3 = phi float [ %m2.0, %for.body37 ], [ %m2.0, %lor.lhs.false ], [ %m1.0..pre60, %if.then50 ]
  %m1_idx.3 = phi i32 [ %m1_idx.0, %for.body37 ], [ %m1_idx.0, %lor.lhs.false ], [ %.m1_idx.0, %if.then50 ]
  %m2_idx.3 = phi i32 [ %m2_idx.0, %for.body37 ], [ %m2_idx.0, %lor.lhs.false ], [ %m1_idx.0., %if.then50 ]
  %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1
  br label %for.cond34

for.end73:                                        ; preds = %for.cond34
  %cmp74 = icmp sgt i32 %m1_idx.0, -1
  br i1 %cmp74, label %if.end78, label %if.else77

if.else77:                                        ; preds = %for.end73
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @417, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.6.433, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 197, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end78:                                         ; preds = %for.end73
  %cmp79 = icmp slt i32 %m2_idx.0, 0
  br i1 %cmp79, label %for.inc92, label %if.end82

if.end82:                                         ; preds = %if.end78
  %cmp83 = icmp slt i32 %mrow.0, 0
  %.pre61 = fsub float %m2.0, %m1.0
  %cmp86 = fcmp ogt float %.pre61, %max.0
  %or.cond126 = or i1 %cmp83, %cmp86
  %16 = trunc i64 %indvars.iv116 to i32
  %m1_idx.0.mcol.1 = select i1 %or.cond126, i32 %m1_idx.0, i32 %mcol.1
  %.mrow.0 = select i1 %or.cond126, i32 %16, i32 %mrow.0
  %.pre61.max.0 = select i1 %or.cond126, float %.pre61, float %max.0
  br label %for.inc92

for.inc92:                                        ; preds = %if.end82, %for.body31, %if.end78
  %mcol.4 = phi i32 [ %mcol.1, %if.end78 ], [ %mcol.1, %for.body31 ], [ %m1_idx.0.mcol.1, %if.end82 ]
  %mrow.3 = phi i32 [ %mrow.0, %if.end78 ], [ %mrow.0, %for.body31 ], [ %.mrow.0, %if.end82 ]
  %max.3 = phi float [ %max.0, %if.end78 ], [ %max.0, %for.body31 ], [ %.pre61.max.0, %if.end82 ]
  %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1
  br label %for.cond28

for.cond95:                                       ; preds = %for.cond28, %for.inc169
  %indvars.iv120 = phi i64 [ %indvars.iv.next121, %for.inc169 ], [ 0, %for.cond28 ]
  %mcol.5 = phi i32 [ %mcol.8, %for.inc169 ], [ %mcol.1, %for.cond28 ]
  %mrow.4 = phi i32 [ %mrow.7, %for.inc169 ], [ %mrow.0, %for.cond28 ]
  %max.4 = phi float [ %max.7, %for.inc169 ], [ %max.0, %for.cond28 ]
  %cmp96 = icmp slt i64 %indvars.iv120, %5
  br i1 %cmp96, label %for.body98, label %for.end171

for.body98:                                       ; preds = %for.cond95
  %arrayidx100 = getelementptr inbounds i8, i8* %call3, i64 %indvars.iv120
  %17 = load i8, i8* %arrayidx100, align 1
  %tobool101 = icmp eq i8 %17, 0
  br i1 %tobool101, label %for.cond107, label %for.inc169

for.cond107:                                      ; preds = %for.body98, %for.inc147
  %indvars.iv118 = phi i64 [ %indvars.iv.next119, %for.inc147 ], [ 0, %for.body98 ]
  %m1103.0 = phi float [ %m1103.3, %for.inc147 ], [ 0.000000e+00, %for.body98 ]
  %m2104.0 = phi float [ %m2104.3, %for.inc147 ], [ 0.000000e+00, %for.body98 ]
  %m1_idx105.0 = phi i32 [ %m1_idx105.3, %for.inc147 ], [ -1, %for.body98 ]
  %m2_idx106.0 = phi i32 [ %m2_idx106.3, %for.inc147 ], [ -1, %for.body98 ]
  %cmp108 = icmp slt i64 %indvars.iv118, %4
  br i1 %cmp108, label %for.body110, label %for.end149

for.body110:                                      ; preds = %for.cond107
  %arrayidx112 = getelementptr inbounds i8, i8* %call, i64 %indvars.iv118
  %18 = load i8, i8* %arrayidx112, align 1
  %tobool113 = icmp eq i8 %18, 0
  br i1 %tobool113, label %if.then114, label %for.inc147

if.then114:                                       ; preds = %for.body110
  %cmp115 = icmp slt i32 %m2_idx106.0, 0
  br i1 %cmp115, label %if.then124, label %lor.lhs.false117

lor.lhs.false117:                                 ; preds = %if.then114
  %arrayidx119 = getelementptr inbounds float*, float** %cost, i64 %indvars.iv118
  %19 = load float*, float** %arrayidx119, align 8
  %arrayidx121 = getelementptr inbounds float, float* %19, i64 %indvars.iv120
  %20 = load float, float* %arrayidx121, align 4
  %cmp122 = fcmp olt float %20, %m2104.0
  br i1 %cmp122, label %if.then124, label %for.inc147

if.then124:                                       ; preds = %lor.lhs.false117, %if.then114
  %cmp125 = icmp slt i32 %m1_idx105.0, 0
  %arrayidx136.phi.trans.insert = getelementptr inbounds float*, float** %cost, i64 %indvars.iv118
  %.pre = load float*, float** %arrayidx136.phi.trans.insert, align 8
  %arrayidx138.phi.trans.insert = getelementptr inbounds float, float* %.pre, i64 %indvars.iv120
  %.pre58 = load float, float* %arrayidx138.phi.trans.insert, align 4
  %cmp132 = fcmp olt float %.pre58, %m1103.0
  %or.cond127 = or i1 %cmp125, %cmp132
  %21 = trunc i64 %indvars.iv118 to i32
  %.pre58.m1103.0 = select i1 %or.cond127, float %.pre58, float %m1103.0
  %m1103.0..pre58 = select i1 %or.cond127, float %m1103.0, float %.pre58
  %.m1_idx105.0 = select i1 %or.cond127, i32 %21, i32 %m1_idx105.0
  %m1_idx105.0. = select i1 %or.cond127, i32 %m1_idx105.0, i32 %21
  br label %for.inc147

for.inc147:                                       ; preds = %if.then124, %for.body110, %lor.lhs.false117
  %m1103.3 = phi float [ %m1103.0, %for.body110 ], [ %m1103.0, %lor.lhs.false117 ], [ %.pre58.m1103.0, %if.then124 ]
  %m2104.3 = phi float [ %m2104.0, %for.body110 ], [ %m2104.0, %lor.lhs.false117 ], [ %m1103.0..pre58, %if.then124 ]
  %m1_idx105.3 = phi i32 [ %m1_idx105.0, %for.body110 ], [ %m1_idx105.0, %lor.lhs.false117 ], [ %.m1_idx105.0, %if.then124 ]
  %m2_idx106.3 = phi i32 [ %m2_idx106.0, %for.body110 ], [ %m2_idx106.0, %lor.lhs.false117 ], [ %m1_idx105.0., %if.then124 ]
  %indvars.iv.next119 = add nuw nsw i64 %indvars.iv118, 1
  br label %for.cond107

for.end149:                                       ; preds = %for.cond107
  %cmp150 = icmp sgt i32 %m1_idx105.0, -1
  br i1 %cmp150, label %if.end154, label %if.else153

if.else153:                                       ; preds = %for.end149
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @418, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.6.433, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 233, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end154:                                        ; preds = %for.end149
  %cmp155 = icmp slt i32 %m2_idx106.0, 0
  br i1 %cmp155, label %for.inc169, label %if.end158

if.end158:                                        ; preds = %if.end154
  %cmp159 = icmp slt i32 %mrow.4, 0
  %.pre62 = fsub float %m2104.0, %m1103.0
  %cmp163 = fcmp ogt float %.pre62, %max.4
  %or.cond128 = or i1 %cmp159, %cmp163
  %22 = trunc i64 %indvars.iv120 to i32
  %.mcol.5 = select i1 %or.cond128, i32 %22, i32 %mcol.5
  %m1_idx105.0.mrow.4 = select i1 %or.cond128, i32 %m1_idx105.0, i32 %mrow.4
  %.pre62.max.4 = select i1 %or.cond128, float %.pre62, float %max.4
  br label %for.inc169

for.inc169:                                       ; preds = %if.end158, %for.body98, %if.end154
  %mcol.8 = phi i32 [ %mcol.5, %if.end154 ], [ %mcol.5, %for.body98 ], [ %.mcol.5, %if.end158 ]
  %mrow.7 = phi i32 [ %mrow.4, %if.end154 ], [ %mrow.4, %for.body98 ], [ %m1_idx105.0.mrow.4, %if.end158 ]
  %max.7 = phi float [ %max.4, %if.end154 ], [ %max.4, %for.body98 ], [ %.pre62.max.4, %if.end158 ]
  %indvars.iv.next121 = add nuw nsw i64 %indvars.iv120, 1
  br label %for.cond95

for.end171:                                       ; preds = %for.cond95
  %cmp172 = icmp sgt i32 %mrow.4, -1
  br i1 %cmp172, label %if.end176, label %if.else175

if.else175:                                       ; preds = %for.end171
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @419, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.8.434, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 244, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end176:                                        ; preds = %for.end171
  %cmp177 = icmp sgt i32 %mcol.5, -1
  br i1 %cmp177, label %if.end181, label %if.else180

if.else180:                                       ; preds = %if.end176
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @420, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.9.435, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 245, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end181:                                        ; preds = %if.end176
  %idxprom182 = sext i32 %mrow.4 to i64
  %arrayidx183 = getelementptr inbounds i8, i8* %call, i64 %idxprom182
  %23 = load i8, i8* %arrayidx183, align 1
  %tobool184 = icmp eq i8 %23, 0
  br i1 %tobool184, label %if.end187, label %if.else186

if.else186:                                       ; preds = %if.end181
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @421, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.436, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 252, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end187:                                        ; preds = %if.end181
  %idxprom188 = sext i32 %mcol.5 to i64
  %arrayidx189 = getelementptr inbounds i8, i8* %call3, i64 %idxprom188
  %24 = load i8, i8* %arrayidx189, align 1
  %tobool190 = icmp eq i8 %24, 0
  br i1 %tobool190, label %if.end193, label %if.else192

if.else192:                                       ; preds = %if.end187
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @422, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.437, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 253, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end193:                                        ; preds = %if.end187
  %cmp194 = icmp sgt i32 %lr.0, 1
  br i1 %cmp194, label %land.lhs.true, label %if.else236

land.lhs.true:                                    ; preds = %if.end193
  %arrayidx197 = getelementptr inbounds float, float* %row, i64 %idxprom182
  %25 = load float, float* %arrayidx197, align 4
  %arrayidx199 = getelementptr inbounds float, float* %col, i64 %idxprom188
  %26 = load float, float* %arrayidx199, align 4
  %cmp200.not = fcmp ole float %25, %26
  %brmerge = or i1 %cmp200.not, %cmp203
  br i1 %brmerge, label %if.then205, label %do.end264

if.then205:                                       ; preds = %land.lhs.true
  %arrayidx2077 = getelementptr inbounds i8*, i8** %call5, i64 %idxprom182
  %arrayidx207 = bitcast i8** %arrayidx2077 to %struct.sol**
  %27 = load %struct.sol*, %struct.sol** %arrayidx207, align 8
  %flow210 = getelementptr inbounds %struct.sol, %struct.sol* %27, i64 %idxprom188, i32 3
  store i32 1, i32* %flow210, align 4
  %28 = bitcast float* %arrayidx197 to i32*
  %29 = load i32, i32* %28, align 4
  %30 = load %struct.sol*, %struct.sol** %arrayidx207, align 8
  %value = getelementptr inbounds %struct.sol, %struct.sol* %30, i64 %idxprom188, i32 2
  %31 = bitcast float* %value to i32*
  store i32 %29, i32* %31, align 8
  %32 = load float, float* %arrayidx197, align 4
  %33 = load float, float* %arrayidx199, align 4
  %sub221 = fsub float %33, %32
  store float %sub221, float* %arrayidx199, align 4
  store float 0.000000e+00, float* %arrayidx197, align 4
  %34 = load float, float* %arrayidx199, align 4
  %cmp226 = fcmp olt float %34, 0.000000e+00
  br i1 %cmp226, label %if.then228, label %do.end235

if.then228:                                       ; preds = %if.then205
  store float 0.000000e+00, float* %arrayidx199, align 4
  br label %do.end235

do.end235:                                        ; preds = %if.then228, %if.then205
  store i8 1, i8* %arrayidx183, align 1
  %dec = add nsw i32 %lr.0, -1
  br label %while.cond

if.else236:                                       ; preds = %if.end193
  %cmp237 = icmp sgt i32 %lc.0.ph, 1
  br i1 %cmp237, label %if.else236.do.end264_crit_edge, label %if.else240

if.else236.do.end264_crit_edge:                   ; preds = %if.else236
  %.pre63 = getelementptr inbounds float, float* %col, i64 %idxprom188
  %.pre64 = getelementptr inbounds float, float* %row, i64 %idxprom182
  br label %do.end264

if.else240:                                       ; preds = %if.else236
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @423, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.438, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 267, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

do.end264:                                        ; preds = %land.lhs.true, %if.else236.do.end264_crit_edge
  %arrayidx257.pre-phi = phi float* [ %.pre64, %if.else236.do.end264_crit_edge ], [ %arrayidx197, %land.lhs.true ]
  %arrayidx248.pre-phi = phi float* [ %.pre63, %if.else236.do.end264_crit_edge ], [ %arrayidx199, %land.lhs.true ]
  %arrayidx2435 = getelementptr inbounds i8*, i8** %call5, i64 %idxprom182
  %arrayidx243 = bitcast i8** %arrayidx2435 to %struct.sol**
  %35 = load %struct.sol*, %struct.sol** %arrayidx243, align 8
  %flow246 = getelementptr inbounds %struct.sol, %struct.sol* %35, i64 %idxprom188, i32 3
  store i32 1, i32* %flow246, align 4
  %36 = bitcast float* %arrayidx248.pre-phi to i32*
  %37 = load i32, i32* %36, align 4
  %38 = load %struct.sol*, %struct.sol** %arrayidx243, align 8
  %value253 = getelementptr inbounds %struct.sol, %struct.sol* %38, i64 %idxprom188, i32 2
  %39 = bitcast float* %value253 to i32*
  store i32 %37, i32* %39, align 8
  %40 = load float, float* %arrayidx248.pre-phi, align 4
  %41 = load float, float* %arrayidx257.pre-phi, align 4
  %sub258 = fsub float %41, %40
  store float %sub258, float* %arrayidx257.pre-phi, align 4
  store float 0.000000e+00, float* %arrayidx248.pre-phi, align 4
  store i8 1, i8* %arrayidx189, align 1
  %dec265 = add nsw i32 %lc.0.ph, -1
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %while.cond.preheader, %do.end264
  %lc.0.ph = phi i32 [ %ncol, %while.cond.preheader ], [ %dec265, %do.end264 ]
  %lr.0.ph = phi i32 [ %nrow, %while.cond.preheader ], [ %lr.0, %do.end264 ]
  %cmp203 = icmp slt i32 %lc.0.ph, 2
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp267 = icmp eq i32 %lc.0.ph, 1
  br i1 %cmp267, label %if.end271, label %if.else270

if.else270:                                       ; preds = %while.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @424, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.13.439, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 278, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

if.end271:                                        ; preds = %while.end
  %cmp272 = icmp eq i32 %lr.0, 1
  br i1 %cmp272, label %for.cond277.preheader, label %if.else275

for.cond277.preheader:                            ; preds = %if.end271
  %42 = sext i32 %ncol to i64
  %43 = sext i32 %nrow to i64
  br label %for.cond277

if.else275:                                       ; preds = %if.end271
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @425, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.14.440, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 279, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_init_vogel, i64 0, i64 0)) #16
  unreachable

for.cond277:                                      ; preds = %if.end324, %for.cond277.preheader
  br label %for.cond278

for.cond278:                                      ; preds = %for.inc303, %for.cond277
  %indvars.iv112 = phi i64 [ %indvars.iv.next113, %for.inc303 ], [ 0, %for.cond277 ]
  %cmp279 = icmp slt i64 %indvars.iv112, %43
  br i1 %cmp279, label %for.body281, label %for.end381

for.body281:                                      ; preds = %for.cond278
  %arrayidx283 = getelementptr inbounds i8, i8* %call, i64 %indvars.iv112
  %44 = load i8, i8* %arrayidx283, align 1
  %tobool284 = icmp eq i8 %44, 0
  br i1 %tobool284, label %for.cond286, label %for.inc303

for.cond286:                                      ; preds = %for.body281, %for.inc295
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc295 ], [ 0, %for.body281 ]
  %cmp287 = icmp slt i64 %indvars.iv, %42
  br i1 %cmp287, label %for.body289, label %for.inc303

for.body289:                                      ; preds = %for.cond286
  %arrayidx291 = getelementptr inbounds i8, i8* %call3, i64 %indvars.iv
  %45 = load i8, i8* %arrayidx291, align 1
  %tobool292 = icmp eq i8 %45, 0
  br i1 %tobool292, label %for.end297, label %for.inc295

for.inc295:                                       ; preds = %for.body289
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond286

for.end297:                                       ; preds = %for.body289
  %46 = trunc i64 %indvars.iv to i32
  %cmp298 = icmp sgt i32 %46, -1
  br i1 %cmp298, label %for.end305, label %for.inc303

for.inc303:                                       ; preds = %for.cond286, %for.body281, %for.end297
  %indvars.iv.next113 = add nuw nsw i64 %indvars.iv112, 1
  br label %for.cond278

for.end305:                                       ; preds = %for.end297
  %47 = trunc i64 %indvars.iv112 to i32
  %cmp306 = icmp slt i32 %47, 0
  br i1 %cmp306, label %for.end381, label %if.end324

if.end324:                                        ; preds = %for.end305
  %arrayidx327 = getelementptr inbounds float, float* %row, i64 %indvars.iv112
  %48 = load float, float* %arrayidx327, align 4
  %arrayidx329 = getelementptr inbounds float, float* %col, i64 %indvars.iv
  %49 = load float, float* %arrayidx329, align 4
  %cmp330 = fcmp olt float %48, %49
  %arrayidx3343 = getelementptr inbounds i8*, i8** %call5, i64 %indvars.iv112
  %arrayidx334 = bitcast i8** %arrayidx3343 to %struct.sol**
  %50 = load %struct.sol*, %struct.sol** %arrayidx334, align 8
  %flow337 = getelementptr inbounds %struct.sol, %struct.sol* %50, i64 %indvars.iv, i32 3
  store i32 1, i32* %flow337, align 4
  %arrayidx329.sink135 = select i1 %cmp330, float* %arrayidx327, float* %arrayidx329
  %arrayidx327.sink130 = select i1 %cmp330, float* %arrayidx329, float* %arrayidx327
  %arrayidx291.sink = select i1 %cmp330, i8* %arrayidx283, i8* %arrayidx291
  %51 = bitcast float* %arrayidx329.sink135 to i32*
  %52 = load i32, i32* %51, align 4
  %53 = load %struct.sol*, %struct.sol** %arrayidx334, align 8
  %value368 = getelementptr inbounds %struct.sol, %struct.sol* %53, i64 %indvars.iv, i32 2
  %54 = bitcast float* %value368 to i32*
  store i32 %52, i32* %54, align 8
  %55 = load float, float* %arrayidx329.sink135, align 4
  %56 = load float, float* %arrayidx327.sink130, align 4
  %sub373 = fsub float %56, %55
  store float %sub373, float* %arrayidx327.sink130, align 4
  store float 0.000000e+00, float* %arrayidx329.sink135, align 4
  store i8 1, i8* %arrayidx291.sink, align 1
  br label %for.cond277

for.end381:                                       ; preds = %for.end305, %for.cond278
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @426, i32 0, i32 0))
  call void @free(i8* %call) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @427, i32 0, i32 0))
  call void @free(i8* %call3) #11
  %57 = bitcast %struct.sol*** %_sol to i8***
  store i8** %call5, i8*** %57, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @tp_update(i32 %nrow, i32 %ncol, float** nocapture readonly %cost, %struct.sol** nocapture readonly %sol, %struct.U* %u, %struct.U* %v) unnamed_addr #0 {
entry:
  %q = alloca %struct.U, align 8
  %queue = alloca %struct.sol, align 8
  %0 = sext i32 %nrow to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv23 = phi i64 [ %indvars.iv.next24, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv23, %0
  br i1 %cmp, label %for.inc, label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond
  %1 = sext i32 %ncol to i64
  br label %for.cond1

for.inc:                                          ; preds = %for.cond
  %flags = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv23, i32 0
  store i32 2, i32* %flags, align 8
  %indvars.iv.next24 = add nuw nsw i64 %indvars.iv23, 1
  br label %for.cond

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc7
  %indvars.iv21 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next22, %for.inc7 ]
  %cmp2 = icmp slt i64 %indvars.iv21, %1
  br i1 %cmp2, label %for.inc7, label %for.end9

for.inc7:                                         ; preds = %for.cond1
  %flags6 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv21, i32 0
  store i32 4, i32* %flags6, align 8
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  br label %for.cond1

for.end9:                                         ; preds = %for.cond1
  %value = getelementptr inbounds %struct.U, %struct.U* %u, i64 0, i32 1
  store float 0.000000e+00, float* %value, align 4
  %flags12 = getelementptr inbounds %struct.U, %struct.U* %u, i64 0, i32 0
  %2 = load i32, i32* %flags12, align 8
  %or = or i32 %2, 1
  store i32 %or, i32* %flags12, align 8
  %next = getelementptr inbounds %struct.U, %struct.U* %q, i64 0, i32 2
  store %struct.U* null, %struct.U** %next, align 8
  %sub.ptr.rhs.cast55 = ptrtoint %struct.U* %v to i64
  %add = add nsw i32 %nrow, %ncol
  %3 = bitcast %struct.U** %next to i64*
  %sub.ptr.rhs.cast = ptrtoint %struct.U* %u to i64
  %4 = sext i32 %ncol to i64
  %5 = sext i32 %nrow to i64
  br label %for.cond14

for.cond14:                                       ; preds = %if.end109, %for.end9
  %6 = phi i32 [ %or, %for.end9 ], [ %.pre, %if.end109 ]
  %qc.0 = phi %struct.U* [ %u, %for.end9 ], [ %19, %if.end109 ]
  %qt.0 = phi %struct.U* [ %q, %for.end9 ], [ %q.qt.5, %if.end109 ]
  %cnt.0 = phi i32 [ 1, %for.end9 ], [ %cnt.5, %if.end109 ]
  %and = and i32 %6, 2
  %tobool = icmp eq i32 %and, 0
  %sub.ptr.lhs.cast54 = ptrtoint %struct.U* %qc.0 to i64
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %for.cond14
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast54, %sub.ptr.rhs.cast
  %sext5 = shl i64 %sub.ptr.sub, 28
  %idxprom20 = ashr i64 %sext5, 32
  %arrayidx21 = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %idxprom20
  %arrayidx33 = getelementptr inbounds float*, float** %cost, i64 %idxprom20
  %value38 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %idxprom20, i32 1
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc51, %if.then
  %indvars.iv17 = phi i64 [ %indvars.iv.next18, %for.inc51 ], [ 0, %if.then ]
  %qt.1 = phi %struct.U* [ %qt.2, %for.inc51 ], [ %qt.0, %if.then ]
  %cnt.1 = phi i32 [ %cnt.2, %for.inc51 ], [ %cnt.0, %if.then ]
  %cmp17 = icmp slt i64 %indvars.iv17, %4
  br i1 %cmp17, label %for.body19, label %if.end101

for.body19:                                       ; preds = %for.cond16
  %7 = load %struct.sol*, %struct.sol** %arrayidx21, align 8
  %flow = getelementptr inbounds %struct.sol, %struct.sol* %7, i64 %indvars.iv17, i32 3
  %8 = load i32, i32* %flow, align 4
  %tobool24 = icmp eq i32 %8, 0
  br i1 %tobool24, label %for.inc51, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body19
  %flags27 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv17, i32 0
  %9 = load i32, i32* %flags27, align 8
  %and28 = and i32 %9, 1
  %tobool29 = icmp eq i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %for.inc51

if.then30:                                        ; preds = %land.lhs.true
  %inc31 = add nsw i32 %cnt.1, 1
  %10 = load float*, float** %arrayidx33, align 8
  %arrayidx35 = getelementptr inbounds float, float* %10, i64 %indvars.iv17
  %11 = load float, float* %arrayidx35, align 4
  %12 = load float, float* %value38, align 4
  %sub = fsub float %11, %12
  %value41 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv17, i32 1
  store float %sub, float* %value41, align 4
  %or45 = or i32 %9, 1
  store i32 %or45, i32* %flags27, align 8
  %arrayidx47 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv17
  %next48 = getelementptr inbounds %struct.U, %struct.U* %qt.1, i64 0, i32 2
  store %struct.U* %arrayidx47, %struct.U** %next48, align 8
  %next50 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv17, i32 2
  store %struct.U* null, %struct.U** %next50, align 8
  br label %for.inc51

for.inc51:                                        ; preds = %if.then30, %for.body19, %land.lhs.true
  %qt.2 = phi %struct.U* [ %qt.1, %land.lhs.true ], [ %arrayidx47, %if.then30 ], [ %qt.1, %for.body19 ]
  %cnt.2 = phi i32 [ %cnt.1, %land.lhs.true ], [ %inc31, %if.then30 ], [ %cnt.1, %for.body19 ]
  %indvars.iv.next18 = add nuw nsw i64 %indvars.iv17, 1
  br label %for.cond16

if.else:                                          ; preds = %for.cond14
  %sub.ptr.sub56 = sub i64 %sub.ptr.lhs.cast54, %sub.ptr.rhs.cast55
  %sext = shl i64 %sub.ptr.sub56, 28
  %idxprom65 = ashr i64 %sext, 32
  %value83 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %idxprom65, i32 1
  br label %for.cond59

for.cond59:                                       ; preds = %for.inc98, %if.else
  %indvars.iv19 = phi i64 [ %indvars.iv.next20, %for.inc98 ], [ 0, %if.else ]
  %qt.3 = phi %struct.U* [ %qt.4, %for.inc98 ], [ %qt.0, %if.else ]
  %cnt.3 = phi i32 [ %cnt.4, %for.inc98 ], [ %cnt.0, %if.else ]
  %cmp60 = icmp slt i64 %indvars.iv19, %5
  br i1 %cmp60, label %for.body62, label %if.end101

for.body62:                                       ; preds = %for.cond59
  %arrayidx64 = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %indvars.iv19
  %13 = load %struct.sol*, %struct.sol** %arrayidx64, align 8
  %flow67 = getelementptr inbounds %struct.sol, %struct.sol* %13, i64 %idxprom65, i32 3
  %14 = load i32, i32* %flow67, align 4
  %tobool68 = icmp eq i32 %14, 0
  br i1 %tobool68, label %for.inc98, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %for.body62
  %flags72 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv19, i32 0
  %15 = load i32, i32* %flags72, align 8
  %and73 = and i32 %15, 1
  %tobool74 = icmp eq i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %for.inc98

if.then75:                                        ; preds = %land.lhs.true69
  %inc76 = add nsw i32 %cnt.3, 1
  %arrayidx78 = getelementptr inbounds float*, float** %cost, i64 %indvars.iv19
  %16 = load float*, float** %arrayidx78, align 8
  %arrayidx80 = getelementptr inbounds float, float* %16, i64 %idxprom65
  %17 = load float, float* %arrayidx80, align 4
  %18 = load float, float* %value83, align 4
  %sub84 = fsub float %17, %18
  %value87 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv19, i32 1
  store float %sub84, float* %value87, align 4
  %or91 = or i32 %15, 1
  store i32 %or91, i32* %flags72, align 8
  %arrayidx93 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv19
  %next94 = getelementptr inbounds %struct.U, %struct.U* %qt.3, i64 0, i32 2
  store %struct.U* %arrayidx93, %struct.U** %next94, align 8
  %next96 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv19, i32 2
  store %struct.U* null, %struct.U** %next96, align 8
  br label %for.inc98

for.inc98:                                        ; preds = %if.then75, %for.body62, %land.lhs.true69
  %qt.4 = phi %struct.U* [ %qt.3, %land.lhs.true69 ], [ %arrayidx93, %if.then75 ], [ %qt.3, %for.body62 ]
  %cnt.4 = phi i32 [ %cnt.3, %land.lhs.true69 ], [ %inc76, %if.then75 ], [ %cnt.3, %for.body62 ]
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  br label %for.cond59

if.end101:                                        ; preds = %for.cond16, %for.cond59
  %qt.5 = phi %struct.U* [ %qt.3, %for.cond59 ], [ %qt.1, %for.cond16 ]
  %cnt.5 = phi i32 [ %cnt.3, %for.cond59 ], [ %cnt.1, %for.cond16 ]
  %cmp102 = icmp eq i32 %cnt.5, %add
  %cmp106 = icmp eq %struct.U* %qt.5, %q
  %or.cond = or i1 %cmp102, %cmp106
  br i1 %or.cond, label %for.end118, label %if.end109

if.end109:                                        ; preds = %if.end101
  %19 = load %struct.U*, %struct.U** %next, align 8
  %next111 = getelementptr inbounds %struct.U, %struct.U* %19, i64 0, i32 2
  %20 = bitcast %struct.U** %next111 to i64*
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %3, align 8
  %cmp114 = icmp eq i64 %21, 0
  %q.qt.5 = select i1 %cmp114, %struct.U* %q, %struct.U* %qt.5
  %flags15.phi.trans.insert = getelementptr inbounds %struct.U, %struct.U* %19, i64 0, i32 0
  %.pre = load i32, i32* %flags15.phi.trans.insert, align 8
  br label %for.cond14

for.end118:                                       ; preds = %if.end101
  br i1 %cmp102, label %for.cond125.preheader, label %if.else123

for.cond125.preheader:                            ; preds = %for.end118
  %22 = sext i32 %ncol to i64
  %23 = sext i32 %nrow to i64
  br label %for.cond125

if.else123:                                       ; preds = %for.end118
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @428, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.15.430, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 403, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_update, i64 0, i64 0)) #16
  unreachable

for.cond125:                                      ; preds = %for.cond125.preheader, %for.inc185
  %indvars.iv15 = phi i64 [ 0, %for.cond125.preheader ], [ %indvars.iv.next16, %for.inc185 ]
  %head.0 = phi %struct.sol* [ null, %for.cond125.preheader ], [ %head.1, %for.inc185 ]
  %cmp126 = icmp slt i64 %indvars.iv15, %23
  br i1 %cmp126, label %for.cond129.preheader, label %for.end187

for.cond129.preheader:                            ; preds = %for.cond125
  %arrayidx134 = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %indvars.iv15
  %arrayidx151 = getelementptr inbounds float*, float** %cost, i64 %indvars.iv15
  %value156 = getelementptr inbounds %struct.U, %struct.U* %u, i64 %indvars.iv15, i32 1
  br label %for.cond129

for.cond129:                                      ; preds = %for.cond129.preheader, %for.inc182
  %indvars.iv13 = phi i64 [ 0, %for.cond129.preheader ], [ %indvars.iv.next14, %for.inc182 ]
  %head.1 = phi %struct.sol* [ %head.0, %for.cond129.preheader ], [ %head.3, %for.inc182 ]
  %cmp130 = icmp slt i64 %indvars.iv13, %22
  br i1 %cmp130, label %for.body132, label %for.inc185

for.body132:                                      ; preds = %for.cond129
  %24 = load %struct.sol*, %struct.sol** %arrayidx134, align 8
  %prev = getelementptr inbounds %struct.sol, %struct.sol* %24, i64 %indvars.iv13, i32 7
  store %struct.sol* null, %struct.sol** %prev, align 8
  %25 = load %struct.sol*, %struct.sol** %arrayidx134, align 8
  %next141 = getelementptr inbounds %struct.sol, %struct.sol* %25, i64 %indvars.iv13, i32 6
  store %struct.sol* null, %struct.sol** %next141, align 8
  %26 = load %struct.sol*, %struct.sol** %arrayidx134, align 8
  %flow146 = getelementptr inbounds %struct.sol, %struct.sol* %26, i64 %indvars.iv13, i32 3
  %27 = load i32, i32* %flow146, align 4
  %tobool147 = icmp eq i32 %27, 0
  br i1 %tobool147, label %if.end149, label %for.inc182

if.end149:                                        ; preds = %for.body132
  %28 = load float*, float** %arrayidx151, align 8
  %arrayidx153 = getelementptr inbounds float, float* %28, i64 %indvars.iv13
  %29 = load float, float* %arrayidx153, align 4
  %30 = load float, float* %value156, align 4
  %value159 = getelementptr inbounds %struct.U, %struct.U* %v, i64 %indvars.iv13, i32 1
  %31 = load float, float* %value159, align 4
  %add160 = fadd float %30, %31
  %sub161 = fsub float %29, %add160
  %sigma = getelementptr inbounds %struct.sol, %struct.sol* %26, i64 %indvars.iv13, i32 5
  store float %sub161, float* %sigma, align 4
  %cmp166 = icmp eq %struct.sol* %head.1, null
  %.pre10 = load %struct.sol*, %struct.sol** %arrayidx134, align 8
  br i1 %cmp166, label %if.then176, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end149
  %sigma172 = getelementptr inbounds %struct.sol, %struct.sol* %.pre10, i64 %indvars.iv13, i32 5
  %32 = load float, float* %sigma172, align 4
  %sigma173 = getelementptr inbounds %struct.sol, %struct.sol* %head.1, i64 0, i32 5
  %33 = load float, float* %sigma173, align 4
  %cmp174 = fcmp olt float %32, %33
  br i1 %cmp174, label %if.then176, label %for.inc182

if.then176:                                       ; preds = %if.end149, %lor.lhs.false
  %arrayidx180 = getelementptr inbounds %struct.sol, %struct.sol* %.pre10, i64 %indvars.iv13
  br label %for.inc182

for.inc182:                                       ; preds = %lor.lhs.false, %if.then176, %for.body132
  %head.3 = phi %struct.sol* [ %head.1, %for.body132 ], [ %arrayidx180, %if.then176 ], [ %head.1, %lor.lhs.false ]
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  br label %for.cond129

for.inc185:                                       ; preds = %for.cond129
  %indvars.iv.next16 = add nuw nsw i64 %indvars.iv15, 1
  br label %for.cond125

for.end187:                                       ; preds = %for.cond125
  %cmp188 = icmp eq %struct.sol* %head.0, null
  br i1 %cmp188, label %return, label %if.end191

if.end191:                                        ; preds = %for.end187
  %sigma192 = getelementptr inbounds %struct.sol, %struct.sol* %head.0, i64 0, i32 5
  %34 = load float, float* %sigma192, align 4
  %cmp193 = fcmp ult float %34, 0.000000e+00
  br i1 %cmp193, label %if.end196, label %return

if.end196:                                        ; preds = %if.end191
  %dir = getelementptr inbounds %struct.sol, %struct.sol* %head.0, i64 0, i32 4
  store i32 0, i32* %dir, align 8
  %flow197 = getelementptr inbounds %struct.sol, %struct.sol* %head.0, i64 0, i32 3
  store i32 1, i32* %flow197, align 4
  %next198 = getelementptr inbounds %struct.sol, %struct.sol* %queue, i64 0, i32 6
  store %struct.sol* null, %struct.sol** %next198, align 8
  %i199 = getelementptr inbounds %struct.sol, %struct.sol* %head.0, i64 0, i32 0
  %35 = load i32, i32* %i199, align 8
  %i200 = getelementptr inbounds %struct.sol, %struct.sol* %queue, i64 0, i32 0
  store i32 %35, i32* %i200, align 8
  %j201 = getelementptr inbounds %struct.sol, %struct.sol* %head.0, i64 0, i32 1
  %36 = load i32, i32* %j201, align 4
  %j202 = getelementptr inbounds %struct.sol, %struct.sol* %queue, i64 0, i32 1
  store i32 %36, i32* %j202, align 4
  %37 = bitcast %struct.sol** %next198 to i64*
  %38 = sext i32 %ncol to i64
  %39 = sext i32 %nrow to i64
  br label %for.cond203

for.cond203:                                      ; preds = %if.end302, %if.end196
  %tail.0 = phi %struct.sol* [ %queue, %if.end196 ], [ %queue.tail.5, %if.end302 ]
  %cur.0 = phi %struct.sol* [ %head.0, %if.end196 ], [ %57, %if.end302 ]
  %dir204 = getelementptr inbounds %struct.sol, %struct.sol* %cur.0, i64 0, i32 4
  %40 = load i32, i32* %dir204, align 8
  %cmp205 = icmp eq i32 %40, 0
  br i1 %cmp205, label %if.then207, label %if.else254

if.then207:                                       ; preds = %for.cond203
  %j208 = getelementptr inbounds %struct.sol, %struct.sol* %cur.0, i64 0, i32 1
  %41 = load i32, i32* %j208, align 4
  %i213 = getelementptr inbounds %struct.sol, %struct.sol* %cur.0, i64 0, i32 0
  %idxprom220 = sext i32 %41 to i64
  br label %for.cond209

for.cond209:                                      ; preds = %for.inc251, %if.then207
  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %for.inc251 ], [ 0, %if.then207 ]
  %tail.1 = phi %struct.sol* [ %tail.2, %for.inc251 ], [ %tail.0, %if.then207 ]
  %cmp210 = icmp slt i64 %indvars.iv11, %39
  br i1 %cmp210, label %for.body212, label %if.end302

for.body212:                                      ; preds = %for.cond209
  %42 = load i32, i32* %i213, align 8
  %43 = zext i32 %42 to i64
  %cmp214 = icmp eq i64 %indvars.iv11, %43
  br i1 %cmp214, label %for.inc251, label %if.end217

if.end217:                                        ; preds = %for.body212
  %arrayidx219 = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %indvars.iv11
  %44 = load %struct.sol*, %struct.sol** %arrayidx219, align 8
  %flow222 = getelementptr inbounds %struct.sol, %struct.sol* %44, i64 %idxprom220, i32 3
  %45 = load i32, i32* %flow222, align 4
  %tobool223 = icmp eq i32 %45, 0
  br i1 %tobool223, label %for.inc251, label %if.end225

if.end225:                                        ; preds = %if.end217
  %prev230 = getelementptr inbounds %struct.sol, %struct.sol* %44, i64 %idxprom220, i32 7
  %46 = load %struct.sol*, %struct.sol** %prev230, align 8
  %cmp231 = icmp eq %struct.sol* %46, null
  br i1 %cmp231, label %if.end234, label %for.inc251

if.end234:                                        ; preds = %if.end225
  store %struct.sol* %cur.0, %struct.sol** %prev230, align 8
  %47 = load %struct.sol*, %struct.sol** %arrayidx219, align 8
  %dir244 = getelementptr inbounds %struct.sol, %struct.sol* %47, i64 %idxprom220, i32 4
  store i32 1, i32* %dir244, align 8
  %48 = load %struct.sol*, %struct.sol** %arrayidx219, align 8
  %arrayidx248 = getelementptr inbounds %struct.sol, %struct.sol* %48, i64 %idxprom220
  %next249 = getelementptr inbounds %struct.sol, %struct.sol* %tail.1, i64 0, i32 6
  store %struct.sol* %arrayidx248, %struct.sol** %next249, align 8
  br label %for.inc251

for.inc251:                                       ; preds = %if.end225, %if.end217, %for.body212, %if.end234
  %tail.2 = phi %struct.sol* [ %arrayidx248, %if.end234 ], [ %tail.1, %for.body212 ], [ %tail.1, %if.end217 ], [ %tail.1, %if.end225 ]
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  br label %for.cond209

if.else254:                                       ; preds = %for.cond203
  %i255 = getelementptr inbounds %struct.sol, %struct.sol* %cur.0, i64 0, i32 0
  %49 = load i32, i32* %i255, align 8
  %j260 = getelementptr inbounds %struct.sol, %struct.sol* %cur.0, i64 0, i32 1
  %idxprom265 = sext i32 %49 to i64
  %arrayidx266 = getelementptr inbounds %struct.sol*, %struct.sol** %sol, i64 %idxprom265
  br label %for.cond256

for.cond256:                                      ; preds = %for.inc299, %if.else254
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc299 ], [ 0, %if.else254 ]
  %tail.3 = phi %struct.sol* [ %tail.4, %for.inc299 ], [ %tail.0, %if.else254 ]
  %cmp257 = icmp slt i64 %indvars.iv, %38
  br i1 %cmp257, label %for.body259, label %if.end302

for.body259:                                      ; preds = %for.cond256
  %50 = load i32, i32* %j260, align 4
  %51 = zext i32 %50 to i64
  %cmp261 = icmp eq i64 %indvars.iv, %51
  br i1 %cmp261, label %for.inc299, label %if.end264

if.end264:                                        ; preds = %for.body259
  %52 = load %struct.sol*, %struct.sol** %arrayidx266, align 8
  %flow269 = getelementptr inbounds %struct.sol, %struct.sol* %52, i64 %indvars.iv, i32 3
  %53 = load i32, i32* %flow269, align 4
  %cmp270 = icmp eq i32 %53, 0
  br i1 %cmp270, label %for.inc299, label %if.end273

if.end273:                                        ; preds = %if.end264
  %prev278 = getelementptr inbounds %struct.sol, %struct.sol* %52, i64 %indvars.iv, i32 7
  %54 = load %struct.sol*, %struct.sol** %prev278, align 8
  %cmp279 = icmp eq %struct.sol* %54, null
  br i1 %cmp279, label %if.end282, label %for.inc299

if.end282:                                        ; preds = %if.end273
  store %struct.sol* %cur.0, %struct.sol** %prev278, align 8
  %55 = load %struct.sol*, %struct.sol** %arrayidx266, align 8
  %dir292 = getelementptr inbounds %struct.sol, %struct.sol* %55, i64 %indvars.iv, i32 4
  store i32 0, i32* %dir292, align 8
  %56 = load %struct.sol*, %struct.sol** %arrayidx266, align 8
  %arrayidx296 = getelementptr inbounds %struct.sol, %struct.sol* %56, i64 %indvars.iv
  %next297 = getelementptr inbounds %struct.sol, %struct.sol* %tail.3, i64 0, i32 6
  store %struct.sol* %arrayidx296, %struct.sol** %next297, align 8
  br label %for.inc299

for.inc299:                                       ; preds = %if.end273, %if.end264, %for.body259, %if.end282
  %tail.4 = phi %struct.sol* [ %arrayidx296, %if.end282 ], [ %tail.3, %for.body259 ], [ %tail.3, %if.end264 ], [ %tail.3, %if.end273 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond256

if.end302:                                        ; preds = %for.cond256, %for.cond209
  %tail.5 = phi %struct.sol* [ %tail.1, %for.cond209 ], [ %tail.3, %for.cond256 ]
  %57 = load %struct.sol*, %struct.sol** %next198, align 8
  %next304 = getelementptr inbounds %struct.sol, %struct.sol* %57, i64 0, i32 6
  %58 = bitcast %struct.sol** %next304 to i64*
  %59 = load i64, i64* %58, align 8
  store i64 %59, i64* %37, align 8
  %cmp306 = icmp eq %struct.sol* %57, %tail.5
  %queue.tail.5 = select i1 %cmp306, %struct.sol* %queue, %struct.sol* %tail.5
  %cmp310 = icmp eq %struct.sol* %57, %head.0
  br i1 %cmp310, label %for.cond315, label %for.cond203

for.cond315:                                      ; preds = %if.end302, %if.end325
  %min.0 = phi %struct.sol* [ %min.1, %if.end325 ], [ null, %if.end302 ]
  %cur.1 = phi %struct.sol* [ %63, %if.end325 ], [ %head.0, %if.end302 ]
  %prev316 = getelementptr inbounds %struct.sol, %struct.sol* %cur.1, i64 0, i32 7
  %60 = load %struct.sol*, %struct.sol** %prev316, align 8
  %cmp317 = icmp eq %struct.sol* %min.0, null
  br i1 %cmp317, label %if.then324, label %lor.lhs.false319

lor.lhs.false319:                                 ; preds = %for.cond315
  %value320 = getelementptr inbounds %struct.sol, %struct.sol* %60, i64 0, i32 2
  %61 = load float, float* %value320, align 8
  %value321 = getelementptr inbounds %struct.sol, %struct.sol* %min.0, i64 0, i32 2
  %62 = load float, float* %value321, align 8
  %cmp322 = fcmp olt float %61, %62
  br i1 %cmp322, label %if.then324, label %if.end325

if.then324:                                       ; preds = %lor.lhs.false319, %for.cond315
  br label %if.end325

if.end325:                                        ; preds = %if.then324, %lor.lhs.false319
  %min.1 = phi %struct.sol* [ %60, %if.then324 ], [ %min.0, %lor.lhs.false319 ]
  %prev326 = getelementptr inbounds %struct.sol, %struct.sol* %60, i64 0, i32 7
  %63 = load %struct.sol*, %struct.sol** %prev326, align 8
  %cmp327 = icmp eq %struct.sol* %63, %head.0
  br i1 %cmp327, label %for.end331, label %for.cond315

for.end331:                                       ; preds = %if.end325
  %value332 = getelementptr inbounds %struct.sol, %struct.sol* %min.1, i64 0, i32 2
  %64 = load float, float* %value332, align 8
  %flow333 = getelementptr inbounds %struct.sol, %struct.sol* %min.1, i64 0, i32 3
  %65 = load i32, i32* %flow333, align 4
  %tobool334 = icmp eq i32 %65, 0
  br i1 %tobool334, label %if.else336, label %if.end337

if.else336:                                       ; preds = %for.end331
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @429, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16.432, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.7.431, i64 0, i64 0), i32 497, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__PRETTY_FUNCTION__.tp_update, i64 0, i64 0)) #16
  unreachable

if.end337:                                        ; preds = %for.end331
  store i32 0, i32* %flow333, align 4
  br label %for.cond339

for.cond339:                                      ; preds = %for.cond339, %if.end337
  %cur.2 = phi %struct.sol* [ %head.0, %if.end337 ], [ %69, %for.cond339 ]
  %value340 = getelementptr inbounds %struct.sol, %struct.sol* %cur.2, i64 0, i32 2
  %66 = load float, float* %value340, align 8
  %add341 = fadd float %66, %64
  store float %add341, float* %value340, align 8
  %prev342 = getelementptr inbounds %struct.sol, %struct.sol* %cur.2, i64 0, i32 7
  %67 = load %struct.sol*, %struct.sol** %prev342, align 8
  %value343 = getelementptr inbounds %struct.sol, %struct.sol* %67, i64 0, i32 2
  %68 = load float, float* %value343, align 8
  %sub344 = fsub float %68, %64
  store float %sub344, float* %value343, align 8
  %prev345 = getelementptr inbounds %struct.sol, %struct.sol* %67, i64 0, i32 7
  %69 = load %struct.sol*, %struct.sol** %prev345, align 8
  %cmp346 = icmp eq %struct.sol* %69, %head.0
  br i1 %cmp346, label %return, label %for.cond339

return:                                           ; preds = %for.cond339, %if.end191, %for.end187
  %retval.0 = phi i32 [ 1, %for.end187 ], [ 1, %if.end191 ], [ 0, %for.cond339 ]
  ret i32 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc %struct.CKHash_Table_* @ckh_alloc_table(i32 %table_size, %struct.anon.7* %_vt) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @430, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 72) #11
  %0 = bitcast i8* %call to %struct.CKHash_Table_*
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @431, i32 0, i32 0))
  %call1 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.443, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.444, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.445, i64 0, i64 0)) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @432, i32 0, i32 0))
  call void @exit(i32 1) #16
  unreachable

if.end:                                           ; preds = %entry
  %vtable = getelementptr inbounds i8, i8* %call, i64 64
  %2 = bitcast i8* %vtable to %struct.anon.7**
  store %struct.anon.7* %_vt, %struct.anon.7** %2, align 8
  %size = bitcast i8* %call to i32*
  store i32 0, i32* %size, align 8
  %table_size2 = getelementptr inbounds i8, i8* %call, i64 8
  %3 = bitcast i8* %table_size2 to i32*
  store i32 %table_size, i32* %3, align 8
  %mul3 = mul nsw i32 %table_size, 10
  %div = sdiv i32 %mul3, 12
  %mean_size = getelementptr inbounds i8, i8* %call, i64 16
  %4 = bitcast i8* %mean_size to i32*
  store i32 %div, i32* %4, align 8
  %mul4 = shl nsw i32 %table_size, 1
  %div5 = sdiv i32 %mul4, 5
  %min_size = getelementptr inbounds i8, i8* %call, i64 12
  %5 = bitcast i8* %min_size to i32*
  store i32 %div5, i32* %5, align 4
  %conv = sitofp i32 %table_size to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @433, i32 0, i32 0))
  %call6 = call double @log(double %conv) #11
  %div8 = fdiv double %call6, 0x3FE62E42FEFA39EF
  %add = fadd double %div8, 5.000000e-01
  %conv9 = fptosi double %add to i32
  %sub = sub nsw i32 32, %conv9
  %shift = getelementptr inbounds i8, i8* %call, i64 4
  %6 = bitcast i8* %shift to i32*
  store i32 %sub, i32* %6, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @434, i32 0, i32 0))
  %call11 = call double @log(double %conv) #11
  %mul12 = fmul double %call11, 4.000000e+00
  %div14 = fdiv double %mul12, 0x3FE62E42FEFA39EF
  %add15 = fadd double %div14, 5.000000e-01
  %conv16 = fptosi double %add15 to i32
  %add17 = add nsw i32 %conv16, 4
  %max_chain = getelementptr inbounds i8, i8* %call, i64 20
  %7 = bitcast i8* %max_chain to i32*
  store i32 %add17, i32* %7, align 4
  %8 = load i32, i32* %3, align 8
  %conv19 = sext i32 %8 to i64
  %mul20 = mul nsw i64 %conv19, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @435, i32 0, i32 0))
  %call21 = call noalias i8* @malloc(i64 %mul20) #11
  %T1 = getelementptr inbounds i8, i8* %call, i64 24
  %9 = bitcast i8* %T1 to i8**
  store i8* %call21, i8** %9, align 8
  %cmp22 = icmp eq i8* %call21, null
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @436, i32 0, i32 0))
  %call25 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.443, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.444, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3.446, i64 0, i64 0)) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @437, i32 0, i32 0))
  call void @exit(i32 1) #16
  unreachable

if.end26:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @438, i32 0, i32 0))
  %call30 = call noalias i8* @malloc(i64 %mul20) #11
  %T2 = getelementptr inbounds i8, i8* %call, i64 32
  %11 = bitcast i8* %T2 to i8**
  store i8* %call30, i8** %11, align 8
  %cmp31 = icmp eq i8* %call30, null
  br i1 %cmp31, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end26
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @439, i32 0, i32 0))
  %call34 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %12, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.443, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.444, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.4.447, i64 0, i64 0)) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @440, i32 0, i32 0))
  call void @exit(i32 1) #16
  unreachable

if.end35:                                         ; preds = %if.end26
  %function_size = getelementptr inbounds i8, i8* %call, i64 40
  %13 = bitcast i8* %function_size to i32*
  store i32 256, i32* %13, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @441, i32 0, i32 0))
  %call39 = call noalias i8* @malloc(i64 1024) #11
  %a1 = getelementptr inbounds i8, i8* %call, i64 48
  %14 = bitcast i8* %a1 to i8**
  store i8* %call39, i8** %14, align 8
  %cmp40 = icmp eq i8* %call39, null
  %15 = bitcast i8* %call39 to i32*
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end35
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @442, i32 0, i32 0))
  %call43 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %16, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.443, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.444, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5.448, i64 0, i64 0)) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @443, i32 0, i32 0))
  call void @exit(i32 1) #16
  unreachable

if.end44:                                         ; preds = %if.end35
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @444, i32 0, i32 0))
  %call48 = call noalias i8* @malloc(i64 1024) #11
  %a2 = getelementptr inbounds i8, i8* %call, i64 56
  %17 = bitcast i8* %a2 to i8**
  store i8* %call48, i8** %17, align 8
  %cmp49 = icmp eq i8* %call48, null
  br i1 %cmp49, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.end44
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @445, i32 0, i32 0))
  %call52 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %18, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.443, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.444, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.449, i64 0, i64 0)) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @446, i32 0, i32 0))
  call void @exit(i32 1) #16
  unreachable

if.end53:                                         ; preds = %if.end44
  call fastcc void @ckh_init(i32* %15, i32 256)
  %19 = bitcast i8* %a2 to i32**
  %20 = load i32*, i32** %19, align 8
  %21 = load i32, i32* %13, align 8
  call fastcc void @ckh_init(i32* %20, i32 %21)
  %22 = bitcast i8* %T2 to %struct.CKHash_Cell**
  %23 = bitcast i8* %T1 to %struct.CKHash_Cell**
  %.pre = load i32, i32* %3, align 8
  %24 = sext i32 %.pre to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end53
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end53 ]
  %cmp59 = icmp slt i64 %indvars.iv, %24
  br i1 %cmp59, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %25 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %22, align 8
  %vid = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %25, i64 %indvars.iv, i32 0
  store i32 -1, i32* %vid, align 8
  %26 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %23, align 8
  %vid65 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %26, i64 %indvars.iv, i32 0
  store i32 -1, i32* %vid65, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret %struct.CKHash_Table_* %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ckh_init(i32* nocapture %a, i32 %function_size) unnamed_addr #0 {
entry:
  %0 = sext i32 %function_size to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv, %0
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @447, i32 0, i32 0))
  %call = call i32 @rand() #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @448, i32 0, i32 0))
  %call1 = call i32 @rand() #11
  %mul = mul nsw i32 %call, %call1
  %shl = shl i32 %mul, 1
  %add = or i32 %shl, 1
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %indvars.iv
  store i32 %add, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @ckh_rehash_insert(%struct.CKHash_Table_* readonly %D, i32 %vid) unnamed_addr #0 {
entry:
  %hkey = alloca i64, align 8
  %x.sroa.7 = alloca [20 x i8], align 4
  %temp.sroa.6 = alloca [20 x i8], align 4
  %max_chain = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 5
  %vtable = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 11
  %a1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 9
  %function_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 8
  %table_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 2
  %shift = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 1
  %T1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 6
  %temp.sroa.6.0..sroa_idx = getelementptr inbounds [20 x i8], [20 x i8]* %temp.sroa.6, i64 0, i64 0
  %x.sroa.7.0..sroa_idx = getelementptr inbounds [20 x i8], [20 x i8]* %x.sroa.7, i64 0, i64 0
  %a2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 10
  %T2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %x.sroa.0.0 = phi i32 [ %vid, %entry ], [ %temp.sroa.0.0.copyload5, %for.inc ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %0 = load i32, i32* %max_chain, align 4
  %cmp = icmp slt i32 %j.0, %0
  br i1 %cmp, label %for.body, label %for.cond23

for.body:                                         ; preds = %for.cond
  %1 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %data = getelementptr inbounds %struct.anon.7, %struct.anon.7* %1, i64 0, i32 3
  %2 = load i8**, i8*** %data, align 8
  %idxprom = zext i32 %x.sroa.0.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %2, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8
  %4 = load i32*, i32** %a1, align 8
  %5 = load i32, i32* %function_size, align 8
  %6 = load i32, i32* %table_size, align 8
  %7 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %hkey, i32* %4, i32 %5, i32 %6, i32 %7, i8* %3)
  %8 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T1, align 8
  %9 = load i64, i64* %hkey, align 8
  %arrayidx3 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %8, i64 %9
  %temp.sroa.0.0..sroa_idx = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %arrayidx3, i64 0, i32 0
  %temp.sroa.0.0.copyload = load i32, i32* %temp.sroa.0.0..sroa_idx, align 8
  %temp.sroa.6.0..sroa_raw_cast = bitcast %struct.CKHash_Cell* %arrayidx3 to i8*
  %temp.sroa.6.0..sroa_raw_idx = getelementptr inbounds i8, i8* %temp.sroa.6.0..sroa_raw_cast, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_idx, i8* %temp.sroa.6.0..sroa_raw_idx, i64 20, i32 4, i1 false)
  store i32 %x.sroa.0.0, i32* %temp.sroa.0.0..sroa_idx, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_raw_idx, i8* %x.sroa.7.0..sroa_idx, i64 20, i32 4, i1 false)
  %cmp7 = icmp eq i32 %temp.sroa.0.0.copyload, -1
  br i1 %cmp7, label %return, label %if.end

if.end:                                           ; preds = %for.body
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %x.sroa.7.0..sroa_idx, i8* %temp.sroa.6.0..sroa_idx, i64 20, i32 4, i1 false)
  %10 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %data9 = getelementptr inbounds %struct.anon.7, %struct.anon.7* %10, i64 0, i32 3
  %11 = load i8**, i8*** %data9, align 8
  %idxprom11 = zext i32 %temp.sroa.0.0.copyload to i64
  %arrayidx12 = getelementptr inbounds i8*, i8** %11, i64 %idxprom11
  %12 = load i8*, i8** %arrayidx12, align 8
  %13 = load i32*, i32** %a2, align 8
  %14 = load i32, i32* %function_size, align 8
  %15 = load i32, i32* %table_size, align 8
  %16 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %hkey, i32* %13, i32 %14, i32 %15, i32 %16, i8* %12)
  %17 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T2, align 8
  %18 = load i64, i64* %hkey, align 8
  %arrayidx16 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %17, i64 %18
  %temp.sroa.0.0..sroa_idx4 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %arrayidx16, i64 0, i32 0
  %temp.sroa.0.0.copyload5 = load i32, i32* %temp.sroa.0.0..sroa_idx4, align 8
  %temp.sroa.6.0..sroa_raw_cast11 = bitcast %struct.CKHash_Cell* %arrayidx16 to i8*
  %temp.sroa.6.0..sroa_raw_idx12 = getelementptr inbounds i8, i8* %temp.sroa.6.0..sroa_raw_cast11, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_idx, i8* %temp.sroa.6.0..sroa_raw_idx12, i64 20, i32 4, i1 false)
  store i32 %temp.sroa.0.0.copyload, i32* %temp.sroa.0.0..sroa_idx4, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_raw_idx12, i8* %x.sroa.7.0..sroa_idx, i64 20, i32 4, i1 false)
  %cmp20 = icmp eq i32 %temp.sroa.0.0.copyload5, -1
  br i1 %cmp20, label %return, label %for.inc

for.inc:                                          ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %x.sroa.7.0..sroa_idx, i8* %temp.sroa.6.0..sroa_idx, i64 20, i32 4, i1 false)
  %inc = add nuw nsw i32 %j.0, 1
  br label %for.cond

for.cond23:                                       ; preds = %for.cond, %for.inc35
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc35 ], [ 0, %for.cond ]
  %19 = load i32, i32* %table_size, align 8
  %20 = sext i32 %19 to i64
  %cmp25 = icmp slt i64 %indvars.iv, %20
  br i1 %cmp25, label %for.inc35, label %for.end37

for.inc35:                                        ; preds = %for.cond23
  %21 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T2, align 8
  %vid30 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %21, i64 %indvars.iv, i32 0
  store i32 -1, i32* %vid30, align 8
  %22 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T1, align 8
  %vid34 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %22, i64 %indvars.iv, i32 0
  store i32 -1, i32* %vid34, align 8
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond23

for.end37:                                        ; preds = %for.cond23
  %23 = load i32*, i32** %a1, align 8
  %24 = load i32, i32* %function_size, align 8
  call fastcc void @ckh_init(i32* %23, i32 %24)
  %25 = load i32*, i32** %a2, align 8
  %26 = load i32, i32* %function_size, align 8
  call fastcc void @ckh_init(i32* %25, i32 %26)
  br label %return

return:                                           ; preds = %if.end, %for.body, %for.end37
  %retval.0 = phi i32 [ 0, %for.end37 ], [ 1, %for.body ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @ckh_hash(i64* nocapture %h, i32* nocapture readonly %a, i32 %function_size, i32 %table_size, i32 %shift, i8* nocapture readonly %key) unnamed_addr #8 {
entry:
  store i64 0, i64* %h, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %0 = phi i64 [ %xor, %for.inc ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i8, i8* %key, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx, align 1
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %2 = trunc i64 %indvars.iv to i32
  %rem = srem i32 %2, %function_size
  %idxprom1 = sext i32 %rem to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %a, i64 %idxprom1
  %3 = load i32, i32* %arrayidx2, align 4
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %3, %conv
  %conv5 = zext i32 %mul to i64
  %xor = xor i64 %0, %conv5
  store i64 %xor, i64* %h, align 8
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv6 = trunc i64 %0 to i32
  %shr = lshr i32 %conv6, %shift
  %rem7 = urem i32 %shr, %table_size
  %conv8 = zext i32 %rem7 to i64
  store i64 %conv8, i64* %h, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ckh_rehash(%struct.CKHash_Table_* nocapture %D, i32 %new_size) unnamed_addr #0 {
entry:
  %vtable = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 11
  %0 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %call = call fastcc %struct.CKHash_Table_* @ckh_alloc_table(i32 %new_size, %struct.anon.7* %0)
  %table_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 2
  %T1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 6
  %T2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %k.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %1 = load i32, i32* %table_size, align 8
  %cmp = icmp slt i32 %k.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T1, align 8
  %idxprom = sext i32 %k.0 to i64
  %vid = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %2, i64 %idxprom, i32 0
  %3 = load i32, i32* %vid, align 8
  %cmp1 = icmp eq i32 %3, -1
  br i1 %cmp1, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %call6 = call fastcc i32 @ckh_rehash_insert(%struct.CKHash_Table_* %call, i32 %3)
  %tobool = icmp eq i32 %call6, 0
  br i1 %tobool, label %for.inc, label %if.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  %4 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T2, align 8
  %vid9 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %4, i64 %idxprom, i32 0
  %5 = load i32, i32* %vid9, align 8
  %cmp10 = icmp eq i32 %5, -1
  br i1 %cmp10, label %for.inc, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %if.end
  %call16 = call fastcc i32 @ckh_rehash_insert(%struct.CKHash_Table_* %call, i32 %5)
  %tobool17 = icmp eq i32 %call16, 0
  %.k.0 = select i1 %tobool17, i32 -1, i32 %k.0
  br label %for.inc

for.inc:                                          ; preds = %land.lhs.true11, %if.end, %land.lhs.true
  %k.2 = phi i32 [ -1, %land.lhs.true ], [ %k.0, %if.end ], [ %.k.0, %land.lhs.true11 ]
  %inc = add nsw i32 %k.2, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.CKHash_Cell** %T1 to i8**
  %7 = load i8*, i8** %6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @449, i32 0, i32 0))
  call void @free(i8* %7) #11
  %8 = bitcast %struct.CKHash_Cell** %T2 to i8**
  %9 = load i8*, i8** %8, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @450, i32 0, i32 0))
  call void @free(i8* %9) #11
  %a1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 9
  %10 = bitcast i32** %a1 to i8**
  %11 = load i8*, i8** %10, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @451, i32 0, i32 0))
  call void @free(i8* %11) #11
  %a2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 10
  %12 = bitcast i32** %a2 to i8**
  %13 = load i8*, i8** %12, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @452, i32 0, i32 0))
  call void @free(i8* %13) #11
  %size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 0
  %14 = load i32, i32* %size, align 8
  %size22 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %call, i64 0, i32 0
  store i32 %14, i32* %size22, align 8
  %15 = bitcast %struct.CKHash_Table_* %D to i8*
  %16 = bitcast %struct.CKHash_Table_* %call to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 72, i32 8, i1 false)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @453, i32 0, i32 0))
  call void @free(i8* %16) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ckh_insert(%struct.CKHash_Table_* %D, i32 %vid) unnamed_addr #0 {
entry:
  %h1 = alloca i64, align 8
  %h2 = alloca i64, align 8
  %x.sroa.8 = alloca [20 x i8], align 4
  %temp.sroa.6 = alloca [20 x i8], align 4
  %vtable = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 11
  %0 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %data = getelementptr inbounds %struct.anon.7, %struct.anon.7* %0, i64 0, i32 3
  %1 = load i8**, i8*** %data, align 8
  %idxprom = zext i32 %vid to i64
  %arrayidx = getelementptr inbounds i8*, i8** %1, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8
  %a1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 9
  %3 = load i32*, i32** %a1, align 8
  %function_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 8
  %4 = load i32, i32* %function_size, align 8
  %table_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 2
  %5 = load i32, i32* %table_size, align 8
  %shift = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 1
  %6 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %h1, i32* %3, i32 %4, i32 %5, i32 %6, i8* %2)
  %T1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 6
  %7 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T1, align 8
  %8 = load i64, i64* %h1, align 8
  %vid2 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %7, i64 %8, i32 0
  %9 = load i32, i32* %vid2, align 8
  %cmp = icmp ne i32 %9, -1
  %cmp6 = icmp eq i32 %9, %vid
  %or.cond = and i1 %cmp, %cmp6
  br i1 %or.cond, label %return, label %if.end8

if.end8:                                          ; preds = %entry
  %a2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 10
  %10 = load i32*, i32** %a2, align 8
  %11 = load i32, i32* %function_size, align 8
  %12 = load i32, i32* %table_size, align 8
  %13 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %h2, i32* %10, i32 %11, i32 %12, i32 %13, i8* %2)
  %T2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 7
  %14 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T2, align 8
  %15 = load i64, i64* %h2, align 8
  %vid13 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %14, i64 %15, i32 0
  %16 = load i32, i32* %vid13, align 8
  %cmp14 = icmp ne i32 %16, -1
  %cmp19 = icmp eq i32 %16, %vid
  %or.cond29 = and i1 %cmp14, %cmp19
  br i1 %or.cond29, label %return, label %if.end22

if.end22:                                         ; preds = %if.end8
  %max_chain = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 5
  %temp.sroa.6.0..sroa_idx = getelementptr inbounds [20 x i8], [20 x i8]* %temp.sroa.6, i64 0, i64 0
  %x.sroa.8.0..sroa_idx = getelementptr inbounds [20 x i8], [20 x i8]* %x.sroa.8, i64 0, i64 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end22
  %x.sroa.0.0 = phi i32 [ %vid, %if.end22 ], [ %temp.sroa.0.0.copyload5, %for.inc ]
  %j.0 = phi i32 [ 0, %if.end22 ], [ %inc74, %for.inc ]
  %17 = load i32, i32* %max_chain, align 4
  %cmp24 = icmp slt i32 %j.0, %17
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T1, align 8
  %19 = load i64, i64* %h1, align 8
  %arrayidx26 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %18, i64 %19
  %temp.sroa.0.0..sroa_idx = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %arrayidx26, i64 0, i32 0
  %temp.sroa.0.0.copyload = load i32, i32* %temp.sroa.0.0..sroa_idx, align 8
  %temp.sroa.6.0..sroa_raw_cast = bitcast %struct.CKHash_Cell* %arrayidx26 to i8*
  %temp.sroa.6.0..sroa_raw_idx = getelementptr inbounds i8, i8* %temp.sroa.6.0..sroa_raw_cast, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_idx, i8* %temp.sroa.6.0..sroa_raw_idx, i64 20, i32 4, i1 false)
  store i32 %x.sroa.0.0, i32* %temp.sroa.0.0..sroa_idx, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_raw_idx, i8* %x.sroa.8.0..sroa_idx, i64 20, i32 4, i1 false)
  %cmp30 = icmp eq i32 %temp.sroa.0.0.copyload, -1
  br i1 %cmp30, label %if.then31, label %if.end38

if.then31:                                        ; preds = %for.body
  %size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 0
  %20 = load i32, i32* %size, align 8
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %size, align 8
  %21 = load i32, i32* %table_size, align 8
  %cmp34 = icmp sgt i32 %21, %20
  br i1 %cmp34, label %return, label %if.then35

if.then35:                                        ; preds = %if.then31
  %mul = shl nsw i32 %21, 1
  call fastcc void @ckh_rehash(%struct.CKHash_Table_* %D, i32 %mul)
  br label %return

if.end38:                                         ; preds = %for.body
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %x.sroa.8.0..sroa_idx, i8* %temp.sroa.6.0..sroa_idx, i64 20, i32 4, i1 false)
  %22 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %data40 = getelementptr inbounds %struct.anon.7, %struct.anon.7* %22, i64 0, i32 3
  %23 = load i8**, i8*** %data40, align 8
  %idxprom42 = zext i32 %temp.sroa.0.0.copyload to i64
  %arrayidx43 = getelementptr inbounds i8*, i8** %23, i64 %idxprom42
  %24 = load i8*, i8** %arrayidx43, align 8
  %25 = load i32*, i32** %a2, align 8
  %26 = load i32, i32* %function_size, align 8
  %27 = load i32, i32* %table_size, align 8
  %28 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %h2, i32* %25, i32 %26, i32 %27, i32 %28, i8* %24)
  %29 = load %struct.CKHash_Cell*, %struct.CKHash_Cell** %T2, align 8
  %30 = load i64, i64* %h2, align 8
  %arrayidx49 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %29, i64 %30
  %temp.sroa.0.0..sroa_idx4 = getelementptr inbounds %struct.CKHash_Cell, %struct.CKHash_Cell* %arrayidx49, i64 0, i32 0
  %temp.sroa.0.0.copyload5 = load i32, i32* %temp.sroa.0.0..sroa_idx4, align 8
  %temp.sroa.6.0..sroa_raw_cast11 = bitcast %struct.CKHash_Cell* %arrayidx49 to i8*
  %temp.sroa.6.0..sroa_raw_idx12 = getelementptr inbounds i8, i8* %temp.sroa.6.0..sroa_raw_cast11, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_idx, i8* %temp.sroa.6.0..sroa_raw_idx12, i64 20, i32 4, i1 false)
  store i32 %temp.sroa.0.0.copyload, i32* %temp.sroa.0.0..sroa_idx4, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %temp.sroa.6.0..sroa_raw_idx12, i8* %x.sroa.8.0..sroa_idx, i64 20, i32 4, i1 false)
  %cmp53 = icmp eq i32 %temp.sroa.0.0.copyload5, -1
  br i1 %cmp53, label %if.then54, label %for.inc

if.then54:                                        ; preds = %if.end38
  %size55 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 0
  %31 = load i32, i32* %size55, align 8
  %inc56 = add nsw i32 %31, 1
  store i32 %inc56, i32* %size55, align 8
  %32 = load i32, i32* %table_size, align 8
  %cmp59 = icmp sgt i32 %32, %31
  br i1 %cmp59, label %return, label %if.then60

if.then60:                                        ; preds = %if.then54
  %mul62 = shl nsw i32 %32, 1
  call fastcc void @ckh_rehash(%struct.CKHash_Table_* %D, i32 %mul62)
  br label %return

for.inc:                                          ; preds = %if.end38
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %x.sroa.8.0..sroa_idx, i8* %temp.sroa.6.0..sroa_idx, i64 20, i32 4, i1 false)
  %33 = load %struct.anon.7*, %struct.anon.7** %vtable, align 8
  %data66 = getelementptr inbounds %struct.anon.7, %struct.anon.7* %33, i64 0, i32 3
  %34 = load i8**, i8*** %data66, align 8
  %idxprom68 = zext i32 %temp.sroa.0.0.copyload5 to i64
  %arrayidx69 = getelementptr inbounds i8*, i8** %34, i64 %idxprom68
  %35 = load i8*, i8** %arrayidx69, align 8
  %36 = load i32*, i32** %a1, align 8
  %37 = load i32, i32* %function_size, align 8
  %38 = load i32, i32* %table_size, align 8
  %39 = load i32, i32* %shift, align 4
  call fastcc void @ckh_hash(i64* nonnull %h1, i32* %36, i32 %37, i32 %38, i32 %39, i8* %35)
  %inc74 = add nuw nsw i32 %j.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %size75 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 0
  %40 = load i32, i32* %size75, align 8
  %mean_size = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 4
  %41 = load i32, i32* %mean_size, align 8
  %cmp76 = icmp slt i32 %40, %41
  %42 = load i32, i32* %table_size, align 8
  br i1 %cmp76, label %if.then77, label %if.else

if.then77:                                        ; preds = %for.end
  call fastcc void @ckh_rehash(%struct.CKHash_Table_* %D, i32 %42)
  br label %if.end81

if.else:                                          ; preds = %for.end
  %mul80 = shl nsw i32 %42, 1
  call fastcc void @ckh_rehash(%struct.CKHash_Table_* %D, i32 %mul80)
  br label %if.end81

if.end81:                                         ; preds = %if.else, %if.then77
  call fastcc void @ckh_insert(%struct.CKHash_Table_* %D, i32 %x.sroa.0.0)
  br label %return

return:                                           ; preds = %if.end8, %entry, %if.then60, %if.then54, %if.then35, %if.then31, %if.end81
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ckh_destruct_table(%struct.CKHash_Table_* nocapture %D) unnamed_addr #0 {
entry:
  %T1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 6
  %0 = bitcast %struct.CKHash_Cell** %T1 to i8**
  %1 = load i8*, i8** %0, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @454, i32 0, i32 0))
  call void @free(i8* %1) #11
  %T2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 7
  %2 = bitcast %struct.CKHash_Cell** %T2 to i8**
  %3 = load i8*, i8** %2, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @455, i32 0, i32 0))
  call void @free(i8* %3) #11
  %a1 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 9
  %4 = bitcast i32** %a1 to i8**
  %5 = load i8*, i8** %4, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @456, i32 0, i32 0))
  call void @free(i8* %5) #11
  %a2 = getelementptr inbounds %struct.CKHash_Table_, %struct.CKHash_Table_* %D, i64 0, i32 10
  %6 = bitcast i32** %a2 to i8**
  %7 = load i8*, i8** %6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @457, i32 0, i32 0))
  call void @free(i8* %7) #11
  %8 = bitcast %struct.CKHash_Table_* %D to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @458, i32 0, i32 0))
  call void @free(i8* %8) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ohash_init_with_stream(%struct.ohash_t* nocapture %ohash, %struct._IO_FILE* nocapture %fin) unnamed_addr #0 {
entry:
  %size = alloca i32, align 4
  %bsize = alloca i32, align 4
  store i32 0, i32* %bsize, align 4
  store i32 0, i32* %size, align 4
  %call = call fastcc i32 @cass_read_uint32.460(i32* nonnull %size, %struct._IO_FILE* %fin)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @459, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1.461, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2.462, i64 0, i64 0), i32 40, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.ohash_init_with_stream, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %size, align 4
  %size1 = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 0
  store i32 %0, i32* %size1, align 8
  %conv = zext i32 %0 to i64
  %mul = mul nuw nsw i64 %conv, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @460, i32 0, i32 0))
  %call2 = call noalias i8* @malloc(i64 %mul) #11
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %ohash, i64 0, i32 1
  %1 = bitcast %struct.anon.5** %bucket to i8**
  store i8* %call2, i8** %1, align 8
  %2 = zext i32 %0 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end ]
  %cmp3 = icmp ult i64 %indvars.iv, %2
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %bsize, align 4
  %call5 = call fastcc i32 @cass_read_uint32.460(i32* nonnull %bsize, %struct._IO_FILE* %fin)
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %do.body, label %if.else9

if.else9:                                         ; preds = %for.body
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @461, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.1.461, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2.462, i64 0, i64 0), i32 49, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.ohash_init_with_stream, i64 0, i64 0)) #16
  unreachable

do.body:                                          ; preds = %for.body
  %3 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %inc = getelementptr inbounds %struct.anon.5, %struct.anon.5* %3, i64 %indvars.iv, i32 0
  store i32 256, i32* %inc, align 8
  %4 = load i32, i32* %bsize, align 4
  %5 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %size15 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %5, i64 %indvars.iv, i32 1
  store i32 %4, i32* %size15, align 4
  %6 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %len19 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %6, i64 %indvars.iv, i32 2
  store i32 0, i32* %len19, align 8
  %7 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %data23 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %7, i64 %indvars.iv, i32 3
  store i32* null, i32** %data23, align 8
  %cmp24 = icmp eq i32 %4, 0
  br i1 %cmp24, label %for.inc, label %if.then26

if.then26:                                        ; preds = %do.body
  %conv27 = zext i32 %4 to i64
  %mul28 = shl nuw nsw i64 %conv27, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @462, i32 0, i32 0))
  %call29 = call noalias i8* @malloc(i64 %mul28) #11
  %8 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %data33 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %8, i64 %indvars.iv, i32 3
  %9 = bitcast i32** %data33 to i8**
  store i8* %call29, i8** %9, align 8
  %10 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %data37 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %10, i64 %indvars.iv, i32 3
  %11 = load i32*, i32** %data37, align 8
  %cmp38 = icmp eq i32* %11, null
  br i1 %cmp38, label %if.else41, label %do.end57

if.else41:                                        ; preds = %if.then26
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @463, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3.463, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2.462, i64 0, i64 0), i32 50, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.ohash_init_with_stream, i64 0, i64 0)) #16
  unreachable

do.end57:                                         ; preds = %if.then26
  %call59 = call fastcc i32 @cass_read_int32.464(i32* nonnull %11, i64 %conv27, %struct._IO_FILE* %fin)
  %cmp60 = icmp eq i32 %call59, %4
  br i1 %cmp60, label %do.body65, label %if.else63

if.else63:                                        ; preds = %do.end57
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @464, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.4.465, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2.462, i64 0, i64 0), i32 54, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.ohash_init_with_stream, i64 0, i64 0)) #16
  unreachable

do.body65:                                        ; preds = %do.end57
  %12 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %len69 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %12, i64 %indvars.iv, i32 2
  store i32 %4, i32* %len69, align 8
  %13 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %size73 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %13, i64 %indvars.iv, i32 1
  %14 = load i32, i32* %size73, align 4
  %cmp74 = icmp ugt i32 %4, %14
  br i1 %cmp74, label %if.else77, label %for.inc

if.else77:                                        ; preds = %do.body65
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @465, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.5.466, i64 0, i64 0), i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.2.462, i64 0, i64 0), i32 55, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__.ohash_init_with_stream, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %do.body, %do.body65
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.460(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @466, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.467()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_int32.464(i32* nocapture %buf, i64 %nmemb, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @467, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 %nmemb, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.467()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.467() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ohash_dump_stream(%struct.ohash_t* nocapture readnone %ohash) unnamed_addr #0 {
entry:
  call fastcc void @cass_write_uint32.471()
  unreachable
}

; Function Attrs: noinline noreturn nounwind uwtable
define internal fastcc void @cass_write_uint32.471() unnamed_addr #10 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @468, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 88, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__PRETTY_FUNCTION__.cass_write_uint32.516, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias i8** @__array2matrix(i32 %row, i32 %col, i32 %size, i8* %data) unnamed_addr #0 {
entry:
  %add = add i32 %row, 1
  %conv = zext i32 %add to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @469, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %0 = bitcast i8* %call to i8**
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @470, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.493, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 74, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__PRETTY_FUNCTION__.__array2matrix, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  store i8* %data, i8** %0, align 8
  %cmp3 = icmp eq i8* %data, null
  br i1 %cmp3, label %if.else6, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end
  %mul11 = mul i32 %col, %size
  %idx.ext = zext i32 %mul11 to i64
  %1 = zext i32 %row to i64
  br label %for.cond

if.else6:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @471, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.5.494, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 76, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__PRETTY_FUNCTION__.__array2matrix, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 1, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %2 = phi i8* [ %data, %for.cond.preheader ], [ %add.ptr, %for.inc ]
  %cmp8 = icmp ult i64 %indvars.iv, %1
  br i1 %cmp8, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %add.ptr = getelementptr i8, i8* %2, i64 %idx.ext
  %arrayidx13 = getelementptr inbounds i8*, i8** %0, i64 %indvars.iv
  store i8* %add.ptr, i8** %arrayidx13, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %idxprom14 = zext i32 %row to i64
  %arrayidx15 = getelementptr inbounds i8*, i8** %0, i64 %idxprom14
  store i8* null, i8** %arrayidx15, align 8
  ret i8** %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias i8** @__matrix_alloc(i32 %row, i32 %col, i32 %size) unnamed_addr #0 {
entry:
  %add = add i32 %row, 1
  %conv = zext i32 %add to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @472, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %mul) #11
  %0 = bitcast i8* %call to i8**
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @473, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.493, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 96, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__PRETTY_FUNCTION__.__matrix_alloc, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %mul2 = mul i32 %row, %col
  %conv3 = zext i32 %mul2 to i64
  %conv4 = zext i32 %size to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @474, i32 0, i32 0))
  %call5 = call noalias i8* @calloc(i64 %conv3, i64 %conv4) #11
  store i8* %call5, i8** %0, align 8
  %cmp7 = icmp eq i8* %call5, null
  br i1 %cmp7, label %if.else10, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end
  %mul15 = mul i32 %col, %size
  %idx.ext = zext i32 %mul15 to i64
  br label %for.cond

if.else10:                                        ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @475, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.5.494, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 98, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__PRETTY_FUNCTION__.__matrix_alloc, i64 0, i64 0)) #16
  unreachable

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %1 = phi i8* [ %add.ptr, %for.inc ], [ %call5, %for.cond.preheader ]
  %i.0 = phi i32 [ %inc, %for.inc ], [ 1, %for.cond.preheader ]
  %cmp12 = icmp ugt i32 %i.0, %row
  br i1 %cmp12, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  %idxprom16 = zext i32 %i.0 to i64
  %arrayidx17 = getelementptr inbounds i8*, i8** %0, i64 %idxprom16
  store i8* %add.ptr, i8** %arrayidx17, align 8
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %idxprom18 = zext i32 %row to i64
  %arrayidx19 = getelementptr inbounds i8*, i8** %0, i64 %idxprom18
  %2 = bitcast i8** %arrayidx19 to i64*
  %3 = load i64, i64* %2, align 8
  %4 = bitcast i8* %call to i64*
  %5 = load i64, i64* %4, align 8
  %sub.ptr.sub = sub i64 %3, %5
  %mul22 = mul i32 %mul2, %size
  %conv23 = zext i32 %mul22 to i64
  %cmp24 = icmp eq i64 %sub.ptr.sub, %conv23
  br i1 %cmp24, label %if.end28, label %if.else27

if.else27:                                        ; preds = %for.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @476, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.6.497, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 103, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__PRETTY_FUNCTION__.__matrix_alloc, i64 0, i64 0)) #16
  unreachable

if.end28:                                         ; preds = %for.end
  store i8* null, i8** %arrayidx19, align 8
  ret i8** %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @__matrix_free(i8** nocapture %data) unnamed_addr #0 {
entry:
  %0 = load i8*, i8** %data, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @477, i32 0, i32 0))
  call void @free(i8* %0) #11
  %1 = bitcast i8** %data to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @478, i32 0, i32 0))
  call void @free(i8* %1) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @matrix_load_stream(%struct._IO_FILE* nocapture %fin, i32* nocapture %size, i32* nocapture %row, i32* nocapture %col, i8*** nocapture %matrix) unnamed_addr #0 {
entry:
  store i32 0, i32* %row, align 4
  store i32 0, i32* %col, align 4
  store i32 0, i32* %size, align 4
  %call = call fastcc i32 @cass_read_uint32.502(i32* %size, %struct._IO_FILE* %fin)
  %call1 = call fastcc i32 @cass_read_uint32.502(i32* %row, %struct._IO_FILE* %fin)
  %add = add nsw i32 %call, %call1
  %call2 = call fastcc i32 @cass_read_uint32.502(i32* %col, %struct._IO_FILE* %fin)
  %add3 = add nsw i32 %add, %call2
  %cmp = icmp eq i32 %add3, 3
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @479, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.7.503, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 126, i8* getelementptr inbounds ([86 x i8], [86 x i8]* @__PRETTY_FUNCTION__.matrix_load_stream, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %row, align 4
  %1 = load i32, i32* %col, align 4
  %2 = load i32, i32* %size, align 4
  %call4 = call fastcc i8** @__matrix_alloc(i32 %0, i32 %1, i32 %2)
  %cmp5 = icmp eq i8** %call4, null
  br i1 %cmp5, label %if.else7, label %if.end8

if.else7:                                         ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @480, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.504, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 128, i8* getelementptr inbounds ([86 x i8], [86 x i8]* @__PRETTY_FUNCTION__.matrix_load_stream, i64 0, i64 0)) #16
  unreachable

if.end8:                                          ; preds = %if.end
  %3 = load i32, i32* %row, align 4
  %4 = load i32, i32* %col, align 4
  %mul = mul i32 %3, %4
  %5 = load i8*, i8** %call4, align 8
  %6 = load i32, i32* %size, align 4
  %call9 = call fastcc i32 @cass_read.505(i8* %5, i32 %6, i32 %mul, %struct._IO_FILE* %fin)
  %cmp10 = icmp eq i32 %call9, %mul
  br i1 %cmp10, label %if.end13, label %if.else12

if.else12:                                        ; preds = %if.end8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @481, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.9.506, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 131, i8* getelementptr inbounds ([86 x i8], [86 x i8]* @__PRETTY_FUNCTION__.matrix_load_stream, i64 0, i64 0)) #16
  unreachable

if.end13:                                         ; preds = %if.end8
  store i8** %call4, i8*** %matrix, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read_uint32.502(i32* nocapture %buf, %struct._IO_FILE* nocapture %in) unnamed_addr #0 {
entry:
  %0 = bitcast i32* %buf to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @482, i32 0, i32 0))
  %call = call i64 @fread(i8* %0, i64 4, i64 1, %struct._IO_FILE* %in)
  %conv = trunc i64 %call to i32
  %call1 = call fastcc i32 @isLittleEndian.507()
  %tobool = icmp eq i32 %call1, 0
  br i1 %tobool, label %for.cond.preheader, label %if.end

for.cond.preheader:                               ; preds = %entry
  %sext = shl i64 %call, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %if.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i32, i32* %buf, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx, align 4
  %or15 = call i32 @llvm.bswap.i32(i32 %2)
  store i32 %or15, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @cass_read.505(i8* nocapture %p, i32 %size, i32 %nmemb, %struct._IO_FILE* nocapture %f) unnamed_addr #0 {
entry:
  %call = call fastcc i32 @isLittleEndian.507()
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @483, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.17.509, i64 0, i64 0), i32 22, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__PRETTY_FUNCTION__.cass_read.510, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %conv = zext i32 %size to i64
  %conv1 = zext i32 %nmemb to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @484, i32 0, i32 0))
  %call2 = call i64 @fread(i8* %p, i64 %conv, i64 %conv1, %struct._IO_FILE* %f)
  %conv3 = trunc i64 %call2 to i32
  ret i32 %conv3
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc i32 @isLittleEndian.507() unnamed_addr #7 {
entry:
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias i8*** @__matrix3_alloc(i32 %num, i32 %row, i32 %col, i32 %size) unnamed_addr #0 {
entry:
  %add = add i32 %num, 1
  %conv = zext i32 %add to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @485, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 %conv, i64 8) #11
  %0 = bitcast i8* %call to i8***
  %1 = zext i32 %num to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %cmp = icmp ult i64 %indvars.iv, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call2 = call fastcc i8** @__matrix_alloc(i32 %row, i32 %col, i32 %size)
  %arrayidx = getelementptr inbounds i8**, i8*** %0, i64 %indvars.iv
  store i8** %call2, i8*** %arrayidx, align 8
  %cmp5 = icmp eq i8** %call2, null
  br i1 %cmp5, label %if.else, label %for.inc

if.else:                                          ; preds = %for.body
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @486, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.15.522, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.1.490, i64 0, i64 0), i32 198, i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__PRETTY_FUNCTION__.__matrix3_alloc, i64 0, i64 0)) #16
  unreachable

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %idxprom7 = zext i32 %num to i64
  %arrayidx8 = getelementptr inbounds i8**, i8*** %0, i64 %idxprom7
  store i8** null, i8*** %arrayidx8, align 8
  ret i8*** %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @__matrix3_free(i8*** nocapture %data) unnamed_addr #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i8**, i8*** %data, i64 %indvars.iv
  %0 = load i8**, i8*** %arrayidx, align 8
  %cmp = icmp eq i8** %0, null
  br i1 %cmp, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  call fastcc void @__matrix_free(i8** nonnull %0)
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %1 = bitcast i8*** %data to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @487, i32 0, i32 0))
  call void @free(i8* %1) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_init(%struct.LSH_query_t* %query, %struct.LSH_t* %lsh, %struct.cass_dataset_t* %ds, i32 %K, i32 %L, i32 %T) unnamed_addr #0 {
entry:
  %0 = bitcast %struct.LSH_query_t* %query to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 144, i32 8, i1 false)
  %lsh1 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  store %struct.LSH_t* %lsh, %struct.LSH_t** %lsh1, align 8
  %ds2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 1
  store %struct.cass_dataset_t* %ds, %struct.cass_dataset_t** %ds2, align 8
  %K3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  store i32 %K, i32* %K3, align 8
  %L4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  store i32 %L, i32* %L4, align 4
  %T5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  store i32 %T, i32* %T5, align 8
  %count = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 4
  %1 = load i32, i32* %count, align 8
  %call = call fastcc %struct.bitmap_t* @bitmap_new(i32 %1)
  %bitmap = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 5
  store %struct.bitmap_t* %call, %struct.bitmap_t** %bitmap, align 8
  %L6 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 2
  %2 = load i32, i32* %L6, align 8
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %3 = load i32, i32* %M, align 4
  %call7 = call fastcc i8** @__matrix_alloc(i32 %2, i32 %3, i32 4)
  %tmp = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 6
  %4 = bitcast i32*** %tmp to i8***
  store i8** %call7, i8*** %4, align 8
  %cmp = icmp eq i8** %call7, null
  br i1 %cmp, label %if.else, label %if.end

if.else:                                          ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @488, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.525, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 40, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %L6, align 8
  %conv = zext i32 %5 to i64
  %mul = shl nuw nsw i64 %conv, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @489, i32 0, i32 0))
  %call10 = call noalias i8* @malloc(i64 %mul) #11
  %tmp2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 7
  %6 = bitcast i32** %tmp2 to i8**
  store i8* %call10, i8** %6, align 8
  %cmp12 = icmp eq i8* %call10, null
  br i1 %cmp12, label %if.else15, label %if.end16

if.else15:                                        ; preds = %if.end
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @490, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.2.527, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 42, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end16:                                         ; preds = %if.end
  %7 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %M18 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %7, i64 0, i32 1
  %8 = load i32, i32* %M18, align 4
  %mul19 = shl i32 %8, 1
  %call20 = call fastcc i8** @__matrix_alloc(i32 %L, i32 %mul19, i32 24)
  %ptb = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 8
  %9 = bitcast %struct.ptb_vec_t*** %ptb to i8***
  store i8** %call20, i8*** %9, align 8
  %cmp22 = icmp eq i8** %call20, null
  br i1 %cmp22, label %if.else25, label %if.end26

if.else25:                                        ; preds = %if.end16
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @491, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.528, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 45, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end26:                                         ; preds = %if.end16
  %10 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %M29 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %10, i64 0, i32 1
  %11 = load i32, i32* %M29, align 4
  %call30 = call fastcc %struct.ptb_vec_t* @gen_score(i32 %11)
  %cmp31 = icmp eq %struct.ptb_vec_t* %call30, null
  br i1 %cmp31, label %if.else34, label %if.end35

if.else34:                                        ; preds = %if.end26
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @492, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4.529, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 56, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end35:                                         ; preds = %if.end26
  %conv36 = zext i32 %T to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @493, i32 0, i32 0))
  %call37 = call noalias i8* @calloc(i64 24, i64 %conv36) #11
  %ptb_set = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 10
  %12 = bitcast %struct.ptb_vec_t** %ptb_set to i8**
  store i8* %call37, i8** %12, align 8
  %cmp39 = icmp eq i8* %call37, null
  br i1 %cmp39, label %if.else42, label %if.end43

if.else42:                                        ; preds = %if.end35
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @494, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.530, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 58, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end43:                                         ; preds = %if.end35
  %13 = bitcast i8* %call37 to %struct.ptb_vec_t*
  %14 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %M46 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %14, i64 0, i32 1
  %15 = load i32, i32* %M46, align 4
  call fastcc void @gen_perturb_set(%struct.ptb_vec_t* nonnull %call30, %struct.ptb_vec_t* %13, i32 %15, i32 %T)
  %call48 = call fastcc i8** @__matrix_alloc(i32 %L, i32 %T, i32 24)
  %ptb_vec = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 11
  %16 = bitcast %struct.ptb_vec_t*** %ptb_vec to i8***
  store i8** %call48, i8*** %16, align 8
  %cmp50 = icmp eq i8** %call48, null
  br i1 %cmp50, label %if.else53, label %if.end54

if.else53:                                        ; preds = %if.end43
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @495, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.531, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 61, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end54:                                         ; preds = %if.end43
  %conv55 = zext i32 %L to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @496, i32 0, i32 0))
  %call56 = call noalias i8* @calloc(i64 4, i64 %conv55) #11
  %ptb_step = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 9
  %17 = bitcast i32** %ptb_step to i8**
  store i8* %call56, i8** %17, align 8
  %cmp58 = icmp eq i8* %call56, null
  br i1 %cmp58, label %if.else61, label %if.end62

if.else61:                                        ; preds = %if.end54
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @497, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.7.532, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 63, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end62:                                         ; preds = %if.end54
  %18 = bitcast %struct.ptb_vec_t* %call30 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @498, i32 0, i32 0))
  call void @free(i8* %18) #11
  %conv63 = zext i32 %K to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @499, i32 0, i32 0))
  %call64 = call noalias i8* @calloc(i64 8, i64 %conv63) #11
  %topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %19 = bitcast %struct.cass_list_entry_t** %topk to i8**
  store i8* %call64, i8** %19, align 8
  %call65 = call fastcc i8** @__matrix_alloc(i32 %L, i32 %K, i32 8)
  %_topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 13
  %20 = bitcast %struct.cass_list_entry_t*** %_topk to i8***
  store i8** %call65, i8*** %20, align 8
  %21 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, align 8
  %cmp67 = icmp eq %struct.cass_list_entry_t* %21, null
  br i1 %cmp67, label %if.else70, label %if.end71

if.else70:                                        ; preds = %if.end62
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @500, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.8.533, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 70, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end71:                                         ; preds = %if.end62
  %cmp73 = icmp eq i8** %call65, null
  br i1 %cmp73, label %if.else76, label %if.end77

if.else76:                                        ; preds = %if.end71
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @501, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.9.534, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 71, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end77:                                         ; preds = %if.end71
  %mul79 = shl nuw nsw i64 %conv55, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @502, i32 0, i32 0))
  %call80 = call noalias i8* @malloc(i64 %mul79) #11
  %C = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 14
  %22 = bitcast i32** %C to i8**
  store i8* %call80, i8** %22, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @503, i32 0, i32 0))
  %call83 = call noalias i8* @malloc(i64 %mul79) #11
  %H = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 15
  %23 = bitcast i32** %H to i8**
  store i8* %call83, i8** %23, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @504, i32 0, i32 0))
  %call86 = call noalias i8* @malloc(i64 %mul79) #11
  %S = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 16
  %24 = bitcast float** %S to i8**
  store i8* %call86, i8** %24, align 8
  %cmp88 = icmp eq i8* %call80, null
  br i1 %cmp88, label %if.else91, label %if.end92

if.else91:                                        ; preds = %if.end77
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @505, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.10.535, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 77, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end92:                                         ; preds = %if.end77
  %cmp94 = icmp eq i8* %call83, null
  br i1 %cmp94, label %if.else97, label %if.end98

if.else97:                                        ; preds = %if.end92
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @506, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.11.536, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 78, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end98:                                         ; preds = %if.end92
  %cmp100 = icmp eq i8* %call86, null
  br i1 %cmp100, label %if.else103, label %if.end104

if.else103:                                       ; preds = %if.end98
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @507, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.12.537, i64 0, i64 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.1.526, i64 0, i64 0), i32 79, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__PRETTY_FUNCTION__.LSH_query_init, i64 0, i64 0)) #16
  unreachable

if.end104:                                        ; preds = %if.end98
  %gamma = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 20
  store float 1.000000e+00, float* %gamma, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_cleanup(%struct.LSH_query_t* nocapture %query) unnamed_addr #0 {
entry:
  %bitmap = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 5
  call fastcc void @bitmap_free(%struct.bitmap_t** %bitmap)
  %tmp = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 6
  %0 = bitcast i32*** %tmp to i8***
  %1 = load i8**, i8*** %0, align 8
  call fastcc void @__matrix_free(i8** %1)
  %_topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 13
  %2 = bitcast %struct.cass_list_entry_t*** %_topk to i8***
  %3 = load i8**, i8*** %2, align 8
  call fastcc void @__matrix_free(i8** %3)
  %topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %4 = bitcast %struct.cass_list_entry_t** %topk to i8**
  %5 = load i8*, i8** %4, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @508, i32 0, i32 0))
  call void @free(i8* %5) #11
  %tmp2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 7
  %6 = bitcast i32** %tmp2 to i8**
  %7 = load i8*, i8** %6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @509, i32 0, i32 0))
  call void @free(i8* %7) #11
  %ptb_step = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 9
  %8 = bitcast i32** %ptb_step to i8**
  %9 = load i8*, i8** %8, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @510, i32 0, i32 0))
  call void @free(i8* %9) #11
  %ptb_set = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 10
  %10 = bitcast %struct.ptb_vec_t** %ptb_set to i8**
  %11 = load i8*, i8** %10, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @511, i32 0, i32 0))
  call void @free(i8* %11) #11
  %ptb_vec = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 11
  %12 = bitcast %struct.ptb_vec_t*** %ptb_vec to i8***
  %13 = load i8**, i8*** %12, align 8
  call fastcc void @__matrix_free(i8** %13)
  %ptb = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 8
  %14 = bitcast %struct.ptb_vec_t*** %ptb to i8***
  %15 = load i8**, i8*** %14, align 8
  call fastcc void @__matrix_free(i8** %15)
  %C = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 14
  %16 = bitcast i32** %C to i8**
  %17 = load i8*, i8** %16, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @512, i32 0, i32 0))
  call void @free(i8* %17) #11
  %H = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 15
  %18 = bitcast i32** %H to i8**
  %19 = load i8*, i8** %18, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @513, i32 0, i32 0))
  call void @free(i8* %19) #11
  %S = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 16
  %20 = bitcast float** %S to i8**
  %21 = load i8*, i8** %20, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @514, i32 0, i32 0))
  call void @free(i8* %21) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_hash_score(%struct.LSH_t* nocapture readonly %lsh, i32 %L, float* nocapture readonly %pnt, i32** nocapture readonly %hash, %struct.ptb_vec_t** nocapture readonly %ptb) unnamed_addr #0 {
entry:
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %betas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 7
  %D = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 0
  %alphas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 6
  %W = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 5
  %0 = sext i32 %L to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc68, %entry
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc68 ], [ 0, %entry ]
  %l.0 = phi i64 [ %indvars.iv6, %for.inc68 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv8, %0
  br i1 %cmp, label %for.cond1.preheader, label %for.end70

for.cond1.preheader:                              ; preds = %for.cond
  %arrayidx18 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv8
  %arrayidx27 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %ptb, i64 %indvars.iv8
  %sext = shl i64 %l.0, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc65
  %indvars.iv6 = phi i64 [ %1, %for.cond1.preheader ], [ %indvars.iv.next7, %for.inc65 ]
  %indvars.iv3 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next4, %for.inc65 ]
  %indvars.iv1 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next2, %for.inc65 ]
  %2 = load i32, i32* %M, align 4
  %3 = zext i32 %2 to i64
  %cmp2 = icmp ult i64 %indvars.iv1, %3
  br i1 %cmp2, label %for.body3, label %for.inc68

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %betas, align 8
  %arrayidx = getelementptr inbounds float, float* %4, i64 %indvars.iv6
  %5 = load float, float* %arrayidx, align 4
  %6 = load i32, i32* %D, align 8
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body3
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body3 ]
  %s.0 = phi float [ %add, %for.inc ], [ %5, %for.body3 ]
  %wide.trip.count = zext i32 %6 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc65, label %for.inc

for.inc:                                          ; preds = %for.cond4
  %arrayidx8 = getelementptr inbounds float, float* %pnt, i64 %indvars.iv
  %7 = load float, float* %arrayidx8, align 4
  %8 = load float**, float*** %alphas, align 8
  %arrayidx10 = getelementptr inbounds float*, float** %8, i64 %indvars.iv6
  %9 = load float*, float** %arrayidx10, align 8
  %arrayidx12 = getelementptr inbounds float, float* %9, i64 %indvars.iv
  %10 = load float, float* %arrayidx12, align 4
  %mul = fmul float %7, %10
  %add = fadd float %s.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond4

for.inc65:                                        ; preds = %for.cond4
  %11 = load float*, float** %W, align 8
  %arrayidx14 = getelementptr inbounds float, float* %11, i64 %indvars.iv8
  %12 = load float, float* %arrayidx14, align 4
  %div = fdiv float %s.0, %12
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @515, i32 0, i32 0))
  %floorf = call float @floorf(float %div) #13
  %conv16 = fptoui float %floorf to i32
  %13 = load i32*, i32** %arrayidx18, align 8
  %arrayidx20 = getelementptr inbounds i32, i32* %13, i64 %indvars.iv1
  store i32 %conv16, i32* %arrayidx20, align 4
  %14 = load float*, float** %W, align 8
  %arrayidx23 = getelementptr inbounds float, float* %14, i64 %indvars.iv8
  %15 = load float, float* %arrayidx23, align 4
  %mul24 = fmul float %floorf, %15
  %sub = fsub float %s.0, %mul24
  %16 = trunc i64 %indvars.iv1 to i32
  %shl = shl i32 1, %16
  %conv25 = sext i32 %shl to i64
  %17 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %set = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %17, i64 %indvars.iv3, i32 0
  store i64 %conv25, i64* %set, align 8
  %18 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %dir = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %18, i64 %indvars.iv3, i32 2
  store i32 0, i32* %dir, align 4
  %mul34 = fmul float %sub, %sub
  %19 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %key = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %19, i64 %indvars.iv3, i32 1
  store float %mul34, float* %key, align 8
  %20 = or i64 %indvars.iv3, 1
  %21 = load float*, float** %W, align 8
  %arrayidx42 = getelementptr inbounds float, float* %21, i64 %indvars.iv8
  %22 = load float, float* %arrayidx42, align 4
  %sub43 = fsub float %22, %sub
  %23 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %set50 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %23, i64 %20, i32 0
  store i64 %conv25, i64* %set50, align 8
  %24 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %dir56 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %24, i64 %20, i32 2
  store i32 %shl, i32* %dir56, align 4
  %mul57 = fmul float %sub43, %sub43
  %25 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx27, align 8
  %key62 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %25, i64 %20, i32 1
  store float %mul57, float* %key62, align 8
  %indvars.iv.next7 = add i64 %indvars.iv6, 1
  %indvars.iv.next4 = add nuw i64 %indvars.iv3, 2
  %indvars.iv.next2 = add nuw i64 %indvars.iv1, 1
  br label %for.cond1

for.inc68:                                        ; preds = %for.cond1
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  br label %for.cond

for.end70:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @LSH_hash2_noperturb(%struct.LSH_t* nocapture readonly %lsh, i32** nocapture readonly %hash, i32* nocapture %hash2, i32 %L) unnamed_addr #8 {
entry:
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %rnd = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 8
  %H = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 3
  %0 = sext i32 %L to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc12, %entry
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc12 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv1, %0
  br i1 %cmp, label %for.cond1.preheader, label %for.end14

for.cond1.preheader:                              ; preds = %for.cond
  %1 = load i32, i32* %M, align 4
  %arrayidx7 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv1
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]
  %h.0 = phi i32 [ 0, %for.cond1.preheader ], [ %add, %for.inc ]
  %wide.trip.count = zext i32 %1 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc12, label %for.inc

for.inc:                                          ; preds = %for.cond1
  %2 = load i32**, i32*** %rnd, align 8
  %arrayidx = getelementptr inbounds i32*, i32** %2, i64 %indvars.iv1
  %3 = load i32*, i32** %arrayidx, align 8
  %arrayidx5 = getelementptr inbounds i32, i32* %3, i64 %indvars.iv
  %4 = load i32, i32* %arrayidx5, align 4
  %5 = load i32*, i32** %arrayidx7, align 8
  %arrayidx9 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %6 = load i32, i32* %arrayidx9, align 4
  %mul = mul i32 %4, %6
  %add = add i32 %h.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond1

for.inc12:                                        ; preds = %for.cond1
  %7 = load i32, i32* %H, align 4
  %rem = urem i32 %h.0, %7
  %arrayidx11 = getelementptr inbounds i32, i32* %hash2, i64 %indvars.iv1
  store i32 %rem, i32* %arrayidx11, align 4
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end14:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @LSH_hash2_perturb(%struct.LSH_t* nocapture readonly %lsh, i32** nocapture readonly %hash, i32* nocapture %hash2, i64 %ptb.0.0.val, i32 %ptb.0.2.val, i32 %l) unnamed_addr #8 {
entry:
  %conv = trunc i64 %ptb.0.0.val to i32
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %0 = load i32, i32* %M, align 4
  %rnd26 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 8
  %idxprom27 = sext i32 %l to i64
  %arrayidx32 = getelementptr inbounds i32*, i32** %hash, i64 %idxprom27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %mask.0 = phi i32 [ %shl, %for.inc ], [ 1, %entry ]
  %h.0 = phi i32 [ %h.2, %for.inc ], [ 0, %entry ]
  %wide.trip.count = zext i32 %0 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond
  %and = and i32 %conv, %mask.0
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else25, label %if.then

if.then:                                          ; preds = %for.body
  %and4 = and i32 %mask.0, %ptb.0.2.val
  %tobool5 = icmp eq i32 %and4, 0
  %1 = load i32**, i32*** %rnd26, align 8
  %arrayidx16 = getelementptr inbounds i32*, i32** %1, i64 %idxprom27
  %2 = load i32*, i32** %arrayidx16, align 8
  %arrayidx18 = getelementptr inbounds i32, i32* %2, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx18, align 4
  %4 = load i32*, i32** %arrayidx32, align 8
  %arrayidx22 = getelementptr inbounds i32, i32* %4, i64 %indvars.iv
  %5 = load i32, i32* %arrayidx22, align 4
  br i1 %tobool5, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.then
  %add = add i32 %5, 1
  %mul = mul i32 %3, %add
  br label %for.inc

if.else:                                          ; preds = %if.then
  %sub = add i32 %5, -1
  %mul23 = mul i32 %3, %sub
  br label %for.inc

if.else25:                                        ; preds = %for.body
  %6 = load i32**, i32*** %rnd26, align 8
  %arrayidx28 = getelementptr inbounds i32*, i32** %6, i64 %idxprom27
  %7 = load i32*, i32** %arrayidx28, align 8
  %arrayidx30 = getelementptr inbounds i32, i32* %7, i64 %indvars.iv
  %8 = load i32, i32* %arrayidx30, align 4
  %9 = load i32*, i32** %arrayidx32, align 8
  %arrayidx34 = getelementptr inbounds i32, i32* %9, i64 %indvars.iv
  %10 = load i32, i32* %arrayidx34, align 4
  %mul35 = mul i32 %8, %10
  br label %for.inc

for.inc:                                          ; preds = %if.else25, %if.else, %if.then6
  %mul.pn.pn = phi i32 [ %mul35, %if.else25 ], [ %mul, %if.then6 ], [ %mul23, %if.else ]
  %h.2 = add i32 %h.0, %mul.pn.pn
  %shl = shl i32 %mask.0, 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %H = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 3
  %11 = load i32, i32* %H, align 4
  %rem = urem i32 %h.0, %11
  store i32 %rem, i32* %hash2, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_merge(%struct.LSH_query_t* nocapture readonly %query) unnamed_addr #0 {
do.body:
  %K1 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %0 = load i32, i32* %K1, align 8
  %L2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %1 = load i32, i32* %L2, align 4
  %_topk3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 13
  %2 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %_topk3, align 8
  %topk4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %3 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk4, align 8
  %4 = bitcast %struct.cass_list_entry_t* %3 to i8*
  %conv = zext i32 %0 to i64
  %mul = shl nuw nsw i64 %conv, 3
  call void @llvm.memset.p0i8.i64(i8* %4, i8 -1, i64 %mul, i32 4, i1 false)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %for.inc ], [ 0, %do.body ]
  %wide.trip.count13 = zext i32 %0 to i64
  %exitcond14 = icmp eq i64 %indvars.iv11, %wide.trip.count13
  br i1 %exitcond14, label %for.cond6.preheader, label %for.inc

for.cond6.preheader:                              ; preds = %for.cond
  %5 = zext i32 %0 to i64
  br label %for.cond6

for.inc:                                          ; preds = %for.cond
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %indvars.iv11, i32 1
  store float 0x7FF0000000000000, float* %dist, align 4
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  br label %for.cond

for.cond6:                                        ; preds = %for.cond6.preheader, %for.inc67
  %indvars.iv7 = phi i64 [ 0, %for.cond6.preheader ], [ %indvars.iv.next8, %for.inc67 ]
  %wide.trip.count9 = zext i32 %1 to i64
  %exitcond10 = icmp eq i64 %indvars.iv7, %wide.trip.count9
  br i1 %exitcond10, label %for.end69, label %for.cond10.preheader

for.cond10.preheader:                             ; preds = %for.cond6
  %arrayidx19 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %2, i64 %indvars.iv7
  br label %for.cond10

for.cond10:                                       ; preds = %for.cond10.preheader, %for.inc64
  %indvars.iv5 = phi i64 [ 0, %for.cond10.preheader ], [ %indvars.iv.next6, %for.inc64 ]
  %wide.trip.count = zext i32 %0 to i64
  %exitcond = icmp eq i64 %indvars.iv5, %wide.trip.count
  br i1 %exitcond, label %for.inc67, label %while.cond

while.cond:                                       ; preds = %for.cond10, %if.end38
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end38 ], [ 0, %for.cond10 ]
  %cmp16 = icmp ult i64 %indvars.iv, %5
  %6 = trunc i64 %indvars.iv to i32
  br i1 %cmp16, label %while.body, label %if.end41

while.body:                                       ; preds = %while.cond
  %7 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx19, align 8
  %dist22 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %7, i64 %indvars.iv5, i32 1
  %8 = load float, float* %dist22, align 4
  %dist25 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %indvars.iv, i32 1
  %9 = load float, float* %dist25, align 4
  %cmp26 = fcmp ogt float %8, %9
  br i1 %cmp26, label %if.end41, label %if.end

if.end:                                           ; preds = %while.body
  %id = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %7, i64 %indvars.iv5, i32 0
  %10 = load i32, i32* %id, align 4
  %id34 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %indvars.iv, i32 0
  %11 = load i32, i32* %id34, align 4
  %cmp35 = icmp eq i32 %10, %11
  br i1 %cmp35, label %for.inc64, label %if.end38

if.end38:                                         ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %while.cond

if.end41:                                         ; preds = %while.cond, %while.body
  %cmp42 = icmp eq i32 %6, 0
  br i1 %cmp42, label %for.inc64, label %for.cond46.preheader

for.cond46.preheader:                             ; preds = %if.end41
  %sub = shl i64 %indvars.iv, 32
  %sext = add i64 %sub, -4294967296
  %12 = ashr exact i64 %sext, 32
  br label %for.cond46

for.cond46:                                       ; preds = %for.cond46.preheader, %for.inc54
  %indvars.iv3 = phi i64 [ 0, %for.cond46.preheader ], [ %indvars.iv.next4, %for.inc54 ]
  %cmp47 = icmp slt i64 %indvars.iv3, %12
  br i1 %cmp47, label %for.inc54, label %for.end56

for.inc54:                                        ; preds = %for.cond46
  %arrayidx51 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %indvars.iv3
  %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1
  %arrayidx53 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %indvars.iv.next4
  %13 = bitcast %struct.cass_list_entry_t* %arrayidx53 to i64*
  %14 = bitcast %struct.cass_list_entry_t* %arrayidx51 to i64*
  %15 = load i64, i64* %13, align 4
  store i64 %15, i64* %14, align 4
  br label %for.cond46

for.end56:                                        ; preds = %for.cond46
  %sext15 = shl i64 %indvars.iv3, 32
  %idxprom57 = ashr exact i64 %sext15, 32
  %arrayidx58 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %3, i64 %idxprom57
  %16 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx19, align 8
  %arrayidx62 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %16, i64 %indvars.iv5
  %17 = bitcast %struct.cass_list_entry_t* %arrayidx62 to i64*
  %18 = bitcast %struct.cass_list_entry_t* %arrayidx58 to i64*
  %19 = load i64, i64* %17, align 4
  store i64 %19, i64* %18, align 4
  br label %for.inc64

for.inc64:                                        ; preds = %if.end, %for.end56, %if.end41
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  br label %for.cond10

for.inc67:                                        ; preds = %for.cond10
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  br label %for.cond6

for.end69:                                        ; preds = %for.cond6
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query(%struct.LSH_query_t* %query, float* nocapture readonly %point) unnamed_addr #0 {
entry:
  %lsh = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  %est1 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 12
  %1 = load %struct.LSH_est_t*, %struct.LSH_est_t** %est1, align 8
  %topk2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %2 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk2, align 8
  %dist3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 18
  %3 = load float, float* %dist3, align 4
  %T4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  %4 = load i32, i32* %T4, align 8
  %L5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %5 = load i32, i32* %L5, align 4
  %CC = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 17
  store i32 0, i32* %CC, align 8
  call fastcc void @LSH_query_bootstrap(%struct.LSH_query_t* %query, float* %point)
  %cmp9 = icmp eq %struct.LSH_est_t* %1, null
  %dist10 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %2, i64 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc14, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc15, %for.inc14 ]
  %cmp = icmp ult i32 %i.0, %5
  br i1 %cmp, label %for.cond6, label %for.end16

for.cond6:                                        ; preds = %for.cond, %for.inc
  %j.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond ]
  %cmp7 = icmp ult i32 %j.0, %4
  br i1 %cmp7, label %for.body8, label %for.inc14

for.body8:                                        ; preds = %for.cond6
  br i1 %cmp9, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body8
  %6 = load float, float* %dist10, align 4
  %cmp11 = fcmp ugt float %6, %3
  br i1 %cmp11, label %for.inc, label %return

for.inc:                                          ; preds = %for.body8, %if.then
  call fastcc void @LSH_query_probe(%struct.LSH_query_t* %query, float* %point, i32 %i.0, i32 0)
  %inc = add nuw nsw i32 %j.0, 1
  br label %for.cond6

for.inc14:                                        ; preds = %for.cond6
  %inc15 = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.end16:                                        ; preds = %for.cond
  call fastcc void @LSH_query_merge(%struct.LSH_query_t* %query)
  br label %return

return:                                           ; preds = %if.then, %for.end16
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_bootstrap(%struct.LSH_query_t* %query, float* nocapture readonly %point) unnamed_addr #0 {
entry:
  %lsh = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  %D1 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 0
  %1 = load i32, i32* %D1, align 8
  %K2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %2 = load i32, i32* %K2, align 8
  %L3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %3 = load i32, i32* %L3, align 4
  %ptb = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 8
  %4 = load %struct.ptb_vec_t**, %struct.ptb_vec_t*** %ptb, align 8
  %tmp6 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 6
  %5 = load i32**, i32*** %tmp6, align 8
  %tmp28 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 7
  %6 = load i32*, i32** %tmp28, align 8
  %_topk10 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 13
  %7 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %_topk10, align 8
  %C14 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 14
  %8 = load i32*, i32** %C14, align 8
  %H16 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 15
  %9 = load i32*, i32** %H16, align 8
  %10 = bitcast i32* %8 to i8*
  %conv = zext i32 %3 to i64
  %mul = shl nuw nsw i64 %conv, 2
  call void @llvm.memset.p0i8.i64(i8* %10, i8 0, i64 %mul, i32 4, i1 false)
  %11 = bitcast i32* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 %mul, i32 4, i1 false)
  %S = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 16
  %12 = bitcast float** %S to i8**
  %13 = load i8*, i8** %12, align 8
  call void @llvm.memset.p0i8.i64(i8* %13, i8 0, i64 %mul, i32 4, i1 false)
  %bitmap = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 5
  %14 = load %struct.bitmap_t*, %struct.bitmap_t** %bitmap, align 8
  %.idx = getelementptr %struct.bitmap_t, %struct.bitmap_t* %14, i64 0, i32 0
  %.idx.val = load i32, i32* %.idx, align 8
  %.idx1 = getelementptr %struct.bitmap_t, %struct.bitmap_t* %14, i64 0, i32 2
  %.idx1.val = load i8*, i8** %.idx1, align 8
  call fastcc void @bitmap_clear(i32 %.idx.val, i8* %.idx1.val)
  %15 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  call fastcc void @LSH_hash_score(%struct.LSH_t* %15, i32 %3, float* %point, i32** %5, %struct.ptb_vec_t** %4)
  %16 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  call fastcc void @LSH_hash2_noperturb(%struct.LSH_t* %16, i32** %5, i32* %6, i32 %3)
  %conv25 = zext i32 %2 to i64
  %mul26 = shl nuw nsw i64 %conv25, 3
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 9
  %ds = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 1
  %CC = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 17
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 1
  %ptb_step = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 9
  %ptb_set = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 10
  %ptb_vec = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 11
  %T = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  %17 = zext i32 %2 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc146, %entry
  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %for.inc146 ], [ 0, %entry ]
  %wide.trip.count13 = zext i32 %3 to i64
  %exitcond14 = icmp eq i64 %indvars.iv11, %wide.trip.count13
  br i1 %exitcond14, label %for.end148, label %do.body

do.body:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %7, i64 %indvars.iv11
  %18 = bitcast %struct.cass_list_entry_t** %arrayidx to i8**
  %19 = load i8*, i8** %18, align 8
  call void @llvm.memset.p0i8.i64(i8* %19, i8 -1, i64 %mul26, i32 4, i1 false)
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc, %do.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %do.body ]
  %wide.trip.count = zext i32 %2 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.cond38.preheader, label %for.inc

for.cond38.preheader:                             ; preds = %for.cond28
  %arrayidx42 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv11
  %arrayidx71 = getelementptr inbounds i32, i32* %8, i64 %indvars.iv11
  %arrayidx127 = getelementptr inbounds i32, i32* %9, i64 %indvars.iv11
  br label %for.cond38

for.inc:                                          ; preds = %for.cond28
  %20 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx, align 8
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %20, i64 %indvars.iv, i32 1
  store float 0x7FF0000000000000, float* %dist, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond28

for.cond38:                                       ; preds = %for.cond38.preheader, %for.inc131
  %__array_foreach_index.0 = phi i32 [ %inc132, %for.inc131 ], [ 0, %for.cond38.preheader ]
  %21 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %21, i64 %indvars.iv11, i32 1
  %22 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %23 = load i32, i32* %arrayidx42, align 4
  %idxprom43 = zext i32 %23 to i64
  %len = getelementptr inbounds %struct.anon.5, %struct.anon.5* %22, i64 %idxprom43, i32 2
  %24 = load i32, i32* %len, align 8
  %cmp45 = icmp ult i32 %__array_foreach_index.0, %24
  br i1 %cmp45, label %for.body47, label %for.inc146

for.body47:                                       ; preds = %for.cond38
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %22, i64 %idxprom43, i32 3
  %25 = load i32*, i32** %data, align 8
  %idxprom57 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx58 = getelementptr inbounds i32, i32* %25, i64 %idxprom57
  %26 = load i32, i32* %arrayidx58, align 4
  %27 = load %struct.bitmap_t*, %struct.bitmap_t** %bitmap, align 8
  %call60 = call fastcc i32 @bitmap_contain(%struct.bitmap_t* %27, i32 %26)
  %tobool = icmp eq i32 %call60, 0
  br i1 %tobool, label %do.body74, label %for.inc131

do.body74:                                        ; preds = %for.body47
  call fastcc void @bitmap_insert(%struct.bitmap_t* %27, i32 %26)
  %28 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds, align 8
  %vec64 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %28, i64 0, i32 6
  %29 = load i8*, i8** %vec64, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %28, i64 0, i32 2
  %30 = load i32, i32* %vec_size, align 8
  %mul66 = mul i32 %26, %30
  %idx.ext = zext i32 %mul66 to i64
  %add.ptr = getelementptr inbounds i8, i8* %29, i64 %idx.ext
  %u = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %arraydecay = bitcast i8* %u to float*
  %call68 = call fastcc float @dist_L2_float.542(i32 %1, float* %arraydecay, float* %point)
  %31 = load i32, i32* %arrayidx71, align 4
  %inc72 = add nsw i32 %31, 1
  store i32 %inc72, i32* %arrayidx71, align 4
  %32 = load i32, i32* %CC, align 8
  %inc73 = add nsw i32 %32, 1
  store i32 %inc73, i32* %CC, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end98, %do.body74
  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %if.end98 ], [ 0, %do.body74 ]
  %cmp78 = icmp ult i64 %indvars.iv7, %17
  %33 = trunc i64 %indvars.iv7 to i32
  br i1 %cmp78, label %while.body, label %if.end102

while.body:                                       ; preds = %while.cond
  %34 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx, align 8
  %dist85 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %34, i64 %indvars.iv7, i32 1
  %35 = load float, float* %dist85, align 4
  %cmp86 = fcmp ogt float %call68, %35
  br i1 %cmp86, label %if.end102, label %if.end

if.end:                                           ; preds = %while.body
  %id94 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %34, i64 %indvars.iv7, i32 0
  %36 = load i32, i32* %id94, align 4
  %cmp95 = icmp eq i32 %26, %36
  br i1 %cmp95, label %for.inc131, label %if.end98

if.end98:                                         ; preds = %if.end
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  br label %while.cond

if.end102:                                        ; preds = %while.cond, %while.body
  %cmp103 = icmp eq i32 %33, 0
  br i1 %cmp103, label %for.inc131, label %for.cond107.preheader

for.cond107.preheader:                            ; preds = %if.end102
  %sub = shl i64 %indvars.iv7, 32
  %sext = add i64 %sub, -4294967296
  %37 = ashr exact i64 %sext, 32
  br label %for.cond107

for.cond107:                                      ; preds = %for.cond107.preheader, %for.inc119
  %indvars.iv9 = phi i64 [ 0, %for.cond107.preheader ], [ %indvars.iv.next10, %for.inc119 ]
  %cmp108 = icmp slt i64 %indvars.iv9, %37
  %38 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx, align 8
  br i1 %cmp108, label %for.inc119, label %for.end121

for.inc119:                                       ; preds = %for.cond107
  %arrayidx114 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %38, i64 %indvars.iv9
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  %arrayidx118 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %38, i64 %indvars.iv.next10
  %39 = bitcast %struct.cass_list_entry_t* %arrayidx118 to i64*
  %40 = bitcast %struct.cass_list_entry_t* %arrayidx114 to i64*
  %41 = load i64, i64* %39, align 4
  store i64 %41, i64* %40, align 4
  br label %for.cond107

for.end121:                                       ; preds = %for.cond107
  %sext15 = shl i64 %indvars.iv9, 32
  %idxprom124 = ashr exact i64 %sext15, 32
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %38, i64 %idxprom124, i32 0
  store i32 %26, i32* %.sroa_idx, align 4
  %.sroa_idx3 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %38, i64 %idxprom124, i32 1
  store float %call68, float* %.sroa_idx3, align 4
  %42 = load i32, i32* %arrayidx127, align 4
  %inc128 = add nsw i32 %42, 1
  store i32 %inc128, i32* %arrayidx127, align 4
  br label %for.inc131

for.inc131:                                       ; preds = %if.end, %for.body47, %if.end102, %for.end121
  %inc132 = add i32 %__array_foreach_index.0, 1
  br label %for.cond38

for.inc146:                                       ; preds = %for.cond38
  %arrayidx136 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %4, i64 %indvars.iv11
  %43 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx136, align 8
  %44 = load i32, i32* %M, align 4
  %mul137 = shl i32 %44, 1
  call fastcc void @ptb_qsort(%struct.ptb_vec_t* %43, i32 %mul137)
  %45 = load i32*, i32** %ptb_step, align 8
  %arrayidx139 = getelementptr inbounds i32, i32* %45, i64 %indvars.iv11
  store i32 0, i32* %arrayidx139, align 4
  %46 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %ptb_set, align 8
  %47 = load %struct.ptb_vec_t**, %struct.ptb_vec_t*** %ptb_vec, align 8
  %arrayidx141 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %47, i64 %indvars.iv11
  %48 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx141, align 8
  %49 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx136, align 8
  %50 = load i32, i32* %M, align 4
  %51 = load i32, i32* %T, align 8
  call fastcc void @map_perturb_vector(%struct.ptb_vec_t* %46, %struct.ptb_vec_t* %48, %struct.ptb_vec_t* %49, i32 %50, i32 %51)
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  br label %for.cond

for.end148:                                       ; preds = %for.cond
  %est = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 12
  %52 = load %struct.LSH_est_t*, %struct.LSH_est_t** %est, align 8
  %cmp149 = icmp eq %struct.LSH_est_t* %52, null
  br i1 %cmp149, label %if.end152, label %if.then151

if.then151:                                       ; preds = %for.end148
  call fastcc void @LSH_query_merge(%struct.LSH_query_t* %query)
  call fastcc void @LSH_query_local(%struct.LSH_query_t* %query)
  br label %if.end152

if.end152:                                        ; preds = %for.end148, %if.then151
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_probe(%struct.LSH_query_t* nocapture %query, float* nocapture readonly %point, i32 %l, i32 %g) unnamed_addr #0 {
entry:
  %h = alloca i32, align 4
  %lsh = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  %D1 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 0
  %1 = load i32, i32* %D1, align 8
  %K2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %2 = load i32, i32* %K2, align 8
  %tmp5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 6
  %3 = load i32**, i32*** %tmp5, align 8
  %cmp = icmp eq i32 %g, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %_topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 13
  %4 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %_topk, align 8
  %idxprom = sext i32 %l to i64
  %arrayidx = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %4, i64 %idxprom
  br label %do.body

cond.false:                                       ; preds = %entry
  %topk7 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %.pre = sext i32 %l to i64
  br label %do.body

do.body:                                          ; preds = %cond.true, %cond.false
  %idxprom16.pre-phi = phi i64 [ %idxprom, %cond.true ], [ %.pre, %cond.false ]
  %cond.in = phi %struct.cass_list_entry_t** [ %arrayidx, %cond.true ], [ %topk7, %cond.false ]
  %cond = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %cond.in, align 8
  %C12 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 14
  %5 = load i32*, i32** %C12, align 8
  %H14 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 15
  %6 = load i32*, i32** %H14, align 8
  %ptb_vec = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 11
  %7 = load %struct.ptb_vec_t**, %struct.ptb_vec_t*** %ptb_vec, align 8
  %arrayidx17 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %7, i64 %idxprom16.pre-phi
  %8 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx17, align 8
  %ptb_step = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 9
  %9 = load i32*, i32** %ptb_step, align 8
  %arrayidx19 = getelementptr inbounds i32, i32* %9, i64 %idxprom16.pre-phi
  %10 = load i32, i32* %arrayidx19, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %arrayidx19, align 4
  %idxprom20 = sext i32 %10 to i64
  %ptb.sroa.0.0..sroa_idx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %8, i64 %idxprom20, i32 0
  %ptb.sroa.0.0.copyload = load i64, i64* %ptb.sroa.0.0..sroa_idx, align 8
  %ptb.sroa.23.0..sroa_idx4 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %8, i64 %idxprom20, i32 2
  %ptb.sroa.23.0.copyload = load i32, i32* %ptb.sroa.23.0..sroa_idx4, align 4
  %11 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  call fastcc void @LSH_hash2_perturb(%struct.LSH_t* %11, i32** %3, i32* nonnull %h, i64 %ptb.sroa.0.0.copyload, i32 %ptb.sroa.23.0.copyload, i32 %l)
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 9
  %12 = load i32, i32* %h, align 4
  %idxprom26 = zext i32 %12 to i64
  %bitmap = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 5
  %ds = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 1
  %arrayidx44 = getelementptr inbounds i32, i32* %5, i64 %idxprom16.pre-phi
  %CC = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 17
  %arrayidx84 = getelementptr inbounds i32, i32* %6, i64 %idxprom16.pre-phi
  %13 = zext i32 %2 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc87, %do.body
  %__array_foreach_index.0 = phi i32 [ 0, %do.body ], [ %inc88, %for.inc87 ]
  %14 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %14, i64 %idxprom16.pre-phi, i32 1
  %15 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %len = getelementptr inbounds %struct.anon.5, %struct.anon.5* %15, i64 %idxprom26, i32 2
  %16 = load i32, i32* %len, align 8
  %cmp28 = icmp ult i32 %__array_foreach_index.0, %16
  br i1 %cmp28, label %for.body, label %do.end90

for.body:                                         ; preds = %for.cond
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %15, i64 %idxprom26, i32 3
  %17 = load i32*, i32** %data, align 8
  %idxprom36 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx37 = getelementptr inbounds i32, i32* %17, i64 %idxprom36
  %18 = load i32, i32* %arrayidx37, align 4
  %19 = load %struct.bitmap_t*, %struct.bitmap_t** %bitmap, align 8
  %call = call fastcc i32 @bitmap_contain(%struct.bitmap_t* %19, i32 %18)
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %do.body49, label %for.inc87

do.body49:                                        ; preds = %for.body
  call fastcc void @bitmap_insert(%struct.bitmap_t* %19, i32 %18)
  %20 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds, align 8
  %vec41 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %20, i64 0, i32 6
  %21 = load i8*, i8** %vec41, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %20, i64 0, i32 2
  %22 = load i32, i32* %vec_size, align 8
  %mul = mul i32 %18, %22
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds i8, i8* %21, i64 %idx.ext
  %23 = load i32, i32* %arrayidx44, align 4
  %inc45 = add nsw i32 %23, 1
  store i32 %inc45, i32* %arrayidx44, align 4
  %24 = load i32, i32* %CC, align 8
  %inc46 = add nsw i32 %24, 1
  store i32 %inc46, i32* %CC, align 8
  %u = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %arraydecay = bitcast i8* %u to float*
  %call48 = call fastcc float @dist_L2_float.542(i32 %1, float* %arraydecay, float* %point)
  br label %while.cond

while.cond:                                       ; preds = %if.end65, %do.body49
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end65 ], [ 0, %do.body49 ]
  %cmp52 = icmp ult i64 %indvars.iv, %13
  %25 = trunc i64 %indvars.iv to i32
  br i1 %cmp52, label %while.body, label %if.end69

while.body:                                       ; preds = %while.cond
  %dist56 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %indvars.iv, i32 1
  %26 = load float, float* %dist56, align 4
  %cmp57 = fcmp ogt float %call48, %26
  br i1 %cmp57, label %if.end69, label %if.end

if.end:                                           ; preds = %while.body
  %id62 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %indvars.iv, i32 0
  %27 = load i32, i32* %id62, align 4
  %cmp63 = icmp eq i32 %18, %27
  br i1 %cmp63, label %for.inc87, label %if.end65

if.end65:                                         ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %while.cond

if.end69:                                         ; preds = %while.cond, %while.body
  %cmp70 = icmp eq i32 %25, 0
  br i1 %cmp70, label %for.inc87, label %for.cond73.preheader

for.cond73.preheader:                             ; preds = %if.end69
  %sub = shl i64 %indvars.iv, 32
  %sext = add i64 %sub, -4294967296
  %28 = ashr exact i64 %sext, 32
  br label %for.cond73

for.cond73:                                       ; preds = %for.cond73.preheader, %for.inc
  %indvars.iv11 = phi i64 [ 0, %for.cond73.preheader ], [ %indvars.iv.next12, %for.inc ]
  %cmp74 = icmp slt i64 %indvars.iv11, %28
  br i1 %cmp74, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond73
  %arrayidx77 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %indvars.iv11
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  %arrayidx79 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %indvars.iv.next12
  %29 = bitcast %struct.cass_list_entry_t* %arrayidx79 to i64*
  %30 = bitcast %struct.cass_list_entry_t* %arrayidx77 to i64*
  %31 = load i64, i64* %29, align 4
  store i64 %31, i64* %30, align 4
  br label %for.cond73

for.end:                                          ; preds = %for.cond73
  %sext13 = shl i64 %indvars.iv11, 32
  %idxprom81 = ashr exact i64 %sext13, 32
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %idxprom81, i32 0
  store i32 %18, i32* %.sroa_idx, align 4
  %.sroa_idx7 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %cond, i64 %idxprom81, i32 1
  store float %call48, float* %.sroa_idx7, align 4
  %32 = load i32, i32* %arrayidx84, align 4
  %inc85 = add nsw i32 %32, 1
  store i32 %inc85, i32* %arrayidx84, align 4
  br label %for.inc87

for.inc87:                                        ; preds = %if.end, %for.body, %if.end69, %for.end
  %inc88 = add i32 %__array_foreach_index.0, 1
  br label %for.cond

do.end90:                                         ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @dist_L2_float.542(i32 %D, float* nocapture readonly %P1, float* nocapture readonly %P2) unnamed_addr #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %result.0 = phi float [ %add, %for.inc ], [ 0.000000e+00, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %P1, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds float, float* %P2, i64 %indvars.iv
  %1 = load float, float* %arrayidx3, align 4
  %sub = fsub float %0, %1
  %mul = fmul float %sub, %sub
  %add = fadd float %result.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @516, i32 0, i32 0))
  %sqrtf = call float @sqrtf(float %result.0) #1
  ret float %sqrtf
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_local(%struct.LSH_query_t* nocapture %query) unnamed_addr #0 {
entry:
  %a = alloca double, align 8
  %b = alloca double, align 8
  %K1 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %0 = load i32, i32* %K1, align 8
  %topk = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %sub = add nsw i32 %0, -1
  %1 = sext i32 %sub to i64
  %2 = sext i32 %0 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %sy.0 = phi double [ %add16, %for.inc ], [ 0.000000e+00, %entry ]
  %sx.0 = phi double [ %add15, %for.inc ], [ 0.000000e+00, %entry ]
  %3 = phi <2 x double> [ %17, %for.inc ], [ zeroinitializer, %entry ]
  %cmp = icmp slt i64 %indvars.iv, %1
  %4 = trunc i64 %indvars.iv to i32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, align 8
  %6 = sub nsw i64 %2, %indvars.iv
  %7 = add nsw i64 %6, -2
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %5, i64 %7, i32 1
  %8 = load float, float* %dist, align 4
  %cmp4 = fcmp ult float %8, 0x7FF0000000000000
  br i1 %cmp4, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %9 = trunc i64 %indvars.iv.next to i32
  %conv6 = sitofp i32 %9 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @517, i32 0, i32 0))
  %call = call double @log(double %conv6) #11
  %10 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, align 8
  %dist12 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %10, i64 %7, i32 1
  %11 = load float, float* %dist12, align 4
  %conv13 = fpext float %11 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @518, i32 0, i32 0))
  %call14 = call double @log(double %conv13) #11
  %12 = insertelement <2 x double> undef, double %call, i32 0
  %13 = shufflevector <2 x double> %12, <2 x double> undef, <2 x i32> zeroinitializer
  %14 = insertelement <2 x double> undef, double %call14, i32 0
  %15 = insertelement <2 x double> %14, double %call, i32 1
  %16 = fmul <2 x double> %13, %15
  %17 = fadd <2 x double> %3, %16
  %add16 = fadd double %sy.0, %call14
  %add15 = fadd double %sx.0, %call
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %18 = extractelement <2 x double> %3, i32 0
  %19 = extractelement <2 x double> %3, i32 1
  call fastcc void @least_squares(double* nonnull %a, double* nonnull %b, i32 %4, double %19, double %18, double %sx.0, double %sy.0)
  %20 = load double, double* %a, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @519, i32 0, i32 0))
  %call20 = call double @exp(double %20) #11
  %lsh = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %21 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  %est = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %21, i64 0, i32 12
  %22 = load %struct.LSH_est_t*, %struct.LSH_est_t** %est, align 8
  %23 = load double, double* %b, align 8
  %call22 = call fastcc double @LSH_est(%struct.LSH_est_t* %22, double %call20, double %23, i32 %sub)
  %gamma = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 20
  %24 = load float, float* %gamma, align 4
  %conv23 = fpext float %24 to double
  %mul24 = fmul double %call22, %conv23
  %conv25 = fptrunc double %mul24 to float
  %dist26 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 18
  store float %conv25, float* %dist26, align 4
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @least_squares(double* nocapture %a, double* nocapture %b, i32 %n, double %sxx, double %sxy, double %sx, double %sy) unnamed_addr #8 {
entry:
  %conv = sitofp i32 %n to double
  %mul = fmul double %conv, %sxy
  %mul1 = fmul double %sx, %sy
  %sub = fsub double %mul, %mul1
  %mul3 = fmul double %conv, %sxx
  %mul4 = fmul double %sx, %sx
  %sub5 = fsub double %mul3, %mul4
  %div = fdiv double %sub, %sub5
  store double %div, double* %b, align 8
  %mul6 = fmul double %div, %sx
  %sub7 = fsub double %sy, %mul6
  %div9 = fdiv double %sub7, %conv
  store double %div9, double* %a, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_recall(%struct.LSH_query_t* %query, float* nocapture readonly %point, float %R) unnamed_addr #0 {
entry:
  %lsh = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh, align 8
  %recall1 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 13
  %topk2 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 12
  %1 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk2, align 8
  %T3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  %2 = load i32, i32* %T3, align 8
  %L4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %3 = load i32, i32* %L4, align 4
  %K5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %4 = load i32, i32* %K5, align 8
  %CC = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 17
  store i32 0, i32* %CC, align 8
  call fastcc void @LSH_query_bootstrap(%struct.LSH_query_t* %query, float* %point)
  call fastcc void @LSH_query_merge(%struct.LSH_query_t* %query)
  %conv = sitofp i32 %4 to float
  %5 = sext i32 %4 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc21, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc22, %for.inc21 ]
  %cmp = icmp ult i32 %i.0, %2
  br i1 %cmp, label %for.cond7, label %for.end23

for.cond7:                                        ; preds = %for.cond, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.cond ]
  %r.0 = phi float [ %add, %for.inc ], [ 0.000000e+00, %for.cond ]
  %cmp8 = icmp slt i64 %indvars.iv, %5
  br i1 %cmp8, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond7
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %1, i64 %indvars.iv, i32 1
  %6 = load float, float* %dist, align 4
  %call = call fastcc float @LSH_recall(%struct.LSH_recall_t* %recall1, float %6, i32 %i.0)
  %add = fadd float %r.0, %call
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond7

for.end:                                          ; preds = %for.cond7
  %div = fdiv float %r.0, %conv
  %cmp10 = fcmp ult float %div, %R
  br i1 %cmp10, label %for.cond14, label %for.end23

for.cond14:                                       ; preds = %for.end, %for.inc18
  %j.1 = phi i32 [ %inc19, %for.inc18 ], [ 0, %for.end ]
  %exitcond = icmp eq i32 %j.1, %3
  br i1 %exitcond, label %for.inc21, label %for.inc18

for.inc18:                                        ; preds = %for.cond14
  call fastcc void @LSH_query_probe(%struct.LSH_query_t* %query, float* %point, i32 %j.1, i32 1)
  %inc19 = add nuw nsw i32 %j.1, 1
  br label %for.cond14

for.inc21:                                        ; preds = %for.cond14
  %inc22 = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.end23:                                        ; preds = %for.end, %for.cond
  ret void
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc float @LSH_recall(%struct.LSH_recall_t* nocapture readonly %recall, float %dist, i32 %T) unnamed_addr #6 {
entry:
  %d_min = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 2
  %0 = load float, float* %d_min, align 8
  %cmp = fcmp ogt float %0, %dist
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %d_max = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 3
  %1 = load float, float* %d_max, align 4
  %cmp1 = fcmp olt float %1, %dist
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %sub = fsub float %dist, %0
  %d_step = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 0
  %2 = load i32, i32* %d_step, align 8
  %conv = uitofp i32 %2 to float
  %mul = fmul float %sub, %conv
  %sub7 = fsub float %1, %0
  %div = fdiv float %mul, %sub7
  %conv8 = fptosi float %div to i32
  %table = getelementptr inbounds %struct.LSH_recall_t, %struct.LSH_recall_t* %recall, i64 0, i32 4
  %3 = load float**, float*** %table, align 8
  %idxprom = sext i32 %T to i64
  %arrayidx = getelementptr inbounds float*, float** %3, i64 %idxprom
  %4 = load float*, float** %arrayidx, align 8
  %idxprom9 = sext i32 %conv8 to i64
  %arrayidx10 = getelementptr inbounds float, float* %4, i64 %idxprom9
  %5 = load float, float* %arrayidx10, align 4
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi float [ %5, %if.end3 ], [ 1.000000e+00, %entry ], [ 0.000000e+00, %if.end ]
  ret float %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_batch(%struct.LSH_query_t* nocapture readonly %query, i32 %N, float** nocapture readonly %point, %struct.cass_list_entry_t** nocapture readonly %topk) unnamed_addr #0 {
entry:
  %h = alloca i32, align 4
  %lsh1 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %D2 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 0
  %1 = load i32, i32* %D2, align 8
  %T3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  %2 = load i32, i32* %T3, align 8
  %L4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %3 = load i32, i32* %L4, align 4
  %K5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %4 = load i32, i32* %K5, align 8
  %M6 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 1
  %5 = load i32, i32* %M6, align 4
  %call = call fastcc i8*** @__matrix3_alloc(i32 1, i32 %3, i32 %5, i32 4)
  %6 = bitcast i8*** %call to i32***
  %call7 = call fastcc i8** @__matrix_alloc(i32 1, i32 %3, i32 4)
  %7 = bitcast i8** %call7 to i32**
  %cmp = icmp sgt i32 %2, 0
  %mul = shl nsw i32 %5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call8 = call fastcc i8*** @__matrix3_alloc(i32 1, i32 %3, i32 %mul, i32 24)
  %8 = bitcast i8*** %call8 to %struct.ptb_vec_t***
  %call9 = call fastcc i8** @__matrix_alloc(i32 1, i32 %2, i32 24)
  %9 = bitcast i8** %call9 to %struct.ptb_vec_t**
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %10 = phi i8*** [ %call8, %if.then ], [ null, %entry ]
  %_score.0 = phi %struct.ptb_vec_t*** [ %8, %if.then ], [ null, %entry ]
  %11 = phi i8** [ %call9, %if.then ], [ null, %entry ]
  %_vec.0 = phi %struct.ptb_vec_t** [ %9, %if.then ], [ null, %entry ]
  %hash = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 9
  %ds = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 1
  %cmp139 = icmp eq i32 %2, 0
  %ptb_set = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 10
  %12 = sext i32 %4 to i64
  %13 = sext i32 %4 to i64
  %14 = sext i32 %4 to i64
  %15 = sext i32 %2 to i64
  %16 = sext i32 %3 to i64
  %17 = sext i32 %N to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc259, %if.end
  %indvars.iv39 = phi i64 [ %indvars.iv.next40, %for.inc259 ], [ 0, %if.end ]
  %cmp10 = icmp slt i64 %indvars.iv39, %17
  br i1 %cmp10, label %if.end13, label %for.end261

if.end13:                                         ; preds = %for.cond
  %18 = load i32**, i32*** %6, align 8
  %19 = load i32*, i32** %7, align 8
  br i1 %cmp, label %cond.true23, label %cond.end27

cond.true23:                                      ; preds = %if.end13
  %20 = load %struct.ptb_vec_t**, %struct.ptb_vec_t*** %_score.0, align 8
  %21 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %_vec.0, align 8
  br label %cond.end27

cond.end27:                                       ; preds = %if.end13, %cond.true23
  %cond3 = phi %struct.ptb_vec_t** [ %20, %cond.true23 ], [ null, %if.end13 ]
  %cond28 = phi %struct.ptb_vec_t* [ %21, %cond.true23 ], [ null, %if.end13 ]
  %22 = load i32, i32* %T3, align 8
  %cmp34 = icmp eq i32 %22, 0
  %arrayidx37 = getelementptr inbounds float*, float** %point, i64 %indvars.iv39
  %23 = load float*, float** %arrayidx37, align 8
  br i1 %cmp34, label %if.then35, label %if.else38

if.then35:                                        ; preds = %cond.end27
  call fastcc void @LSH_hash_L(%struct.LSH_t* %0, float* %23, i32** %18, i32 %3)
  br label %do.body

if.else38:                                        ; preds = %cond.end27
  call fastcc void @LSH_hash_score(%struct.LSH_t* %0, i32 %3, float* %23, i32** %18, %struct.ptb_vec_t** %cond3)
  br label %do.body

do.body:                                          ; preds = %if.then35, %if.else38
  call fastcc void @LSH_hash2_noperturb(%struct.LSH_t* %0, i32** %18, i32* %19, i32 %3)
  %arrayidx47 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, i64 %indvars.iv39
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc, %do.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %do.body ]
  %cmp44 = icmp slt i64 %indvars.iv, %12
  br i1 %cmp44, label %for.inc, label %for.cond50.preheader

for.cond50.preheader:                             ; preds = %for.cond43
  %arrayidx84 = getelementptr inbounds float*, float** %point, i64 %indvars.iv39
  br label %for.cond50

for.inc:                                          ; preds = %for.cond43
  %24 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx47, align 8
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %24, i64 %indvars.iv, i32 1
  store float 0x7FF0000000000000, float* %dist, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond43

for.cond50:                                       ; preds = %for.cond50.preheader, %for.inc256
  %indvars.iv37 = phi i64 [ 0, %for.cond50.preheader ], [ %indvars.iv.next38, %for.inc256 ]
  %cmp51 = icmp slt i64 %indvars.iv37, %16
  br i1 %cmp51, label %for.cond57.preheader, label %for.inc259

for.cond57.preheader:                             ; preds = %for.cond50
  %arrayidx61 = getelementptr inbounds i32, i32* %19, i64 %indvars.iv37
  br label %for.cond57

for.cond57:                                       ; preds = %for.cond57.preheader, %for.inc135
  %__array_foreach_index.0 = phi i32 [ %inc136, %for.inc135 ], [ 0, %for.cond57.preheader ]
  %25 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %bucket = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %25, i64 %indvars.iv37, i32 1
  %26 = load %struct.anon.5*, %struct.anon.5** %bucket, align 8
  %27 = load i32, i32* %arrayidx61, align 4
  %idxprom62 = zext i32 %27 to i64
  %len = getelementptr inbounds %struct.anon.5, %struct.anon.5* %26, i64 %idxprom62, i32 2
  %28 = load i32, i32* %len, align 8
  %cmp64 = icmp ult i32 %__array_foreach_index.0, %28
  br i1 %cmp64, label %do.body87, label %do.end138

do.body87:                                        ; preds = %for.cond57
  %data = getelementptr inbounds %struct.anon.5, %struct.anon.5* %26, i64 %idxprom62, i32 3
  %29 = load i32*, i32** %data, align 8
  %idxprom75 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx76 = getelementptr inbounds i32, i32* %29, i64 %idxprom75
  %30 = load i32, i32* %arrayidx76, align 4
  %31 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds, align 8
  %vec79 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %31, i64 0, i32 6
  %32 = load i8*, i8** %vec79, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %31, i64 0, i32 2
  %33 = load i32, i32* %vec_size, align 8
  %mul81 = mul i32 %30, %33
  %idx.ext = zext i32 %mul81 to i64
  %add.ptr = getelementptr inbounds i8, i8* %32, i64 %idx.ext
  %u = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %arraydecay = bitcast i8* %u to float*
  %34 = load float*, float** %arrayidx84, align 8
  %call85 = call fastcc float @dist_L2_float.549(i32 %1, float* %arraydecay, float* %34)
  br label %while.cond

while.cond:                                       ; preds = %if.end109, %do.body87
  %indvars.iv27 = phi i64 [ %indvars.iv.next28, %if.end109 ], [ 0, %do.body87 ]
  %cmp91 = icmp slt i64 %indvars.iv27, %13
  %35 = trunc i64 %indvars.iv27 to i32
  br i1 %cmp91, label %while.body, label %if.end112

while.body:                                       ; preds = %while.cond
  %36 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx47, align 8
  %dist97 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %36, i64 %indvars.iv27, i32 1
  %37 = load float, float* %dist97, align 4
  %cmp98 = fcmp ogt float %call85, %37
  br i1 %cmp98, label %if.end112, label %if.end100

if.end100:                                        ; preds = %while.body
  %id106 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %36, i64 %indvars.iv27, i32 0
  %38 = load i32, i32* %id106, align 4
  %cmp107 = icmp eq i32 %30, %38
  br i1 %cmp107, label %for.inc135, label %if.end109

if.end109:                                        ; preds = %if.end100
  %indvars.iv.next28 = add nuw nsw i64 %indvars.iv27, 1
  br label %while.cond

if.end112:                                        ; preds = %while.cond, %while.body
  %cmp113 = icmp eq i32 %35, 0
  br i1 %cmp113, label %for.inc135, label %for.cond116.preheader

for.cond116.preheader:                            ; preds = %if.end112
  %sub = shl i64 %indvars.iv27, 32
  %sext42 = add i64 %sub, -4294967296
  %39 = ashr exact i64 %sext42, 32
  br label %for.cond116

for.cond116:                                      ; preds = %for.cond116.preheader, %for.inc127
  %indvars.iv29 = phi i64 [ 0, %for.cond116.preheader ], [ %indvars.iv.next30, %for.inc127 ]
  %cmp117 = icmp slt i64 %indvars.iv29, %39
  %40 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx47, align 8
  br i1 %cmp117, label %for.inc127, label %for.end129

for.inc127:                                       ; preds = %for.cond116
  %arrayidx122 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %40, i64 %indvars.iv29
  %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1
  %arrayidx126 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %40, i64 %indvars.iv.next30
  %41 = bitcast %struct.cass_list_entry_t* %arrayidx126 to i64*
  %42 = bitcast %struct.cass_list_entry_t* %arrayidx122 to i64*
  %43 = load i64, i64* %41, align 4
  store i64 %43, i64* %42, align 4
  br label %for.cond116

for.end129:                                       ; preds = %for.cond116
  %sext43 = shl i64 %indvars.iv29, 32
  %idxprom132 = ashr exact i64 %sext43, 32
  %.sroa_idx15 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %40, i64 %idxprom132, i32 0
  store i32 %30, i32* %.sroa_idx15, align 4
  %.sroa_idx16 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %40, i64 %idxprom132, i32 1
  store float %call85, float* %.sroa_idx16, align 4
  br label %for.inc135

for.inc135:                                       ; preds = %if.end100, %for.end129, %if.end112
  %inc136 = add i32 %__array_foreach_index.0, 1
  br label %for.cond57

do.end138:                                        ; preds = %for.cond57
  br i1 %cmp139, label %for.inc256, label %if.end141

if.end141:                                        ; preds = %do.end138
  %arrayidx143 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %cond3, i64 %indvars.iv37
  %44 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx143, align 8
  call fastcc void @ptb_qsort(%struct.ptb_vec_t* %44, i32 %mul)
  %45 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %ptb_set, align 8
  %46 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx143, align 8
  call fastcc void @map_perturb_vector(%struct.ptb_vec_t* %45, %struct.ptb_vec_t* %cond28, %struct.ptb_vec_t* %46, i32 %5, i32 %2)
  br label %for.cond148

for.cond148:                                      ; preds = %for.inc253, %if.end141
  %indvars.iv35 = phi i64 [ %indvars.iv.next36, %for.inc253 ], [ 0, %if.end141 ]
  %cmp149 = icmp slt i64 %indvars.iv35, %15
  br i1 %cmp149, label %do.body153, label %for.inc256

do.body153:                                       ; preds = %for.cond148
  %ptb.sroa.0.0..sroa_idx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %cond28, i64 %indvars.iv35, i32 0
  %ptb.sroa.0.0.copyload = load i64, i64* %ptb.sroa.0.0..sroa_idx, align 8
  %ptb.sroa.26.0..sroa_idx7 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %cond28, i64 %indvars.iv35, i32 2
  %ptb.sroa.26.0.copyload = load i32, i32* %ptb.sroa.26.0..sroa_idx7, align 4
  %47 = trunc i64 %indvars.iv37 to i32
  call fastcc void @LSH_hash2_perturb(%struct.LSH_t* %0, i32** %18, i32* nonnull %h, i64 %ptb.sroa.0.0.copyload, i32 %ptb.sroa.26.0.copyload, i32 %47)
  %48 = load i32, i32* %h, align 4
  %idxprom161 = zext i32 %48 to i64
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc249, %do.body153
  %__array_foreach_index155.0 = phi i32 [ 0, %do.body153 ], [ %inc250, %for.inc249 ]
  %49 = load %struct.ohash_t*, %struct.ohash_t** %hash, align 8
  %bucket160 = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %49, i64 %indvars.iv37, i32 1
  %50 = load %struct.anon.5*, %struct.anon.5** %bucket160, align 8
  %len163 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %50, i64 %idxprom161, i32 2
  %51 = load i32, i32* %len163, align 8
  %cmp164 = icmp ult i32 %__array_foreach_index155.0, %51
  br i1 %cmp164, label %do.body194, label %for.inc253

do.body194:                                       ; preds = %for.cond156
  %data174 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %50, i64 %idxprom161, i32 3
  %52 = load i32*, i32** %data174, align 8
  %idxprom175 = zext i32 %__array_foreach_index155.0 to i64
  %arrayidx176 = getelementptr inbounds i32, i32* %52, i64 %idxprom175
  %53 = load i32, i32* %arrayidx176, align 4
  %54 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds, align 8
  %vec180 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %54, i64 0, i32 6
  %55 = load i8*, i8** %vec180, align 8
  %vec_size182 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %54, i64 0, i32 2
  %56 = load i32, i32* %vec_size182, align 8
  %mul183 = mul i32 %53, %56
  %idx.ext184 = zext i32 %mul183 to i64
  %add.ptr185 = getelementptr inbounds i8, i8* %55, i64 %idx.ext184
  %u187 = getelementptr inbounds i8, i8* %add.ptr185, i64 8
  %arraydecay189 = bitcast i8* %u187 to float*
  %57 = load float*, float** %arrayidx84, align 8
  %call192 = call fastcc float @dist_L2_float.549(i32 %1, float* %arraydecay189, float* %57)
  br label %while.cond199

while.cond199:                                    ; preds = %if.end219, %do.body194
  %indvars.iv31 = phi i64 [ %indvars.iv.next32, %if.end219 ], [ 0, %do.body194 ]
  %cmp200 = icmp slt i64 %indvars.iv31, %14
  %58 = trunc i64 %indvars.iv31 to i32
  br i1 %cmp200, label %while.body201, label %if.end224

while.body201:                                    ; preds = %while.cond199
  %59 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx47, align 8
  %dist207 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %59, i64 %indvars.iv31, i32 1
  %60 = load float, float* %dist207, align 4
  %cmp208 = fcmp ogt float %call192, %60
  br i1 %cmp208, label %if.end224, label %if.end210

if.end210:                                        ; preds = %while.body201
  %id216 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %59, i64 %indvars.iv31, i32 0
  %61 = load i32, i32* %id216, align 4
  %cmp217 = icmp eq i32 %53, %61
  br i1 %cmp217, label %for.inc249, label %if.end219

if.end219:                                        ; preds = %if.end210
  %indvars.iv.next32 = add nuw nsw i64 %indvars.iv31, 1
  br label %while.cond199

if.end224:                                        ; preds = %while.cond199, %while.body201
  %cmp225 = icmp eq i32 %58, 0
  br i1 %cmp225, label %for.inc249, label %for.cond228.preheader

for.cond228.preheader:                            ; preds = %if.end224
  %sub229 = shl i64 %indvars.iv31, 32
  %sext = add i64 %sub229, -4294967296
  %62 = ashr exact i64 %sext, 32
  br label %for.cond228

for.cond228:                                      ; preds = %for.cond228.preheader, %for.inc241
  %indvars.iv33 = phi i64 [ 0, %for.cond228.preheader ], [ %indvars.iv.next34, %for.inc241 ]
  %cmp230 = icmp slt i64 %indvars.iv33, %62
  %63 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx47, align 8
  br i1 %cmp230, label %for.inc241, label %for.end243

for.inc241:                                       ; preds = %for.cond228
  %arrayidx235 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %63, i64 %indvars.iv33
  %indvars.iv.next34 = add nuw nsw i64 %indvars.iv33, 1
  %arrayidx240 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %63, i64 %indvars.iv.next34
  %64 = bitcast %struct.cass_list_entry_t* %arrayidx240 to i64*
  %65 = bitcast %struct.cass_list_entry_t* %arrayidx235 to i64*
  %66 = load i64, i64* %64, align 4
  store i64 %66, i64* %65, align 4
  br label %for.cond228

for.end243:                                       ; preds = %for.cond228
  %sext41 = shl i64 %indvars.iv33, 32
  %idxprom246 = ashr exact i64 %sext41, 32
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %63, i64 %idxprom246, i32 0
  store i32 %53, i32* %.sroa_idx, align 4
  %.sroa_idx10 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %63, i64 %idxprom246, i32 1
  store float %call192, float* %.sroa_idx10, align 4
  br label %for.inc249

for.inc249:                                       ; preds = %if.end210, %for.end243, %if.end224
  %inc250 = add i32 %__array_foreach_index155.0, 1
  br label %for.cond156

for.inc253:                                       ; preds = %for.cond156
  %indvars.iv.next36 = add nuw nsw i64 %indvars.iv35, 1
  br label %for.cond148

for.inc256:                                       ; preds = %for.cond148, %do.end138
  %indvars.iv.next38 = add nuw nsw i64 %indvars.iv37, 1
  br label %for.cond50

for.inc259:                                       ; preds = %for.cond50
  %indvars.iv.next40 = add nuw nsw i64 %indvars.iv39, 1
  br label %for.cond

for.end261:                                       ; preds = %for.cond
  %cmp262 = icmp eq %struct.ptb_vec_t** %_vec.0, null
  br i1 %cmp262, label %if.end264, label %if.then263

if.then263:                                       ; preds = %for.end261
  call fastcc void @__matrix_free(i8** %11)
  br label %if.end264

if.end264:                                        ; preds = %for.end261, %if.then263
  %cmp265 = icmp eq %struct.ptb_vec_t*** %_score.0, null
  br i1 %cmp265, label %if.end267, label %if.then266

if.then266:                                       ; preds = %if.end264
  call fastcc void @__matrix3_free(i8*** %10)
  br label %if.end267

if.end267:                                        ; preds = %if.end264, %if.then266
  call fastcc void @__matrix3_free(i8*** %call)
  call fastcc void @__matrix_free(i8** %call7)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_hash_L(%struct.LSH_t* nocapture readonly %lsh, float* nocapture readonly %pnt, i32** nocapture readonly %hash, i32 %L) unnamed_addr #0 {
entry:
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %betas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 7
  %D = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 0
  %alphas = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 6
  %W = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 5
  %0 = sext i32 %L to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc24, %entry
  %indvars.iv5 = phi i64 [ %indvars.iv.next6, %for.inc24 ], [ 0, %entry ]
  %l.0 = phi i64 [ %indvars.iv3, %for.inc24 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv5, %0
  br i1 %cmp, label %for.cond1.preheader, label %for.end26

for.cond1.preheader:                              ; preds = %for.cond
  %arrayidx17 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv5
  %sext = shl i64 %l.0, 32
  %1 = ashr exact i64 %sext, 32
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc21
  %indvars.iv3 = phi i64 [ %1, %for.cond1.preheader ], [ %indvars.iv.next4, %for.inc21 ]
  %indvars.iv1 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next2, %for.inc21 ]
  %2 = load i32, i32* %M, align 4
  %3 = zext i32 %2 to i64
  %cmp2 = icmp ult i64 %indvars.iv1, %3
  br i1 %cmp2, label %for.body3, label %for.inc24

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %betas, align 8
  %arrayidx = getelementptr inbounds float, float* %4, i64 %indvars.iv3
  %5 = load float, float* %arrayidx, align 4
  %6 = load i32, i32* %D, align 8
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body3
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body3 ]
  %s.0 = phi float [ %add, %for.inc ], [ %5, %for.body3 ]
  %wide.trip.count = zext i32 %6 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc21, label %for.inc

for.inc:                                          ; preds = %for.cond4
  %arrayidx8 = getelementptr inbounds float, float* %pnt, i64 %indvars.iv
  %7 = load float, float* %arrayidx8, align 4
  %8 = load float**, float*** %alphas, align 8
  %arrayidx10 = getelementptr inbounds float*, float** %8, i64 %indvars.iv3
  %9 = load float*, float** %arrayidx10, align 8
  %arrayidx12 = getelementptr inbounds float, float* %9, i64 %indvars.iv
  %10 = load float, float* %arrayidx12, align 4
  %mul = fmul float %7, %10
  %add = fadd float %s.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond4

for.inc21:                                        ; preds = %for.cond4
  %11 = load float*, float** %W, align 8
  %arrayidx14 = getelementptr inbounds float, float* %11, i64 %indvars.iv5
  %12 = load float, float* %arrayidx14, align 4
  %div = fdiv float %s.0, %12
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @520, i32 0, i32 0))
  %floorf = call float @floorf(float %div) #13
  %conv15 = fptoui float %floorf to i32
  %13 = load i32*, i32** %arrayidx17, align 8
  %arrayidx19 = getelementptr inbounds i32, i32* %13, i64 %indvars.iv1
  store i32 %conv15, i32* %arrayidx19, align 4
  %indvars.iv.next4 = add i64 %indvars.iv3, 1
  %indvars.iv.next2 = add nuw i64 %indvars.iv1, 1
  br label %for.cond1

for.inc24:                                        ; preds = %for.cond1
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  br label %for.cond

for.end26:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @dist_L2_float.549(i32 %D, float* nocapture readonly %P1, float* nocapture readonly %P2) unnamed_addr #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %result.0 = phi float [ %add, %for.inc ], [ 0.000000e+00, %entry ]
  %wide.trip.count = zext i32 %D to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds float, float* %P1, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds float, float* %P2, i64 %indvars.iv
  %1 = load float, float* %arrayidx3, align 4
  %sub = fsub float %0, %1
  %mul = fmul float %sub, %sub
  %add = fadd float %result.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @521, i32 0, i32 0))
  %sqrtf = call float @sqrtf(float %result.0) #1
  ret float %sqrtf
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @LSH_query_batch_ca(%struct.LSH_query_t* nocapture readonly %query, i32 %N, float** nocapture readonly %point, %struct.cass_list_entry_t** nocapture readonly %topk) unnamed_addr #0 {
entry:
  %h = alloca i32, align 4
  %lsh1 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 0
  %0 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %D2 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 0
  %1 = load i32, i32* %D2, align 8
  %L3 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 3
  %2 = load i32, i32* %L3, align 4
  %K4 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 2
  %3 = load i32, i32* %K4, align 8
  %T5 = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 4
  %4 = load i32, i32* %T5, align 8
  %M6 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 1
  %5 = load i32, i32* %M6, align 4
  %add = add nsw i32 %4, 1
  %call = call fastcc i8*** @__matrix3_alloc(i32 %N, i32 %2, i32 %add, i32 24)
  %call7 = call fastcc i8*** @__matrix3_alloc(i32 1, i32 %2, i32 %5, i32 4)
  %6 = bitcast i8*** %call7 to i32***
  %cmp = icmp sgt i32 %4, 0
  %mul = shl nsw i32 %5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call8 = call fastcc i8*** @__matrix3_alloc(i32 1, i32 %2, i32 %mul, i32 24)
  %7 = bitcast i8*** %call8 to %struct.ptb_vec_t***
  %call9 = call fastcc i8** @__matrix_alloc(i32 1, i32 %4, i32 24)
  %8 = bitcast i8** %call9 to %struct.ptb_vec_t**
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %9 = phi i8** [ %call9, %if.then ], [ null, %entry ]
  %_vec.0 = phi %struct.ptb_vec_t** [ %8, %if.then ], [ null, %entry ]
  %10 = phi i8*** [ %call8, %if.then ], [ null, %entry ]
  %_score.0 = phi %struct.ptb_vec_t*** [ %7, %if.then ], [ null, %entry ]
  %cmp39 = icmp eq i32 %4, 0
  %ptb_set = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 10
  %11 = sext i32 %4 to i64
  %12 = sext i32 %2 to i64
  %13 = sext i32 %N to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc88, %if.end
  %indvars.iv95 = phi i64 [ %indvars.iv.next96, %for.inc88 ], [ 0, %if.end ]
  %cmp10 = icmp slt i64 %indvars.iv95, %13
  br i1 %cmp10, label %for.body, label %for.end90

for.body:                                         ; preds = %for.cond
  br i1 %cmp, label %if.end25.thread, label %if.end25

if.end25.thread:                                  ; preds = %for.body
  %14 = load %struct.ptb_vec_t**, %struct.ptb_vec_t*** %_score.0, align 8
  %15 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %_vec.0, align 8
  %16 = load i32**, i32*** %6, align 8
  br label %if.else32

if.end25:                                         ; preds = %for.body
  %17 = load i32**, i32*** %6, align 8
  br i1 %cmp39, label %if.then29, label %if.else32

if.then29:                                        ; preds = %if.end25
  %arrayidx31 = getelementptr inbounds float*, float** %point, i64 %indvars.iv95
  %18 = load float*, float** %arrayidx31, align 8
  call fastcc void @LSH_hash_L(%struct.LSH_t* %0, float* %18, i32** %17, i32 %2)
  br label %if.end35

if.else32:                                        ; preds = %if.end25.thread, %if.end25
  %19 = phi i32** [ %16, %if.end25.thread ], [ %17, %if.end25 ]
  %cond2222 = phi %struct.ptb_vec_t* [ %15, %if.end25.thread ], [ null, %if.end25 ]
  %cond1620 = phi %struct.ptb_vec_t** [ %14, %if.end25.thread ], [ null, %if.end25 ]
  %arrayidx34 = getelementptr inbounds float*, float** %point, i64 %indvars.iv95
  %20 = load float*, float** %arrayidx34, align 8
  call fastcc void @LSH_hash_score(%struct.LSH_t* %0, i32 %2, float* %20, i32** %19, %struct.ptb_vec_t** %cond1620)
  br label %if.end35

if.end35:                                         ; preds = %if.else32, %if.then29
  %21 = phi i32** [ %19, %if.else32 ], [ %17, %if.then29 ]
  %cond2221 = phi %struct.ptb_vec_t* [ %cond2222, %if.else32 ], [ null, %if.then29 ]
  %cond1619 = phi %struct.ptb_vec_t** [ %cond1620, %if.else32 ], [ null, %if.then29 ]
  %22 = load %struct.LSH_t*, %struct.LSH_t** %lsh1, align 8
  %arrayidx389 = getelementptr inbounds i8**, i8*** %call, i64 %indvars.iv95
  %arrayidx38 = bitcast i8*** %arrayidx389 to %struct.b2s***
  %23 = load %struct.b2s**, %struct.b2s*** %arrayidx38, align 8
  %24 = trunc i64 %indvars.iv95 to i32
  call fastcc void @LSH_hash2_b2s_L(%struct.LSH_t* %22, i32** %21, %struct.b2s** %23, i32 %2, i32 %24)
  br i1 %cmp39, label %for.inc88, label %for.cond42

for.cond42:                                       ; preds = %if.end35, %for.inc85
  %indvars.iv93 = phi i64 [ %indvars.iv.next94, %for.inc85 ], [ 0, %if.end35 ]
  %cmp43 = icmp slt i64 %indvars.iv93, %12
  br i1 %cmp43, label %for.body44, label %for.inc88

for.body44:                                       ; preds = %for.cond42
  %arrayidx46 = getelementptr inbounds %struct.ptb_vec_t*, %struct.ptb_vec_t** %cond1619, i64 %indvars.iv93
  %25 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx46, align 8
  call fastcc void @ptb_qsort(%struct.ptb_vec_t* %25, i32 %mul)
  %26 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %ptb_set, align 8
  %27 = load %struct.ptb_vec_t*, %struct.ptb_vec_t** %arrayidx46, align 8
  call fastcc void @map_perturb_vector(%struct.ptb_vec_t* %26, %struct.ptb_vec_t* %cond2221, %struct.ptb_vec_t* %27, i32 %5, i32 %4)
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc, %for.body44
  %indvars.iv91 = phi i64 [ %indvars.iv.next92, %for.inc ], [ 0, %for.body44 ]
  %cmp52 = icmp slt i64 %indvars.iv91, %11
  br i1 %cmp52, label %for.inc, label %for.inc85

for.inc:                                          ; preds = %for.cond51
  %arrayidx56.idx = getelementptr %struct.ptb_vec_t, %struct.ptb_vec_t* %cond2221, i64 %indvars.iv91, i32 0
  %arrayidx56.idx.val = load i64, i64* %arrayidx56.idx, align 8
  %arrayidx56.idx14 = getelementptr %struct.ptb_vec_t, %struct.ptb_vec_t* %cond2221, i64 %indvars.iv91, i32 2
  %arrayidx56.idx14.val = load i32, i32* %arrayidx56.idx14, align 4
  %28 = trunc i64 %indvars.iv93 to i32
  call fastcc void @LSH_hash2_perturb(%struct.LSH_t* %0, i32** %21, i32* nonnull %h, i64 %arrayidx56.idx.val, i32 %arrayidx56.idx14.val, i32 %28)
  %29 = load %struct.b2s**, %struct.b2s*** %arrayidx38, align 8
  %arrayidx60 = getelementptr inbounds %struct.b2s*, %struct.b2s** %29, i64 %indvars.iv93
  %30 = load %struct.b2s*, %struct.b2s** %arrayidx60, align 8
  %indvars.iv.next92 = add nuw nsw i64 %indvars.iv91, 1
  %qry = getelementptr inbounds %struct.b2s, %struct.b2s* %30, i64 %indvars.iv.next92, i32 1
  %31 = trunc i64 %indvars.iv95 to i32
  store i32 %31, i32* %qry, align 4
  %32 = load %struct.b2s*, %struct.b2s** %arrayidx60, align 8
  %t = getelementptr inbounds %struct.b2s, %struct.b2s* %32, i64 %indvars.iv.next92, i32 2
  %33 = trunc i64 %indvars.iv91 to i32
  store i32 %33, i32* %t, align 8
  %34 = load i32, i32* %h, align 4
  %35 = load %struct.b2s*, %struct.b2s** %arrayidx60, align 8
  %bucket = getelementptr inbounds %struct.b2s, %struct.b2s* %35, i64 %indvars.iv.next92, i32 0
  store i32 %34, i32* %bucket, align 8
  %36 = load %struct.b2s*, %struct.b2s** %arrayidx60, align 8
  %next = getelementptr inbounds %struct.b2s, %struct.b2s* %36, i64 %indvars.iv.next92, i32 3
  store %struct.b2s* null, %struct.b2s** %next, align 8
  br label %for.cond51

for.inc85:                                        ; preds = %for.cond51
  %indvars.iv.next94 = add nuw nsw i64 %indvars.iv93, 1
  br label %for.cond42

for.inc88:                                        ; preds = %for.cond42, %if.end35
  %indvars.iv.next96 = add nuw nsw i64 %indvars.iv95, 1
  br label %for.cond

for.end90:                                        ; preds = %for.cond
  call fastcc void @__matrix3_free(i8*** %call7)
  %cmp91 = icmp eq %struct.ptb_vec_t*** %_score.0, null
  br i1 %cmp91, label %if.end93, label %if.then92

if.then92:                                        ; preds = %for.end90
  call fastcc void @__matrix3_free(i8*** %10)
  br label %if.end93

if.end93:                                         ; preds = %for.end90, %if.then92
  %cmp94 = icmp eq %struct.ptb_vec_t** %_vec.0, null
  br i1 %cmp94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %if.end93
  call fastcc void @__matrix_free(i8** %9)
  br label %if.end96

if.end96:                                         ; preds = %if.end93, %if.then95
  %mul98 = mul nsw i32 %add, %N
  %mul99 = mul nsw i32 %mul98, 5
  %call100 = call fastcc i32 @prime(i32 %mul99)
  %conv = sext i32 %call100 to i64
  %call102 = call fastcc i8** @__matrix_alloc(i32 %2, i32 %call100, i32 8)
  %37 = sext i32 %4 to i64
  %38 = sext i32 %N to i64
  %39 = sext i32 %2 to i64
  br label %for.cond103

for.cond103:                                      ; preds = %for.inc170, %if.end96
  %indvars.iv89 = phi i64 [ %indvars.iv.next90, %for.inc170 ], [ 0, %if.end96 ]
  %cmp104 = icmp slt i64 %indvars.iv89, %39
  br i1 %cmp104, label %for.cond111.preheader, label %for.end172

for.cond111.preheader:                            ; preds = %for.cond103
  %arrayidx1416 = getelementptr inbounds i8*, i8** %call102, i64 %indvars.iv89
  %arrayidx141 = bitcast i8** %arrayidx1416 to %struct.b2s***
  br label %for.cond111

for.cond111:                                      ; preds = %for.cond111.preheader, %for.inc167
  %indvars.iv87 = phi i64 [ 0, %for.cond111.preheader ], [ %indvars.iv.next88, %for.inc167 ]
  %cmp112 = icmp slt i64 %indvars.iv87, %38
  br i1 %cmp112, label %for.cond115.preheader, label %for.inc170

for.cond115.preheader:                            ; preds = %for.cond111
  %arrayidx1214 = getelementptr inbounds i8**, i8*** %call, i64 %indvars.iv87
  %arrayidx121 = bitcast i8*** %arrayidx1214 to %struct.b2s***
  br label %for.cond115

for.cond115:                                      ; preds = %for.cond115.preheader, %for.inc164
  %indvars.iv85 = phi i64 [ 0, %for.cond115.preheader ], [ %indvars.iv.next86, %for.inc164 ]
  %cmp116 = icmp sgt i64 %indvars.iv85, %37
  br i1 %cmp116, label %for.inc167, label %for.body118

for.body118:                                      ; preds = %for.cond115
  %40 = load %struct.b2s**, %struct.b2s*** %arrayidx121, align 8
  %arrayidx123 = getelementptr inbounds %struct.b2s*, %struct.b2s** %40, i64 %indvars.iv89
  %41 = load %struct.b2s*, %struct.b2s** %arrayidx123, align 8
  %arrayidx125 = getelementptr inbounds %struct.b2s, %struct.b2s* %41, i64 %indvars.iv85
  %bucket128 = getelementptr inbounds %struct.b2s, %struct.b2s* %arrayidx125, i64 0, i32 0
  %42 = load i32, i32* %bucket128, align 8
  %conv129 = zext i32 %42 to i64
  %43 = load %struct.b2s**, %struct.b2s*** %arrayidx141, align 8
  br label %for.cond131

for.cond131:                                      ; preds = %if.end149, %for.body118
  %conv129.pn = phi i64 [ %conv129, %for.body118 ], [ %conv151, %if.end149 ]
  %k127.0.in = urem i64 %conv129.pn, %conv
  %arrayidx135 = getelementptr inbounds %struct.b2s*, %struct.b2s** %43, i64 %k127.0.in
  %44 = load %struct.b2s*, %struct.b2s** %arrayidx135, align 8
  %cmp136 = icmp eq %struct.b2s* %44, null
  %45 = ptrtoint %struct.b2s* %44 to i64
  br i1 %cmp136, label %for.inc164, label %if.end139

if.end139:                                        ; preds = %for.cond131
  %bucket144 = getelementptr inbounds %struct.b2s, %struct.b2s* %44, i64 0, i32 0
  %46 = load i32, i32* %bucket144, align 8
  %cmp146 = icmp eq i32 %46, %42
  br i1 %cmp146, label %for.inc164, label %if.end149

if.end149:                                        ; preds = %if.end139
  %add150 = add nuw nsw i64 %k127.0.in, 1
  %conv151 = and i64 %add150, 4294967295
  br label %for.cond131

for.inc164:                                       ; preds = %for.cond131, %if.end139
  %next159 = getelementptr inbounds %struct.b2s, %struct.b2s* %41, i64 %indvars.iv85, i32 3
  %47 = bitcast %struct.b2s** %next159 to i64*
  store i64 %45, i64* %47, align 8
  store %struct.b2s* %arrayidx125, %struct.b2s** %arrayidx135, align 8
  %indvars.iv.next86 = add nuw nsw i64 %indvars.iv85, 1
  br label %for.cond115

for.inc167:                                       ; preds = %for.cond115
  %indvars.iv.next88 = add nuw nsw i64 %indvars.iv87, 1
  br label %for.cond111

for.inc170:                                       ; preds = %for.cond111
  %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1
  br label %for.cond103

for.end172:                                       ; preds = %for.cond103
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @522, i32 0, i32 0))
  %call175 = call noalias i8* @malloc(i64 24) #11
  %48 = bitcast i8* %call175 to %struct.anon.212*
  br label %for.cond176

for.cond176:                                      ; preds = %for.inc189, %for.end172
  %indvars.iv82 = phi i64 [ %indvars.iv.next83, %for.inc189 ], [ 0, %for.end172 ]
  %exitcond84 = icmp eq i64 %indvars.iv82, 1
  br i1 %exitcond84, label %for.end191, label %for.inc189

for.inc189:                                       ; preds = %for.cond176
  %inc182 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv82, i32 0
  store i32 256, i32* %inc182, align 8
  %size = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv82, i32 1
  store i32 0, i32* %size, align 4
  %len = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv82, i32 2
  store i32 0, i32* %len, align 8
  %data = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv82, i32 3
  store %struct._cass_vecset_t* null, %struct._cass_vecset_t** %data, align 8
  %indvars.iv.next83 = add nuw nsw i64 %indvars.iv82, 1
  br label %for.cond176

for.end191:                                       ; preds = %for.cond176
  br i1 %cmp, label %if.then194, label %if.end196

if.then194:                                       ; preds = %for.end191
  %call195 = call fastcc i8*** @__matrix3_alloc(i32 %N, i32 %4, i32 %3, i32 8)
  %49 = bitcast i8*** %call195 to %struct.cass_list_entry_t***
  br label %if.end196

if.end196:                                        ; preds = %if.then194, %for.end191
  %50 = phi i8*** [ %call195, %if.then194 ], [ null, %for.end191 ]
  %ptopk.0 = phi %struct.cass_list_entry_t*** [ %49, %if.then194 ], [ null, %for.end191 ]
  %51 = sext i32 %3 to i64
  %52 = sext i32 %3 to i64
  %53 = sext i32 %4 to i64
  %54 = sext i32 %N to i64
  br label %for.cond197

for.cond197:                                      ; preds = %for.inc242, %if.end196
  %indvars.iv80 = phi i64 [ %indvars.iv.next81, %for.inc242 ], [ 0, %if.end196 ]
  %cmp198 = icmp slt i64 %indvars.iv80, %54
  br i1 %cmp198, label %for.cond205.preheader, label %for.cond245.preheader

for.cond205.preheader:                            ; preds = %for.cond197
  %arrayidx210 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, i64 %indvars.iv80
  br label %for.cond205

for.cond245.preheader:                            ; preds = %for.cond197
  %len277 = getelementptr inbounds i8, i8* %call175, i64 8
  %55 = bitcast i8* %len277 to i32*
  %size305 = getelementptr inbounds i8, i8* %call175, i64 4
  %56 = bitcast i8* %size305 to i32*
  %inc321 = bitcast i8* %call175 to i32*
  %data335 = getelementptr inbounds i8, i8* %call175, i64 16
  %57 = bitcast i8* %data335 to %struct._cass_vecset_t**
  %58 = bitcast i8* %data335 to i8**
  %hash381 = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %0, i64 0, i32 9
  %ds = getelementptr inbounds %struct.LSH_query_t, %struct.LSH_query_t* %query, i64 0, i32 1
  %59 = sext i32 %3 to i64
  %60 = sext i32 %3 to i64
  %61 = zext i32 %call100 to i64
  %62 = sext i32 %2 to i64
  br label %for.cond245

for.cond205:                                      ; preds = %for.cond205.preheader, %for.inc213
  %indvars.iv74 = phi i64 [ 0, %for.cond205.preheader ], [ %indvars.iv.next75, %for.inc213 ]
  %cmp206 = icmp slt i64 %indvars.iv74, %51
  br i1 %cmp206, label %for.inc213, label %for.cond217.preheader

for.cond217.preheader:                            ; preds = %for.cond205
  %arrayidx229 = getelementptr inbounds %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %ptopk.0, i64 %indvars.iv80
  br label %for.cond217

for.inc213:                                       ; preds = %for.cond205
  %63 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx210, align 8
  %dist = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %63, i64 %indvars.iv74, i32 1
  store float 0x7FF0000000000000, float* %dist, align 4
  %indvars.iv.next75 = add nuw nsw i64 %indvars.iv74, 1
  br label %for.cond205

for.cond217:                                      ; preds = %for.cond217.preheader, %for.inc239
  %indvars.iv78 = phi i64 [ 0, %for.cond217.preheader ], [ %indvars.iv.next79, %for.inc239 ]
  %cmp218 = icmp slt i64 %indvars.iv78, %53
  br i1 %cmp218, label %for.cond224, label %for.inc242

for.cond224:                                      ; preds = %for.cond217, %for.inc235
  %indvars.iv76 = phi i64 [ %indvars.iv.next77, %for.inc235 ], [ 0, %for.cond217 ]
  %cmp225 = icmp slt i64 %indvars.iv76, %52
  br i1 %cmp225, label %for.inc235, label %for.inc239

for.inc235:                                       ; preds = %for.cond224
  %64 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %arrayidx229, align 8
  %arrayidx231 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %64, i64 %indvars.iv78
  %65 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx231, align 8
  %dist234 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %65, i64 %indvars.iv76, i32 1
  store float 0x7FF0000000000000, float* %dist234, align 4
  %indvars.iv.next77 = add nuw nsw i64 %indvars.iv76, 1
  br label %for.cond224

for.inc239:                                       ; preds = %for.cond224
  %indvars.iv.next79 = add nuw nsw i64 %indvars.iv78, 1
  br label %for.cond217

for.inc242:                                       ; preds = %for.cond217
  %indvars.iv.next81 = add nuw nsw i64 %indvars.iv80, 1
  br label %for.cond197

for.cond245:                                      ; preds = %for.cond245.preheader, %for.inc590
  %indvars.iv72 = phi i64 [ 0, %for.cond245.preheader ], [ %indvars.iv.next73, %for.inc590 ]
  %cmp246 = icmp slt i64 %indvars.iv72, %62
  br i1 %cmp246, label %for.cond249.preheader, label %for.cond593

for.cond249.preheader:                            ; preds = %for.cond245
  %arrayidx2551 = getelementptr inbounds i8*, i8** %call102, i64 %indvars.iv72
  %arrayidx255 = bitcast i8** %arrayidx2551 to %struct.b2s***
  br label %for.cond249

for.cond249:                                      ; preds = %for.cond249.preheader, %for.inc587
  %indvars.iv70 = phi i64 [ 0, %for.cond249.preheader ], [ %indvars.iv.next71, %for.inc587 ]
  %cmp251 = icmp ult i64 %indvars.iv70, %61
  br i1 %cmp251, label %for.body253, label %for.inc590

for.body253:                                      ; preds = %for.cond249
  %66 = load %struct.b2s**, %struct.b2s*** %arrayidx255, align 8
  %arrayidx257 = getelementptr inbounds %struct.b2s*, %struct.b2s** %66, i64 %indvars.iv70
  %67 = load %struct.b2s*, %struct.b2s** %arrayidx257, align 8
  %cmp258 = icmp eq %struct.b2s* %67, null
  br i1 %cmp258, label %for.inc587, label %do.end278

do.end278:                                        ; preds = %for.body253
  store i32 0, i32* %55, align 8
  %bucket283 = getelementptr inbounds %struct.b2s, %struct.b2s* %67, i64 0, i32 0
  %68 = load i32, i32* %bucket283, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end376, %do.end278
  %69 = phi i32 [ 0, %do.end278 ], [ %inc301, %do.end376 ]
  %tmp262.0 = phi %struct.b2s* [ %67, %do.end278 ], [ %79, %do.end376 ]
  %cmp284 = icmp eq %struct.b2s* %tmp262.0, null
  br i1 %cmp284, label %for.cond380.preheader, label %do.body302

for.cond380.preheader:                            ; preds = %while.cond
  %idxprom385 = zext i32 %68 to i64
  br label %for.cond380

do.body302:                                       ; preds = %while.cond
  %qry289 = getelementptr inbounds %struct.b2s, %struct.b2s* %tmp262.0, i64 0, i32 1
  %70 = load i32, i32* %qry289, align 4
  %t291 = getelementptr inbounds %struct.b2s, %struct.b2s* %tmp262.0, i64 0, i32 2
  %71 = load i32, i32* %t291, align 8
  %inc301 = add i32 %69, 1
  store i32 %inc301, i32* %55, align 8
  %72 = load i32, i32* %56, align 4
  %cmp309 = icmp ult i32 %72, %inc301
  br i1 %cmp309, label %if.end312, label %do.body302.do.end376_crit_edge

do.body302.do.end376_crit_edge:                   ; preds = %do.body302
  %.pre = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %57, align 8
  br label %do.end376

if.end312:                                        ; preds = %do.body302
  %73 = load i32, i32* %inc321, align 8
  %add325 = add i32 %69, %73
  %neg = sub i32 0, %73
  %and = and i32 %add325, %neg
  store i32 %and, i32* %56, align 4
  %74 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %57, align 8
  %cmp336 = icmp eq %struct._cass_vecset_t* %74, null
  br i1 %cmp336, label %if.else351, label %if.then338

if.then338:                                       ; preds = %if.end312
  %75 = bitcast %struct._cass_vecset_t* %74 to i8*
  %conv345 = zext i32 %and to i64
  %mul346 = shl nuw nsw i64 %conv345, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @523, i32 0, i32 0))
  %call347 = call i8* @realloc(i8* %75, i64 %mul346) #11
  br label %if.end361

if.else351:                                       ; preds = %if.end312
  %conv355 = zext i32 %and to i64
  %mul356 = shl nuw nsw i64 %conv355, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @524, i32 0, i32 0))
  %call357 = call noalias i8* @malloc(i64 %mul356) #11
  br label %if.end361

if.end361:                                        ; preds = %if.else351, %if.then338
  %call357.sink = phi i8* [ %call357, %if.else351 ], [ %call347, %if.then338 ]
  %76 = bitcast i8* %call357.sink to %struct._cass_vecset_t*
  store i8* %call357.sink, i8** %58, align 8
  %cmp365 = icmp eq i8* %call357.sink, null
  br i1 %cmp365, label %if.else368, label %do.end376

if.else368:                                       ; preds = %if.end361
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @525, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.552, i64 0, i64 0), i8* getelementptr inbounds ([82 x i8], [82 x i8]* @.str.1.548, i64 0, i64 0), i32 354, i8* getelementptr inbounds ([88 x i8], [88 x i8]* @__PRETTY_FUNCTION__.LSH_query_batch_ca, i64 0, i64 0)) #16
  unreachable

do.end376:                                        ; preds = %do.body302.do.end376_crit_edge, %if.end361
  %77 = phi %struct._cass_vecset_t* [ %.pre, %do.body302.do.end376_crit_edge ], [ %76, %if.end361 ]
  %idxprom374 = sext i32 %69 to i64
  %arrayidx375 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %77, i64 %idxprom374
  %78 = bitcast %struct._cass_vecset_t* %arrayidx375 to i64*
  %t287.sroa.2.0.insert.ext = zext i32 %71 to i64
  %t287.sroa.2.0.insert.shift = shl nuw i64 %t287.sroa.2.0.insert.ext, 32
  %t287.sroa.0.0.insert.ext = zext i32 %70 to i64
  %t287.sroa.0.0.insert.insert = or i64 %t287.sroa.2.0.insert.shift, %t287.sroa.0.0.insert.ext
  store i64 %t287.sroa.0.0.insert.insert, i64* %78, align 4
  %next377 = getelementptr inbounds %struct.b2s, %struct.b2s* %tmp262.0, i64 0, i32 3
  %79 = load %struct.b2s*, %struct.b2s** %next377, align 8
  br label %while.cond

for.cond380:                                      ; preds = %for.cond380.preheader, %for.inc582
  %__array_foreach_index.0 = phi i32 [ %inc583, %for.inc582 ], [ 0, %for.cond380.preheader ]
  %80 = load %struct.ohash_t*, %struct.ohash_t** %hash381, align 8
  %bucket384 = getelementptr inbounds %struct.ohash_t, %struct.ohash_t* %80, i64 %indvars.iv72, i32 1
  %81 = load %struct.anon.5*, %struct.anon.5** %bucket384, align 8
  %len387 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %81, i64 %idxprom385, i32 2
  %82 = load i32, i32* %len387, align 8
  %cmp388 = icmp ult i32 %__array_foreach_index.0, %82
  br i1 %cmp388, label %do.body401, label %for.inc587

do.body401:                                       ; preds = %for.cond380
  %data398 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %81, i64 %idxprom385, i32 3
  %83 = load i32*, i32** %data398, align 8
  %idxprom399 = zext i32 %__array_foreach_index.0 to i64
  %arrayidx400 = getelementptr inbounds i32, i32* %83, i64 %idxprom399
  %84 = load i32, i32* %arrayidx400, align 4
  br label %for.cond404

for.cond404:                                      ; preds = %for.inc578, %do.body401
  %indvars.iv66 = phi i64 [ %indvars.iv.next67, %for.inc578 ], [ 0, %do.body401 ]
  %wide.trip.count68 = zext i32 %69 to i64
  %exitcond69 = icmp eq i64 %indvars.iv66, %wide.trip.count68
  br i1 %exitcond69, label %for.inc582, label %for.body410

for.body410:                                      ; preds = %for.cond404
  %85 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %57, align 8
  %86 = load %struct.cass_dataset_t*, %struct.cass_dataset_t** %ds, align 8
  %vec418 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %86, i64 0, i32 6
  %87 = load i8*, i8** %vec418, align 8
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %86, i64 0, i32 2
  %88 = load i32, i32* %vec_size, align 8
  %mul420 = mul i32 %84, %88
  %idx.ext421 = zext i32 %mul420 to i64
  %add.ptr422 = getelementptr inbounds i8, i8* %87, i64 %idx.ext421
  %u = getelementptr inbounds i8, i8* %add.ptr422, i64 8
  %arraydecay = bitcast i8* %u to float*
  %qry424 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %85, i64 %indvars.iv66, i32 0
  %89 = load i32, i32* %qry424, align 4
  %idxprom425 = sext i32 %89 to i64
  %arrayidx426 = getelementptr inbounds float*, float** %point, i64 %idxprom425
  %90 = load float*, float** %arrayidx426, align 8
  %call427 = call fastcc float @dist_L2_float.549(i32 %1, float* %arraydecay, float* %90)
  %t429 = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %85, i64 %indvars.iv66, i32 1
  %91 = load i32, i32* %t429, align 4
  %cmp430 = icmp eq i32 %91, -1
  br i1 %cmp430, label %while.cond437, label %while.cond502

while.cond437:                                    ; preds = %for.body410, %if.end462
  %indvars.iv62 = phi i64 [ %indvars.iv.next63, %if.end462 ], [ 0, %for.body410 ]
  %cmp438 = icmp slt i64 %indvars.iv62, %60
  %92 = trunc i64 %indvars.iv62 to i32
  br i1 %cmp438, label %while.body440, label %if.end466

while.body440:                                    ; preds = %while.cond437
  %93 = load i32, i32* %qry424, align 4
  %idxprom443 = sext i32 %93 to i64
  %arrayidx444 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, i64 %idxprom443
  %94 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx444, align 8
  %dist447 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %94, i64 %indvars.iv62, i32 1
  %95 = load float, float* %dist447, align 4
  %cmp448 = fcmp ogt float %call427, %95
  br i1 %cmp448, label %if.end466, label %if.end451

if.end451:                                        ; preds = %while.body440
  %id458 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %94, i64 %indvars.iv62, i32 0
  %96 = load i32, i32* %id458, align 4
  %cmp459 = icmp eq i32 %84, %96
  br i1 %cmp459, label %for.inc578, label %if.end462

if.end462:                                        ; preds = %if.end451
  %indvars.iv.next63 = add nuw nsw i64 %indvars.iv62, 1
  br label %while.cond437

if.end466:                                        ; preds = %while.cond437, %while.body440
  %cmp467 = icmp eq i32 %92, 0
  br i1 %cmp467, label %for.inc578, label %for.cond471.preheader

for.cond471.preheader:                            ; preds = %if.end466
  %sub472 = shl i64 %indvars.iv62, 32
  %sext100 = add i64 %sub472, -4294967296
  %97 = ashr exact i64 %sext100, 32
  br label %for.cond471

for.cond471:                                      ; preds = %for.cond471.preheader, %for.inc487
  %indvars.iv64 = phi i64 [ 0, %for.cond471.preheader ], [ %indvars.iv.next65, %for.inc487 ]
  %cmp473 = icmp slt i64 %indvars.iv64, %97
  %98 = load i32, i32* %qry424, align 4
  %idxprom477 = sext i32 %98 to i64
  %arrayidx478 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, i64 %idxprom477
  %99 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx478, align 8
  br i1 %cmp473, label %for.inc487, label %for.end489

for.inc487:                                       ; preds = %for.cond471
  %arrayidx480 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %99, i64 %indvars.iv64
  %indvars.iv.next65 = add nuw nsw i64 %indvars.iv64, 1
  %arrayidx486 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %99, i64 %indvars.iv.next65
  %100 = bitcast %struct.cass_list_entry_t* %arrayidx486 to i64*
  %101 = bitcast %struct.cass_list_entry_t* %arrayidx480 to i64*
  %102 = load i64, i64* %100, align 4
  store i64 %102, i64* %101, align 4
  br label %for.cond471

for.end489:                                       ; preds = %for.cond471
  %sext101 = shl i64 %indvars.iv64, 32
  %idxprom493 = ashr exact i64 %sext101, 32
  %.sroa_idx29 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %99, i64 %idxprom493, i32 0
  store i32 %84, i32* %.sroa_idx29, align 4
  %.sroa_idx30 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %99, i64 %idxprom493, i32 1
  store float %call427, float* %.sroa_idx30, align 4
  br label %for.inc578

while.cond502:                                    ; preds = %for.body410, %if.end533
  %indvars.iv58 = phi i64 [ %indvars.iv.next59, %if.end533 ], [ 0, %for.body410 ]
  %cmp503 = icmp slt i64 %indvars.iv58, %59
  %103 = trunc i64 %indvars.iv58 to i32
  br i1 %cmp503, label %while.body505, label %if.end538

while.body505:                                    ; preds = %while.cond502
  %104 = load i32, i32* %qry424, align 4
  %idxprom508 = sext i32 %104 to i64
  %arrayidx509 = getelementptr inbounds %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %ptopk.0, i64 %idxprom508
  %105 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %arrayidx509, align 8
  %idxprom511 = sext i32 %91 to i64
  %arrayidx512 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %105, i64 %idxprom511
  %106 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx512, align 8
  %dist515 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %106, i64 %indvars.iv58, i32 1
  %107 = load float, float* %dist515, align 4
  %cmp516 = fcmp ogt float %call427, %107
  br i1 %cmp516, label %if.end538, label %if.end519

if.end519:                                        ; preds = %while.body505
  %id529 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %106, i64 %indvars.iv58, i32 0
  %108 = load i32, i32* %id529, align 4
  %cmp530 = icmp eq i32 %84, %108
  br i1 %cmp530, label %for.inc578, label %if.end533

if.end533:                                        ; preds = %if.end519
  %indvars.iv.next59 = add nuw nsw i64 %indvars.iv58, 1
  br label %while.cond502

if.end538:                                        ; preds = %while.cond502, %while.body505
  %cmp539 = icmp eq i32 %103, 0
  br i1 %cmp539, label %for.inc578, label %for.cond543.preheader

for.cond543.preheader:                            ; preds = %if.end538
  %sub544 = shl i64 %indvars.iv58, 32
  %sext98 = add i64 %sub544, -4294967296
  %109 = ashr exact i64 %sext98, 32
  br label %for.cond543

for.cond543:                                      ; preds = %for.cond543.preheader, %for.inc565
  %indvars.iv60 = phi i64 [ 0, %for.cond543.preheader ], [ %indvars.iv.next61, %for.inc565 ]
  %cmp545 = icmp slt i64 %indvars.iv60, %109
  %110 = load i32, i32* %qry424, align 4
  %idxprom549 = sext i32 %110 to i64
  %arrayidx550 = getelementptr inbounds %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %ptopk.0, i64 %idxprom549
  %111 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %arrayidx550, align 8
  %112 = load i32, i32* %t429, align 4
  %idxprom552 = sext i32 %112 to i64
  %arrayidx553 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %111, i64 %idxprom552
  %113 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx553, align 8
  br i1 %cmp545, label %for.inc565, label %for.end567

for.inc565:                                       ; preds = %for.cond543
  %arrayidx555 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %113, i64 %indvars.iv60
  %indvars.iv.next61 = add nuw nsw i64 %indvars.iv60, 1
  %arrayidx564 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %113, i64 %indvars.iv.next61
  %114 = bitcast %struct.cass_list_entry_t* %arrayidx564 to i64*
  %115 = bitcast %struct.cass_list_entry_t* %arrayidx555 to i64*
  %116 = load i64, i64* %114, align 4
  store i64 %116, i64* %115, align 4
  br label %for.cond543

for.end567:                                       ; preds = %for.cond543
  %sext99 = shl i64 %indvars.iv60, 32
  %idxprom574 = ashr exact i64 %sext99, 32
  %.sroa_idx = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %113, i64 %idxprom574, i32 0
  store i32 %84, i32* %.sroa_idx, align 4
  %.sroa_idx24 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %113, i64 %idxprom574, i32 1
  store float %call427, float* %.sroa_idx24, align 4
  br label %for.inc578

for.inc578:                                       ; preds = %if.end519, %if.end451, %if.end466, %for.end489, %if.end538, %for.end567
  %indvars.iv.next67 = add nuw nsw i64 %indvars.iv66, 1
  br label %for.cond404

for.inc582:                                       ; preds = %for.cond404
  %inc583 = add i32 %__array_foreach_index.0, 1
  br label %for.cond380

for.inc587:                                       ; preds = %for.cond380, %for.body253
  %indvars.iv.next71 = add nuw nsw i64 %indvars.iv70, 1
  br label %for.cond249

for.inc590:                                       ; preds = %for.cond249
  %indvars.iv.next73 = add nuw nsw i64 %indvars.iv72, 1
  br label %for.cond245

for.cond593:                                      ; preds = %for.cond245, %for.inc618
  %indvars.iv55 = phi i64 [ %indvars.iv.next56, %for.inc618 ], [ 0, %for.cond245 ]
  %exitcond57 = icmp eq i64 %indvars.iv55, 1
  br i1 %exitcond57, label %for.end620, label %do.body597

do.body597:                                       ; preds = %for.cond593
  %data600 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv55, i32 3
  %117 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %data600, align 8
  %cmp601 = icmp eq %struct._cass_vecset_t* %117, null
  br i1 %cmp601, label %for.inc618, label %if.then603

if.then603:                                       ; preds = %do.body597
  %118 = bitcast %struct._cass_vecset_t* %117 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @526, i32 0, i32 0))
  call void @free(i8* %118) #11
  br label %for.inc618

for.inc618:                                       ; preds = %do.body597, %if.then603
  store %struct._cass_vecset_t* null, %struct._cass_vecset_t** %data600, align 8
  %len613 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv55, i32 2
  store i32 0, i32* %len613, align 8
  %size616 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %48, i64 %indvars.iv55, i32 1
  store i32 0, i32* %size616, align 4
  %indvars.iv.next56 = add nuw nsw i64 %indvars.iv55, 1
  br label %for.cond593

for.end620:                                       ; preds = %for.cond593
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @527, i32 0, i32 0))
  call void @free(i8* %call175) #11
  call fastcc void @__matrix_free(i8** %call102)
  %119 = bitcast i8*** %call to i8**
  call fastcc void @__matrix_free(i8** %119)
  br i1 %cmp, label %for.cond624.preheader, label %if.end727

for.cond624.preheader:                            ; preds = %for.end620
  %120 = sext i32 %3 to i64
  %121 = sext i32 %3 to i64
  %122 = sext i32 %N to i64
  br label %for.cond624

for.cond624:                                      ; preds = %for.cond624.preheader, %for.inc724
  %indvars.iv53 = phi i64 [ 0, %for.cond624.preheader ], [ %indvars.iv.next54, %for.inc724 ]
  %cmp625 = icmp slt i64 %indvars.iv53, %122
  br i1 %cmp625, label %for.cond632.preheader, label %if.end727

for.cond632.preheader:                            ; preds = %for.cond624
  %arrayidx650 = getelementptr inbounds %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %ptopk.0, i64 %indvars.iv53
  %arrayidx657 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %topk, i64 %indvars.iv53
  br label %for.cond632

for.cond632:                                      ; preds = %for.cond632.preheader, %for.inc721
  %indvars.iv51 = phi i64 [ 0, %for.cond632.preheader ], [ %indvars.iv.next52, %for.inc721 ]
  %wide.trip.count = zext i32 %4 to i64
  %exitcond = icmp eq i64 %indvars.iv51, %wide.trip.count
  br i1 %exitcond, label %for.inc724, label %for.cond636

for.cond636:                                      ; preds = %for.cond632, %for.inc718
  %indvars.iv49 = phi i64 [ %indvars.iv.next50, %for.inc718 ], [ 0, %for.cond632 ]
  %cmp637 = icmp slt i64 %indvars.iv49, %121
  br i1 %cmp637, label %while.cond645, label %for.inc721

while.cond645:                                    ; preds = %for.cond636, %if.end680
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end680 ], [ 0, %for.cond636 ]
  %cmp646 = icmp slt i64 %indvars.iv, %120
  %123 = trunc i64 %indvars.iv to i32
  br i1 %cmp646, label %while.body648, label %if.end685

while.body648:                                    ; preds = %while.cond645
  %124 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %arrayidx650, align 8
  %arrayidx652 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %124, i64 %indvars.iv51
  %125 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx652, align 8
  %dist655 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %125, i64 %indvars.iv49, i32 1
  %126 = load float, float* %dist655, align 4
  %127 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx657, align 8
  %dist660 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %127, i64 %indvars.iv, i32 1
  %128 = load float, float* %dist660, align 4
  %cmp661 = fcmp ogt float %126, %128
  br i1 %cmp661, label %if.end685, label %if.end664

if.end664:                                        ; preds = %while.body648
  %id671 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %125, i64 %indvars.iv49, i32 0
  %129 = load i32, i32* %id671, align 4
  %id676 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %127, i64 %indvars.iv, i32 0
  %130 = load i32, i32* %id676, align 4
  %cmp677 = icmp eq i32 %129, %130
  br i1 %cmp677, label %for.inc718, label %if.end680

if.end680:                                        ; preds = %if.end664
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %while.cond645

if.end685:                                        ; preds = %while.cond645, %while.body648
  %cmp686 = icmp eq i32 %123, 0
  br i1 %cmp686, label %for.inc718, label %for.cond690.preheader

for.cond690.preheader:                            ; preds = %if.end685
  %sub691 = shl i64 %indvars.iv, 32
  %sext = add i64 %sub691, -4294967296
  %131 = ashr exact i64 %sext, 32
  br label %for.cond690

for.cond690:                                      ; preds = %for.cond690.preheader, %for.inc704
  %indvars.iv47 = phi i64 [ 0, %for.cond690.preheader ], [ %indvars.iv.next48, %for.inc704 ]
  %cmp692 = icmp slt i64 %indvars.iv47, %131
  %132 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx657, align 8
  br i1 %cmp692, label %for.inc704, label %for.end706

for.inc704:                                       ; preds = %for.cond690
  %arrayidx698 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %132, i64 %indvars.iv47
  %indvars.iv.next48 = add nuw nsw i64 %indvars.iv47, 1
  %arrayidx703 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %132, i64 %indvars.iv.next48
  %133 = bitcast %struct.cass_list_entry_t* %arrayidx703 to i64*
  %134 = bitcast %struct.cass_list_entry_t* %arrayidx698 to i64*
  %135 = load i64, i64* %133, align 4
  store i64 %135, i64* %134, align 4
  br label %for.cond690

for.end706:                                       ; preds = %for.cond690
  %sext97 = shl i64 %indvars.iv47, 32
  %idxprom709 = ashr exact i64 %sext97, 32
  %arrayidx710 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %132, i64 %idxprom709
  %136 = load %struct.cass_list_entry_t**, %struct.cass_list_entry_t*** %arrayidx650, align 8
  %arrayidx714 = getelementptr inbounds %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %136, i64 %indvars.iv51
  %137 = load %struct.cass_list_entry_t*, %struct.cass_list_entry_t** %arrayidx714, align 8
  %arrayidx716 = getelementptr inbounds %struct.cass_list_entry_t, %struct.cass_list_entry_t* %137, i64 %indvars.iv49
  %138 = bitcast %struct.cass_list_entry_t* %arrayidx716 to i64*
  %139 = bitcast %struct.cass_list_entry_t* %arrayidx710 to i64*
  %140 = load i64, i64* %138, align 4
  store i64 %140, i64* %139, align 4
  br label %for.inc718

for.inc718:                                       ; preds = %if.end664, %for.end706, %if.end685
  %indvars.iv.next50 = add nuw nsw i64 %indvars.iv49, 1
  br label %for.cond636

for.inc721:                                       ; preds = %for.cond636
  %indvars.iv.next52 = add nuw nsw i64 %indvars.iv51, 1
  br label %for.cond632

for.inc724:                                       ; preds = %for.cond632
  %indvars.iv.next54 = add nuw nsw i64 %indvars.iv53, 1
  br label %for.cond624

if.end727:                                        ; preds = %for.cond624, %for.end620
  %cmp728 = icmp eq %struct.cass_list_entry_t*** %ptopk.0, null
  br i1 %cmp728, label %if.end731, label %if.then730

if.then730:                                       ; preds = %if.end727
  call fastcc void @__matrix3_free(i8*** %50)
  br label %if.end731

if.end731:                                        ; preds = %if.end727, %if.then730
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @LSH_hash2_b2s_L(%struct.LSH_t* nocapture readonly %lsh, i32** nocapture readonly %hash, %struct.b2s** nocapture readonly %hash2, i32 %L, i32 %qry) unnamed_addr #8 {
entry:
  %M = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 1
  %rnd = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 8
  %H = getelementptr inbounds %struct.LSH_t, %struct.LSH_t* %lsh, i64 0, i32 3
  %0 = sext i32 %L to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc23, %entry
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc23 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv1, %0
  br i1 %cmp, label %for.cond1.preheader, label %for.end25

for.cond1.preheader:                              ; preds = %for.cond
  %1 = load i32, i32* %M, align 4
  %arrayidx7 = getelementptr inbounds i32*, i32** %hash, i64 %indvars.iv1
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]
  %h2.0 = phi i32 [ 0, %for.cond1.preheader ], [ %add, %for.inc ]
  %wide.trip.count = zext i32 %1 to i64
  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count
  br i1 %exitcond, label %for.inc23, label %for.inc

for.inc:                                          ; preds = %for.cond1
  %2 = load i32**, i32*** %rnd, align 8
  %arrayidx = getelementptr inbounds i32*, i32** %2, i64 %indvars.iv1
  %3 = load i32*, i32** %arrayidx, align 8
  %arrayidx5 = getelementptr inbounds i32, i32* %3, i64 %indvars.iv
  %4 = load i32, i32* %arrayidx5, align 4
  %5 = load i32*, i32** %arrayidx7, align 8
  %arrayidx9 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %6 = load i32, i32* %arrayidx9, align 4
  %mul = mul i32 %4, %6
  %add = add i32 %h2.0, %mul
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond1

for.inc23:                                        ; preds = %for.cond1
  %arrayidx11 = getelementptr inbounds %struct.b2s*, %struct.b2s** %hash2, i64 %indvars.iv1
  %7 = load %struct.b2s*, %struct.b2s** %arrayidx11, align 8
  %qry13 = getelementptr inbounds %struct.b2s, %struct.b2s* %7, i64 0, i32 1
  store i32 %qry, i32* %qry13, align 4
  %8 = load %struct.b2s*, %struct.b2s** %arrayidx11, align 8
  %t = getelementptr inbounds %struct.b2s, %struct.b2s* %8, i64 0, i32 2
  store i32 -1, i32* %t, align 8
  %9 = load i32, i32* %H, align 4
  %rem = urem i32 %h2.0, %9
  %10 = load %struct.b2s*, %struct.b2s** %arrayidx11, align 8
  %bucket = getelementptr inbounds %struct.b2s, %struct.b2s* %10, i64 0, i32 0
  store i32 %rem, i32* %bucket, align 8
  %11 = load %struct.b2s*, %struct.b2s** %arrayidx11, align 8
  %next = getelementptr inbounds %struct.b2s, %struct.b2s* %11, i64 0, i32 3
  store %struct.b2s* null, %struct.b2s** %next, align 8
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end25:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @prime(i32 %n) unnamed_addr #0 {
entry:
  %rem1 = and i32 %n, 1
  %0 = xor i32 %rem1, 1
  %inc.n = add nsw i32 %0, %n
  br label %for.cond

for.cond:                                         ; preds = %entry, %if.end16
  %n.addr.1 = phi i32 [ %add17, %if.end16 ], [ %inc.n, %entry ]
  %conv = sitofp i32 %n.addr.1 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @528, i32 0, i32 0))
  %call = call double @sqrt(double %conv) #11
  %conv1 = fptosi double %call to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.cond
  %conv11.sink = phi double [ %conv11, %while.body ], [ 3.000000e+00, %for.cond ]
  %j.0 = phi i64 [ %add, %while.body ], [ 3, %for.cond ]
  %div12 = fdiv double %conv, %conv11.sink
  %conv4 = fptosi double %div12 to i64
  %conv5 = sitofp i64 %conv4 to double
  %cmp6 = fcmp une double %div12, %conv5
  %cmp8 = icmp sle i64 %j.0, %conv1
  %or.cond = and i1 %cmp6, %cmp8
  br i1 %or.cond, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %add = add nuw nsw i64 %j.0, 2
  %conv11 = sitofp i64 %add to double
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp13 = icmp sgt i64 %j.0, %conv1
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %while.end
  ret i32 %n.addr.1

if.end16:                                         ; preds = %while.end
  %add17 = add nsw i32 %n.addr.1, 2
  br label %for.cond
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.ptb_vec_t* @gen_score(i32 %M) unnamed_addr #0 {
entry:
  %mul = shl nsw i32 %M, 1
  %conv = sext i32 %mul to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @529, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 24, i64 %conv) #11
  %0 = bitcast i8* %call to %struct.ptb_vec_t*
  %conv7 = sitofp i32 %M to double
  %add8 = fadd double %conv7, 1.000000e+00
  %add10 = fadd double %conv7, 2.000000e+00
  %sub = add nsw i32 %mul, -1
  %1 = sext i32 %M to i64
  %2 = sext i32 %sub to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv, %1
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %3 = trunc i64 %indvars.iv to i32
  %shl = shl i32 1, %3
  %conv2 = sext i32 %shl to i64
  %set = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %indvars.iv, i32 0
  store i64 %conv2, i64* %set, align 8
  %4 = trunc i64 %indvars.iv to i32
  %conv3 = sitofp i32 %4 to double
  %add = fadd double %conv3, 1.000000e+00
  %add5 = fadd double %conv3, 2.000000e+00
  %mul6 = fmul double %add, %add5
  %div = fdiv double %mul6, %add8
  %div11 = fdiv double %div, %add10
  %mul12 = fmul double %div11, 2.500000e-01
  %conv13 = fptrunc double %mul12 to float
  %key = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %indvars.iv, i32 1
  store float %conv13, float* %key, align 8
  %div20 = fdiv double %add, %add8
  %mul21 = fmul double %div20, 5.000000e-01
  %conv22 = fptrunc double %mul21 to float
  %key1 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %indvars.iv, i32 4
  store float %conv22, float* %key1, align 4
  %5 = sub nsw i64 %2, %indvars.iv
  %6 = trunc i64 %5 to i32
  %shl27 = shl i32 1, %6
  %conv28 = sext i32 %shl27 to i64
  %set34 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %5, i32 0
  store i64 %conv28, i64* %set34, align 8
  %conv38 = fpext float %conv22 to double
  %mul39 = fmul double %conv38, 2.000000e+00
  %sub40 = fsub double 1.000000e+00, %mul39
  %conv44 = fpext float %conv13 to double
  %add45 = fadd double %sub40, %conv44
  %conv46 = fptrunc double %add45 to float
  %key52 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %5, i32 1
  store float %conv46, float* %key52, align 8
  %conv58 = fsub float 1.000000e+00, %conv22
  %key164 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %0, i64 %5, i32 4
  store float %conv58, float* %key164, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret %struct.ptb_vec_t* %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @gen_perturb_set(%struct.ptb_vec_t* nocapture readonly %score, %struct.ptb_vec_t* nocapture %set, i32 %M, i32 %T) unnamed_addr #0 {
do.body5:
  %ptb.sroa.0.0..sroa_idx73 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 0, i32 0
  %ptb.sroa.0.0.copyload74 = load i64, i64* %ptb.sroa.0.0..sroa_idx73, align 8
  %ptb.sroa.10.0..sroa_idx82 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 0, i32 1
  %0 = bitcast float* %ptb.sroa.10.0..sroa_idx82 to i32*
  %ptb.sroa.10.0.copyload83151 = load i32, i32* %0, align 8
  %ptb.sroa.15.0..sroa_idx93 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 0, i32 2
  %ptb.sroa.15.0.copyload94 = load i32, i32* %ptb.sroa.15.0..sroa_idx93, align 4
  %ptb.sroa.22.0..sroa_idx113 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 0, i32 4
  %1 = bitcast float* %ptb.sroa.22.0..sroa_idx113 to i32*
  %ptb.sroa.22.0.copyload114149 = load i32, i32* %1, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @530, i32 0, i32 0))
  %call24 = call noalias i8* @malloc(i64 6144) #11
  %2 = bitcast i8* %call24 to %struct.ptb_vec_t*
  %cmp28 = icmp eq i8* %call24, null
  br i1 %cmp28, label %if.else31, label %do.end52

if.else31:                                        ; preds = %do.body5
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @531, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.557, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 62, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.gen_perturb_set, i64 0, i64 0)) #16
  unreachable

do.end52:                                         ; preds = %do.body5
  %ptb.sroa.0.0..sroa_idx71 = bitcast i8* %call24 to i64*
  store i64 %ptb.sroa.0.0.copyload74, i64* %ptb.sroa.0.0..sroa_idx71, align 8
  %ptb.sroa.10.0..sroa_idx80 = getelementptr inbounds i8, i8* %call24, i64 8
  %3 = bitcast i8* %ptb.sroa.10.0..sroa_idx80 to i32*
  store i32 %ptb.sroa.10.0.copyload83151, i32* %3, align 8
  %ptb.sroa.15.0..sroa_idx91 = getelementptr inbounds i8, i8* %call24, i64 12
  %4 = bitcast i8* %ptb.sroa.15.0..sroa_idx91 to i32*
  store i32 %ptb.sroa.15.0.copyload94, i32* %4, align 4
  %ptb.sroa.16.0..sroa_idx100 = getelementptr inbounds i8, i8* %call24, i64 16
  %5 = bitcast i8* %ptb.sroa.16.0..sroa_idx100 to i32*
  store i32 0, i32* %5, align 8
  %ptb.sroa.22.0..sroa_idx111 = getelementptr inbounds i8, i8* %call24, i64 20
  %6 = bitcast i8* %ptb.sroa.22.0..sroa_idx111 to i32*
  store i32 %ptb.sroa.22.0.copyload114149, i32* %6, align 4
  %cmp53 = icmp sgt i32 %T, 0
  br i1 %cmp53, label %for.cond.preheader, label %if.end338

for.cond.preheader:                               ; preds = %do.end52
  %mul70 = shl nsw i32 %M, 1
  %sub71 = add nsw i32 %mul70, -1
  %7 = sext i32 %M to i64
  %8 = sext i32 %sub71 to i64
  br label %for.cond.outer

for.cond.outer:                                   ; preds = %for.cond.preheader, %do.end336
  %9 = phi i8* [ %call24, %for.cond.preheader ], [ %36, %do.end336 ]
  %10 = phi i8* [ %call24, %for.cond.preheader ], [ %37, %do.end336 ]
  %11 = phi i8* [ %call24, %for.cond.preheader ], [ %38, %do.end336 ]
  %heap.sroa.39.2.ph = phi %struct.ptb_vec_t* [ %2, %for.cond.preheader ], [ %heap.sroa.39.6.ph, %do.end336 ]
  %heap.sroa.21.0.ph = phi i32 [ 1, %for.cond.preheader ], [ %inc269, %do.end336 ]
  %heap.sroa.4.1.ph = phi i32 [ 256, %for.cond.preheader ], [ %heap.sroa.4.3.ph, %do.end336 ]
  %i.0.ph = phi i32 [ 0, %for.cond.preheader ], [ %i.1, %do.end336 ]
  %ptb.sroa.0.0..sroa_idx69 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 0, i32 0
  %ptb.sroa.10.0..sroa_idx78 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 0, i32 1
  %ptb.sroa.15.0..sroa_idx89 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 0, i32 2
  %ptb.sroa.16.0..sroa_idx98 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 0, i32 3
  %ptb.sroa.22.0..sroa_idx109 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.cond.outer, %do.end147
  %heap.sroa.21.0 = phi i32 [ %dec, %do.end147 ], [ %heap.sroa.21.0.ph, %for.cond.outer ]
  %i.0 = phi i32 [ %i.1, %do.end147 ], [ %i.0.ph, %for.cond.outer ]
  %cmp57 = icmp eq i32 %heap.sroa.21.0, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @532, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 83, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.gen_perturb_set, i64 0, i64 0)) #16
  unreachable

if.end60:                                         ; preds = %for.cond
  %ptb.sroa.0.0.copyload70 = load i64, i64* %ptb.sroa.0.0..sroa_idx69, align 8
  %ptb.sroa.10.0.copyload79 = load float, float* %ptb.sroa.10.0..sroa_idx78, align 8
  %ptb.sroa.15.0.copyload90 = load i32, i32* %ptb.sroa.15.0..sroa_idx89, align 4
  %ptb.sroa.16.0.copyload99 = load i32, i32* %ptb.sroa.16.0..sroa_idx98, align 8
  %12 = bitcast float* %ptb.sroa.22.0..sroa_idx109 to i32*
  %ptb.sroa.22.0.copyload110150 = load i32, i32* %12, align 4
  br label %for.cond63

for.cond63:                                       ; preds = %for.inc, %if.end60
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end60 ]
  %cmp64 = icmp slt i64 %indvars.iv, %7
  br i1 %cmp64, label %for.body, label %if.then81

for.body:                                         ; preds = %for.cond63
  %and68 = and i64 %ptb.sroa.0.0.copyload70, %indvars.iv
  %tobool = icmp eq i64 %and68, 0
  br i1 %tobool, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = sub nsw i64 %8, %indvars.iv
  %and74 = and i64 %ptb.sroa.0.0.copyload70, %13
  %tobool75 = icmp eq i64 %and74, 0
  br i1 %tobool75, label %for.inc, label %if.end97

for.inc:                                          ; preds = %for.body, %land.lhs.true
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond63

if.then81:                                        ; preds = %for.cond63
  %idxprom82 = sext i32 %i.0 to i64
  %ptb.sroa.0.0..sroa_idx67 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %idxprom82, i32 0
  store i64 %ptb.sroa.0.0.copyload70, i64* %ptb.sroa.0.0..sroa_idx67, align 8
  %ptb.sroa.10.0..sroa_idx76 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %idxprom82, i32 1
  store float %ptb.sroa.10.0.copyload79, float* %ptb.sroa.10.0..sroa_idx76, align 8
  %ptb.sroa.15.0..sroa_idx87 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %idxprom82, i32 2
  store i32 %ptb.sroa.15.0.copyload90, i32* %ptb.sroa.15.0..sroa_idx87, align 4
  %ptb.sroa.16.0..sroa_idx96 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %idxprom82, i32 3
  store i32 %ptb.sroa.16.0.copyload99, i32* %ptb.sroa.16.0..sroa_idx96, align 8
  %ptb.sroa.22.0..sroa_idx107 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %idxprom82, i32 4
  %14 = bitcast float* %ptb.sroa.22.0..sroa_idx107 to i32*
  store i32 %ptb.sroa.22.0.copyload110150, i32* %14, align 4
  %inc84 = add nsw i32 %i.0, 1
  %cmp85 = icmp eq i32 %inc84, %T
  br i1 %cmp85, label %do.body343, label %if.end97

if.end97:                                         ; preds = %land.lhs.true, %if.then81
  %i.1 = phi i32 [ %inc84, %if.then81 ], [ %i.0, %land.lhs.true ]
  %dec = add i32 %heap.sroa.21.0, -1
  %idxprom127 = sext i32 %dec to i64
  %key129 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom127, i32 1
  br label %for.cond100

for.cond100:                                      ; preds = %if.end133, %if.end97
  %_i_91.0 = phi i32 [ 0, %if.end97 ], [ %_l_.0, %if.end133 ]
  %shl = shl i32 %_i_91.0, 1
  %add101 = or i32 %shl, 1
  %cmp102 = icmp slt i32 %add101, %dec
  br i1 %cmp102, label %if.end105, label %do.end147

if.end105:                                        ; preds = %for.cond100
  %add106 = add nsw i32 %add101, 1
  %cmp107 = icmp slt i32 %add106, %dec
  br i1 %cmp107, label %land.lhs.true109, label %if.end121

land.lhs.true109:                                 ; preds = %if.end105
  %idxprom111 = sext i32 %add101 to i64
  %key113 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom111, i32 1
  %15 = load float, float* %key113, align 8
  %idxprom115 = sext i32 %add106 to i64
  %key117 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom115, i32 1
  %16 = load float, float* %key117, align 8
  %cmp118 = fcmp ult float %15, %16
  br i1 %cmp118, label %if.end121, label %if.then120

if.then120:                                       ; preds = %land.lhs.true109
  br label %if.end121

if.end121:                                        ; preds = %land.lhs.true109, %if.then120, %if.end105
  %_l_.0 = phi i32 [ %add106, %if.then120 ], [ %add101, %land.lhs.true109 ], [ %add101, %if.end105 ]
  %idxprom123 = sext i32 %_l_.0 to i64
  %key125 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom123, i32 1
  %17 = load float, float* %key125, align 8
  %18 = load float, float* %key129, align 8
  %cmp130 = fcmp ult float %17, %18
  br i1 %cmp130, label %if.end133, label %do.end147

if.end133:                                        ; preds = %if.end121
  %idxprom135 = sext i32 %_i_91.0 to i64
  %arrayidx136 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom135
  %arrayidx139 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom123
  %19 = bitcast %struct.ptb_vec_t* %arrayidx136 to i8*
  %20 = bitcast %struct.ptb_vec_t* %arrayidx139 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 24, i32 8, i1 false)
  br label %for.cond100

do.end147:                                        ; preds = %for.cond100, %if.end121
  %idxprom142 = sext i32 %_i_91.0 to i64
  %arrayidx143 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom142
  %arrayidx146 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.2.ph, i64 %idxprom127
  %21 = bitcast %struct.ptb_vec_t* %arrayidx143 to i8*
  %22 = bitcast %struct.ptb_vec_t* %arrayidx146 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 24, i32 8, i1 false)
  %inc150 = add i32 %ptb.sroa.16.0.copyload99, 1
  %cmp153 = icmp ult i32 %inc150, %mul70
  br i1 %cmp153, label %do.body185, label %for.cond

do.body185:                                       ; preds = %do.end147
  %idxprom157 = sext i32 %ptb.sroa.16.0.copyload99 to i64
  %set159 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 %idxprom157, i32 0
  %23 = load i64, i64* %set159, align 8
  %neg160 = xor i64 %23, -1
  %and162 = and i64 %ptb.sroa.0.0.copyload70, %neg160
  %key165 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 %idxprom157, i32 1
  %24 = load float, float* %key165, align 8
  %sub167 = fsub float %ptb.sroa.10.0.copyload79, %24
  %idxprom169 = zext i32 %inc150 to i64
  %set171 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 %idxprom169, i32 0
  %25 = load i64, i64* %set171, align 8
  %or = or i64 %ptb.sroa.0.0.copyload70, %25
  %key176 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %score, i64 %idxprom169, i32 1
  %26 = load float, float* %key176, align 8
  %add178 = fadd float %ptb.sroa.10.0.copyload79, %26
  %cmp188 = icmp ult i32 %heap.sroa.4.1.ph, %heap.sroa.21.0
  br i1 %cmp188, label %if.end219, label %while.cond227.preheader

while.cond227.preheader:                          ; preds = %if.end219, %do.body185
  %27 = phi i8* [ %9, %do.body185 ], [ %call211, %if.end219 ]
  %28 = phi i8* [ %10, %do.body185 ], [ %call211, %if.end219 ]
  %29 = phi i8* [ %11, %do.body185 ], [ %call211, %if.end219 ]
  %heap.sroa.39.4.ph = phi %struct.ptb_vec_t* [ %heap.sroa.39.2.ph, %do.body185 ], [ %heap.sroa.39.3, %if.end219 ]
  %heap.sroa.4.2.ph = phi i32 [ %heap.sroa.4.1.ph, %do.body185 ], [ %and202, %if.end219 ]
  br label %while.cond227

if.end219:                                        ; preds = %do.body185
  %add197 = add i32 %heap.sroa.21.0, 255
  %and202 = and i32 %add197, -256
  %conv215 = zext i32 %and202 to i64
  %mul216 = mul nuw nsw i64 %conv215, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @533, i32 0, i32 0))
  %call211 = call i8* @realloc(i8* %11, i64 %mul216) #11
  %heap.sroa.39.3 = bitcast i8* %call211 to %struct.ptb_vec_t*
  %cmp221 = icmp eq i8* %call211, null
  br i1 %cmp221, label %if.else224, label %while.cond227.preheader

if.else224:                                       ; preds = %if.end219
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @534, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.557, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 108, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.gen_perturb_set, i64 0, i64 0)) #16
  unreachable

while.cond227:                                    ; preds = %while.cond227.preheader, %if.end240
  %_i_180.0 = phi i32 [ %shr231, %if.end240 ], [ %dec, %while.cond227.preheader ]
  %cmp228 = icmp sgt i32 %_i_180.0, 0
  br i1 %cmp228, label %while.body230, label %do.body270

while.body230:                                    ; preds = %while.cond227
  %shr231 = ashr i32 %_i_180.0, 1
  %idxprom234 = sext i32 %shr231 to i64
  %key236 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom234, i32 1
  %30 = load float, float* %key236, align 8
  %cmp237 = fcmp ult float %add178, %30
  br i1 %cmp237, label %if.end240, label %do.body270

if.end240:                                        ; preds = %while.body230
  %idxprom242 = sext i32 %_i_180.0 to i64
  %arrayidx243 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom242
  %arrayidx246 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom234
  %31 = bitcast %struct.ptb_vec_t* %arrayidx243 to i8*
  %32 = bitcast %struct.ptb_vec_t* %arrayidx246 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %31, i8* %32, i64 24, i32 8, i1 false)
  br label %while.cond227

do.body270:                                       ; preds = %while.cond227, %while.body230
  %idxprom249 = sext i32 %_i_180.0 to i64
  %ptb.sroa.0.0..sroa_idx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom249, i32 0
  store i64 %or, i64* %ptb.sroa.0.0..sroa_idx, align 8
  %ptb.sroa.10.0..sroa_idx75 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom249, i32 1
  store float %add178, float* %ptb.sroa.10.0..sroa_idx75, align 8
  %ptb.sroa.15.0..sroa_idx86 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom249, i32 2
  store i32 %ptb.sroa.15.0.copyload90, i32* %ptb.sroa.15.0..sroa_idx86, align 4
  %ptb.sroa.16.0..sroa_idx95 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom249, i32 3
  store i32 %inc150, i32* %ptb.sroa.16.0..sroa_idx95, align 8
  %ptb.sroa.22.0..sroa_idx106 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.4.ph, i64 %idxprom249, i32 4
  %33 = bitcast float* %ptb.sroa.22.0..sroa_idx106 to i32*
  store i32 %ptb.sroa.22.0.copyload110150, i32* %33, align 4
  %34 = load i64, i64* %set171, align 8
  %or257 = or i64 %and162, %34
  %35 = load float, float* %key176, align 8
  %add263 = fadd float %sub167, %35
  %inc269 = add i32 %heap.sroa.21.0, 1
  %cmp273 = icmp ult i32 %heap.sroa.4.2.ph, %inc269
  br i1 %cmp273, label %if.end304, label %while.cond312.preheader

while.cond312.preheader:                          ; preds = %if.end304, %do.body270
  %36 = phi i8* [ %27, %do.body270 ], [ %call296, %if.end304 ]
  %37 = phi i8* [ %28, %do.body270 ], [ %call296, %if.end304 ]
  %38 = phi i8* [ %29, %do.body270 ], [ %call296, %if.end304 ]
  %heap.sroa.39.6.ph = phi %struct.ptb_vec_t* [ %heap.sroa.39.4.ph, %do.body270 ], [ %heap.sroa.39.5, %if.end304 ]
  %heap.sroa.4.3.ph = phi i32 [ %heap.sroa.4.2.ph, %do.body270 ], [ %and287, %if.end304 ]
  br label %while.cond312

if.end304:                                        ; preds = %do.body270
  %add282 = add i32 %heap.sroa.21.0, 256
  %and287 = and i32 %add282, -256
  %conv300 = zext i32 %and287 to i64
  %mul301 = mul nuw nsw i64 %conv300, 24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @535, i32 0, i32 0))
  %call296 = call i8* @realloc(i8* %28, i64 %mul301) #11
  %heap.sroa.39.5 = bitcast i8* %call296 to %struct.ptb_vec_t*
  %cmp306 = icmp eq i8* %call296, null
  br i1 %cmp306, label %if.else309, label %while.cond312.preheader

if.else309:                                       ; preds = %if.end304
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @536, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.557, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 116, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.gen_perturb_set, i64 0, i64 0)) #16
  unreachable

while.cond312:                                    ; preds = %while.cond312.preheader, %if.end325
  %_i_265.0 = phi i32 [ %shr316, %if.end325 ], [ %heap.sroa.21.0, %while.cond312.preheader ]
  %cmp313 = icmp sgt i32 %_i_265.0, 0
  br i1 %cmp313, label %while.body315, label %do.end336

while.body315:                                    ; preds = %while.cond312
  %shr316 = ashr i32 %_i_265.0, 1
  %idxprom319 = sext i32 %shr316 to i64
  %key321 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom319, i32 1
  %39 = load float, float* %key321, align 8
  %cmp322 = fcmp ult float %add263, %39
  br i1 %cmp322, label %if.end325, label %do.end336

if.end325:                                        ; preds = %while.body315
  %idxprom327 = sext i32 %_i_265.0 to i64
  %arrayidx328 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom327
  %arrayidx331 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom319
  %40 = bitcast %struct.ptb_vec_t* %arrayidx328 to i8*
  %41 = bitcast %struct.ptb_vec_t* %arrayidx331 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %40, i8* %41, i64 24, i32 8, i1 false)
  br label %while.cond312

do.end336:                                        ; preds = %while.cond312, %while.body315
  %idxprom334 = sext i32 %_i_265.0 to i64
  %ptb2.sroa.0.0..sroa_idx47 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom334, i32 0
  store i64 %or257, i64* %ptb2.sroa.0.0..sroa_idx47, align 8
  %ptb2.sroa.6.0..sroa_idx50 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom334, i32 1
  store float %add263, float* %ptb2.sroa.6.0..sroa_idx50, align 8
  %ptb2.sroa.11.0..sroa_idx55 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom334, i32 2
  store i32 %ptb.sroa.15.0.copyload90, i32* %ptb2.sroa.11.0..sroa_idx55, align 4
  %ptb2.sroa.1157.0..sroa_idx59 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom334, i32 3
  store i32 %inc150, i32* %ptb2.sroa.1157.0..sroa_idx59, align 8
  %ptb2.sroa.13.0..sroa_idx63 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %heap.sroa.39.6.ph, i64 %idxprom334, i32 4
  %42 = bitcast float* %ptb2.sroa.13.0..sroa_idx63 to i32*
  store i32 %ptb.sroa.22.0.copyload110150, i32* %42, align 4
  br label %for.cond.outer

if.end338:                                        ; preds = %do.end52
  %43 = phi i8* [ %call24, %do.end52 ]
  %i.2 = phi i32 [ 0, %do.end52 ]
  %cmp339 = icmp slt i32 %i.2, %T
  br i1 %cmp339, label %if.then341, label %if.then347

if.then341:                                       ; preds = %if.end338
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @537, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2.559, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 119, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__PRETTY_FUNCTION__.gen_perturb_set, i64 0, i64 0)) #16
  unreachable

do.body343:                                       ; preds = %if.then81
  %cmp345 = icmp eq %struct.ptb_vec_t* %heap.sroa.39.2.ph, null
  br i1 %cmp345, label %do.end353, label %if.then347

if.then347:                                       ; preds = %if.end338, %do.body343
  %44 = phi i8* [ %9, %do.body343 ], [ %43, %if.end338 ]
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @538, i32 0, i32 0))
  call void @free(i8* %44) #11
  br label %do.end353

do.end353:                                        ; preds = %if.then347, %do.body343
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @map_perturb_vector(%struct.ptb_vec_t* nocapture readonly %set, %struct.ptb_vec_t* nocapture %vector, %struct.ptb_vec_t* nocapture readonly %mapping, i32 %M, i32 %T) unnamed_addr #0 {
entry:
  %vec.sroa.11 = alloca i64, align 8
  %mul = shl nsw i32 %M, 1
  %0 = sext i32 %mul to i64
  %1 = sext i32 %T to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc30, %entry
  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %for.inc30 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv11, %1
  br i1 %cmp, label %for.body, label %for.end32

for.body:                                         ; preds = %for.cond
  %set5 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %set, i64 %indvars.iv11, i32 0
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body ]
  %vec.sroa.8.0 = phi i32 [ %vec.sroa.8.1, %for.inc ], [ 0, %for.body ]
  %vec.sroa.5.0 = phi float [ %vec.sroa.5.1, %for.inc ], [ 0.000000e+00, %for.body ]
  %vec.sroa.0.0 = phi i64 [ %vec.sroa.0.1, %for.inc ], [ 0, %for.body ]
  %cmp3 = icmp slt i64 %indvars.iv, %0
  br i1 %cmp3, label %for.body4, label %for.inc30

for.body4:                                        ; preds = %for.cond2
  %2 = load i64, i64* %set5, align 8
  %3 = trunc i64 %indvars.iv to i32
  %shl = shl i32 1, %3
  %conv = sext i32 %shl to i64
  %and = and i64 %2, %conv
  %tobool = icmp eq i64 %and, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body4
  %set9 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %mapping, i64 %indvars.iv, i32 0
  %4 = load i64, i64* %set9, align 8
  %and10 = and i64 %vec.sroa.0.0, %4
  %cmp11 = icmp eq i64 %and10, 0
  br i1 %cmp11, label %if.end, label %if.else

if.else:                                          ; preds = %if.then
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @539, i32 0, i32 0))
  call void @__assert_fail(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.4.563, i64 0, i64 0), i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.1.558, i64 0, i64 0), i32 138, i8* getelementptr inbounds ([84 x i8], [84 x i8]* @__PRETTY_FUNCTION__.map_perturb_vector, i64 0, i64 0)) #16
  unreachable

if.end:                                           ; preds = %if.then
  %or = or i64 %vec.sroa.0.0, %4
  %dir20 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %mapping, i64 %indvars.iv, i32 2
  %5 = load i32, i32* %dir20, align 4
  %or22 = or i32 %vec.sroa.8.0, %5
  %key25 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %mapping, i64 %indvars.iv, i32 1
  %6 = load float, float* %key25, align 8
  %add = fadd float %vec.sroa.5.0, %6
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body4
  %vec.sroa.8.1 = phi i32 [ %vec.sroa.8.0, %for.body4 ], [ %or22, %if.end ]
  %vec.sroa.5.1 = phi float [ %vec.sroa.5.0, %for.body4 ], [ %add, %if.end ]
  %vec.sroa.0.1 = phi i64 [ %vec.sroa.0.0, %for.body4 ], [ %or, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond2

for.inc30:                                        ; preds = %for.cond2
  %vec.sroa.0.0..sroa_idx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %vector, i64 %indvars.iv11, i32 0
  store i64 %vec.sroa.0.0, i64* %vec.sroa.0.0..sroa_idx, align 8
  %vec.sroa.5.0..sroa_idx2 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %vector, i64 %indvars.iv11, i32 1
  store float %vec.sroa.5.0, float* %vec.sroa.5.0..sroa_idx2, align 8
  %vec.sroa.8.0..sroa_idx3 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %vector, i64 %indvars.iv11, i32 2
  store i32 %vec.sroa.8.0, i32* %vec.sroa.8.0..sroa_idx3, align 4
  %vec.sroa.11.0..sroa_idx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %vector, i64 %indvars.iv11, i32 3
  %7 = bitcast i32* %vec.sroa.11.0..sroa_idx to i64*
  %8 = load i64, i64* %vec.sroa.11, align 8
  store i64 %8, i64* %7, align 8
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  br label %for.cond

for.end32:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ptb_qsort(%struct.ptb_vec_t* %numbers, i32 %array_size) unnamed_addr #0 {
entry:
  %sub = add i32 %array_size, -1
  call fastcc void @ptb_qsort_help(%struct.ptb_vec_t* %numbers, i32 0, i32 %sub)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @ptb_qsort_help(%struct.ptb_vec_t* %numbers, i32 %left, i32 %right) unnamed_addr #0 {
entry:
  %pivot_v = alloca %struct.ptb_vec_t, align 8
  %idxprom = zext i32 %left to i64
  %arrayidx = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %numbers, i64 %idxprom
  %0 = bitcast %struct.ptb_vec_t* %pivot_v to i8*
  %1 = bitcast %struct.ptb_vec_t* %arrayidx to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 24, i32 8, i1 false)
  br label %while.cond

while.cond:                                       ; preds = %if.then23, %while.end21, %entry
  %left.addr.0 = phi i32 [ %left, %entry ], [ %9, %while.end21 ], [ %9, %if.then23 ]
  %right.addr.0 = phi i32 [ %right, %entry ], [ %4, %while.end21 ], [ %dec28, %if.then23 ]
  %cmp = icmp ult i32 %left.addr.0, %right.addr.0
  br i1 %cmp, label %while.cond1.preheader, label %while.end30

while.cond1.preheader:                            ; preds = %while.cond
  %2 = zext i32 %right.addr.0 to i64
  %3 = zext i32 %left.addr.0 to i64
  br label %while.cond1

while.cond1:                                      ; preds = %while.cond1.preheader, %while.body5
  %indvars.iv = phi i64 [ %2, %while.cond1.preheader ], [ %indvars.iv.next, %while.body5 ]
  %arrayidx3 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %numbers, i64 %indvars.iv
  %call = call fastcc i32 @ptb_ge(%struct.ptb_vec_t* byval align 8 %arrayidx3, %struct.ptb_vec_t* byval nonnull align 8 %pivot_v)
  %tobool = icmp ne i32 %call, 0
  %cmp4 = icmp ult i64 %3, %indvars.iv
  %or.cond1 = and i1 %tobool, %cmp4
  br i1 %or.cond1, label %while.body5, label %while.end

while.body5:                                      ; preds = %while.cond1
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  br label %while.cond1

while.end:                                        ; preds = %while.cond1
  %4 = trunc i64 %indvars.iv to i32
  %cmp6 = icmp eq i32 %left.addr.0, %4
  br i1 %cmp6, label %while.cond11.preheader, label %if.then

if.then:                                          ; preds = %while.end
  %idxprom7 = zext i32 %left.addr.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %numbers, i64 %idxprom7
  %5 = bitcast %struct.ptb_vec_t* %arrayidx8 to i8*
  %6 = bitcast %struct.ptb_vec_t* %arrayidx3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 24, i32 8, i1 false)
  %inc = add i32 %left.addr.0, 1
  br label %while.cond11.preheader

while.cond11.preheader:                           ; preds = %while.end, %if.then
  %left.addr.2.ph = phi i32 [ %left.addr.0, %while.end ], [ %inc, %if.then ]
  %7 = zext i32 %left.addr.2.ph to i64
  %8 = and i64 %indvars.iv, 4294967295
  br label %while.cond11

while.cond11:                                     ; preds = %while.cond11.preheader, %while.body19
  %indvars.iv2 = phi i64 [ %7, %while.cond11.preheader ], [ %indvars.iv.next3, %while.body19 ]
  %arrayidx13 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %numbers, i64 %indvars.iv2
  %call14 = call fastcc i32 @ptb_ge(%struct.ptb_vec_t* byval nonnull align 8 %pivot_v, %struct.ptb_vec_t* byval align 8 %arrayidx13)
  %tobool15 = icmp ne i32 %call14, 0
  %cmp17 = icmp ult i64 %indvars.iv2, %8
  %or.cond = and i1 %tobool15, %cmp17
  br i1 %or.cond, label %while.body19, label %while.end21

while.body19:                                     ; preds = %while.cond11
  %indvars.iv.next3 = add nuw nsw i64 %indvars.iv2, 1
  br label %while.cond11

while.end21:                                      ; preds = %while.cond11
  %9 = trunc i64 %indvars.iv2 to i32
  %cmp22 = icmp eq i32 %9, %4
  br i1 %cmp22, label %while.cond, label %if.then23

if.then23:                                        ; preds = %while.end21
  %10 = bitcast %struct.ptb_vec_t* %arrayidx3 to i8*
  %11 = bitcast %struct.ptb_vec_t* %arrayidx13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 24, i32 8, i1 false)
  %dec28 = add i32 %4, -1
  br label %while.cond

while.end30:                                      ; preds = %while.cond
  %idxprom31 = zext i32 %left.addr.0 to i64
  %arrayidx32 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %numbers, i64 %idxprom31
  %12 = bitcast %struct.ptb_vec_t* %arrayidx32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %0, i64 24, i32 8, i1 false)
  %cmp33 = icmp ugt i32 %left.addr.0, %left
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %while.end30
  %sub = add i32 %left.addr.0, -1
  call fastcc void @ptb_qsort_help(%struct.ptb_vec_t* %numbers, i32 %left, i32 %sub)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %while.end30
  %cmp36 = icmp ult i32 %left.addr.0, %right
  br i1 %cmp36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end35
  %add = add i32 %left.addr.0, 1
  call fastcc void @ptb_qsort_help(%struct.ptb_vec_t* %numbers, i32 %add, i32 %right)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end35
  ret void
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @ptb_ge(%struct.ptb_vec_t* byval nocapture readonly align 8 %a, %struct.ptb_vec_t* byval nocapture readonly align 8 %b) unnamed_addr #6 {
entry:
  %key = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %a, i64 0, i32 1
  %0 = load float, float* %key, align 8
  %key1 = getelementptr inbounds %struct.ptb_vec_t, %struct.ptb_vec_t* %b, i64 0, i32 1
  %1 = load float, float* %key1, align 8
  %cmp = fcmp oge float %0, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @emd(%struct.signature_t* nocapture readonly %Signature1, %struct.signature_t* nocapture readonly %Signature2, float (i32, i8*, i8*, i8*)* nocapture %Dist, i32 %dim, i8* %param) unnamed_addr #0 {
entry:
  %emd_state = alloca %struct.emd_state_t, align 8
  %U = alloca [257 x %struct.emd_node1_t], align 16
  %V = alloca [257 x %struct.emd_node1_t], align 16
  %0 = load double**, double*** @C, align 8
  %cmp = icmp eq double** %0, null
  %1 = ptrtoint double** %0 to i64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call fastcc i8** @__matrix_alloc(i32 257, i32 257, i32 8)
  store i8** %call, i8*** bitcast (double*** @C to i8***), align 8
  %2 = ptrtoint i8** %call to i64
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = phi i64 [ %2, %if.then ], [ %1, %entry ]
  %4 = bitcast %struct.emd_state_t* %emd_state to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 86680, i32 8, i1 false)
  %C = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 2
  %5 = bitcast float*** %C to i64*
  store i64 %3, i64* %5, align 8
  %call1 = call fastcc float @emdinit(%struct.emd_state_t* nonnull %emd_state, %struct.signature_t* %Signature1, %struct.signature_t* %Signature2, float (i32, i8*, i8*, i8*)* %Dist, i32 %dim, i8* %param)
  %conv = fpext float %call1 to double
  %cmp2 = fcmp oeq double %conv, 1.000000e+20
  br i1 %cmp2, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 0
  %6 = load i32, i32* %n1, align 8
  %cmp6 = icmp sgt i32 %6, 1
  br i1 %cmp6, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end5
  %n2 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 1
  %7 = load i32, i32* %n2, align 4
  %cmp8 = icmp sgt i32 %7, 1
  br i1 %cmp8, label %for.cond.preheader, label %if.end24

for.cond.preheader:                               ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %U, i64 0, i64 0
  %arraydecay13 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %V, i64 0, i64 0
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %itr.0 = phi i32 [ %inc, %for.inc ], [ 1, %for.cond.preheader ]
  %cmp11 = icmp slt i32 %itr.0, 500
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call fastcc void @findBasicVariables(%struct.emd_state_t* nonnull %emd_state, %struct.emd_node1_t* %arraydecay, %struct.emd_node1_t* %arraydecay13)
  %call16 = call fastcc i32 @isOptimal(%struct.emd_state_t* nonnull %emd_state, %struct.emd_node1_t* %arraydecay, %struct.emd_node1_t* %arraydecay13)
  %tobool = icmp eq i32 %call16, 0
  br i1 %tobool, label %for.inc, label %if.end24

for.inc:                                          ; preds = %for.body
  call fastcc void @newSol(%struct.emd_state_t* nonnull %emd_state)
  %inc = add nuw nsw i32 %itr.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp19 = icmp eq i32 %itr.0, 500
  br i1 %cmp19, label %do.end, label %if.end24

do.end:                                           ; preds = %for.end
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @540, i32 0, i32 0))
  %call22 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %8, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.568, i64 0, i64 0), i32 500) #14
  br label %if.end24

if.end24:                                         ; preds = %for.body, %for.end, %do.end, %land.lhs.true, %if.end5
  %arraydecay25 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 3, i64 0
  %EndX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 4
  %9 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %EnterX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %emd_state, i64 0, i32 5
  %10 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %n = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature1, i64 0, i32 0
  %n36 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature2, i64 0, i32 0
  %11 = load float**, float*** %C, align 8
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc71, %if.end24
  %totalCost.0 = phi double [ 0.000000e+00, %if.end24 ], [ %totalCost.1, %for.inc71 ]
  %XP.0 = phi %struct.emd_node2_t* [ %arraydecay25, %if.end24 ], [ %incdec.ptr72, %for.inc71 ]
  %cmp27 = icmp ult %struct.emd_node2_t* %XP.0, %9
  br i1 %cmp27, label %for.body29, label %if.end78

for.body29:                                       ; preds = %for.cond26
  %cmp30 = icmp eq %struct.emd_node2_t* %XP.0, %10
  br i1 %cmp30, label %for.inc71, label %if.end33

if.end33:                                         ; preds = %for.body29
  %i = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %XP.0, i64 0, i32 0
  %12 = load i32, i32* %i, align 8
  %13 = load i32, i32* %n, align 8
  %cmp34 = icmp eq i32 %12, %13
  br i1 %cmp34, label %for.inc71, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end33
  %j = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %XP.0, i64 0, i32 1
  %14 = load i32, i32* %j, align 4
  %15 = load i32, i32* %n36, align 8
  %cmp37 = icmp eq i32 %14, %15
  br i1 %cmp37, label %for.inc71, label %if.end40

if.end40:                                         ; preds = %lor.lhs.false
  %val = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %XP.0, i64 0, i32 2
  %16 = load double, double* %val, align 8
  %cmp41 = fcmp oeq double %16, 0.000000e+00
  br i1 %cmp41, label %for.inc71, label %if.end70

if.end70:                                         ; preds = %if.end40
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds float*, float** %11, i64 %idxprom
  %17 = load float*, float** %arrayidx, align 8
  %idxprom49 = sext i32 %14 to i64
  %arrayidx50 = getelementptr inbounds float, float* %17, i64 %idxprom49
  %18 = load float, float* %arrayidx50, align 4
  %conv51 = fpext float %18 to double
  %mul = fmul double %16, %conv51
  %add = fadd double %totalCost.0, %mul
  br label %for.inc71

for.inc71:                                        ; preds = %if.end40, %if.end33, %lor.lhs.false, %for.body29, %if.end70
  %totalCost.1 = phi double [ %add, %if.end70 ], [ %totalCost.0, %for.body29 ], [ %totalCost.0, %lor.lhs.false ], [ %totalCost.0, %if.end33 ], [ %totalCost.0, %if.end40 ]
  %incdec.ptr72 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %XP.0, i64 1
  br label %for.cond26

if.end78:                                         ; preds = %for.cond26
  %div = fdiv double %totalCost.0, %conv
  %conv80 = fptrunc double %div to float
  br label %return

return:                                           ; preds = %if.end, %if.end78
  %retval.0 = phi float [ %conv80, %if.end78 ], [ 0x4415AF1D80000000, %if.end ]
  ret float %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @emdinit(%struct.emd_state_t* %state, %struct.signature_t* nocapture readonly %Signature1, %struct.signature_t* nocapture readonly %Signature2, float (i32, i8*, i8*, i8*)* nocapture %Dist, i32 %dim, i8* %param) unnamed_addr #0 {
entry:
  %S = alloca [257 x double], align 16
  %D = alloca [257 x double], align 16
  %n = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature1, i64 0, i32 0
  %0 = load i32, i32* %n, align 8
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 0
  store i32 %0, i32* %n1, align 8
  %n2 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature2, i64 0, i32 0
  %1 = load i32, i32* %n2, align 8
  %n23 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 1
  store i32 %1, i32* %n23, align 4
  %cmp = icmp sgt i32 %0, 256
  %cmp6 = icmp sgt i32 %1, 256
  %or.cond = or i1 %cmp, %cmp6
  br i1 %or.cond, label %do.end, label %if.end

do.end:                                           ; preds = %entry
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @541, i32 0, i32 0))
  %call = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.1.577, i64 0, i64 0), i32 256, i32 %0, i32 %1) #14
  br label %return

if.end:                                           ; preds = %entry
  %maxC = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 10
  store float 0.000000e+00, float* %maxC, align 8
  %Features = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature1, i64 0, i32 1
  %Features15 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature2, i64 0, i32 1
  %C = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc38, %if.end
  %indvars.iv18 = phi i64 [ %indvars.iv.next19, %for.inc38 ], [ 0, %if.end ]
  %3 = phi i32 [ %6, %for.inc38 ], [ %1, %if.end ]
  %4 = phi i32 [ %.pre, %for.inc38 ], [ %0, %if.end ]
  %5 = sext i32 %4 to i64
  %cmp10 = icmp slt i64 %indvars.iv18, %5
  br i1 %cmp10, label %for.cond11, label %for.cond41.preheader

for.cond41.preheader:                             ; preds = %for.cond
  %Weights = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature1, i64 0, i32 2
  br label %for.cond41

for.cond11:                                       ; preds = %for.cond, %for.inc
  %indvars.iv16 = phi i64 [ %indvars.iv.next17, %for.inc ], [ 0, %for.cond ]
  %6 = phi i32 [ %.pre3, %for.inc ], [ %3, %for.cond ]
  %7 = sext i32 %6 to i64
  %cmp13 = icmp slt i64 %indvars.iv16, %7
  br i1 %cmp13, label %for.body14, label %for.inc38

for.body14:                                       ; preds = %for.cond11
  %8 = load i8**, i8*** %Features, align 8
  %arrayidx = getelementptr inbounds i8*, i8** %8, i64 %indvars.iv18
  %9 = load i8*, i8** %arrayidx, align 8
  %10 = load i8**, i8*** %Features15, align 8
  %arrayidx17 = getelementptr inbounds i8*, i8** %10, i64 %indvars.iv16
  %11 = load i8*, i8** %arrayidx17, align 8
  %call18 = call float %Dist(i32 %dim, i8* %9, i8* %11, i8* %param) #11
  %12 = load float**, float*** %C, align 8
  %arrayidx20 = getelementptr inbounds float*, float** %12, i64 %indvars.iv18
  %13 = load float*, float** %arrayidx20, align 8
  %arrayidx22 = getelementptr inbounds float, float* %13, i64 %indvars.iv16
  store float %call18, float* %arrayidx22, align 4
  %14 = load float**, float*** %C, align 8
  %arrayidx25 = getelementptr inbounds float*, float** %14, i64 %indvars.iv18
  %15 = load float*, float** %arrayidx25, align 8
  %arrayidx27 = getelementptr inbounds float, float* %15, i64 %indvars.iv16
  %16 = load float, float* %arrayidx27, align 4
  %17 = load float, float* %maxC, align 8
  %cmp29 = fcmp ogt float %16, %17
  br i1 %cmp29, label %if.then30, label %for.inc

if.then30:                                        ; preds = %for.body14
  store float %16, float* %maxC, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body14, %if.then30
  %indvars.iv.next17 = add nuw i64 %indvars.iv16, 1
  %.pre3 = load i32, i32* %n23, align 4
  br label %for.cond11

for.inc38:                                        ; preds = %for.cond11
  %indvars.iv.next19 = add nuw i64 %indvars.iv18, 1
  %.pre = load i32, i32* %n1, align 8
  br label %for.cond

for.cond41:                                       ; preds = %for.cond41.preheader, %for.inc55
  %indvars.iv14 = phi i64 [ 0, %for.cond41.preheader ], [ %indvars.iv.next15, %for.inc55 ]
  %18 = phi i32 [ %4, %for.cond41.preheader ], [ %.pre1, %for.inc55 ]
  %sSum.0 = phi double [ 0.000000e+00, %for.cond41.preheader ], [ %add, %for.inc55 ]
  %19 = sext i32 %18 to i64
  %cmp43 = icmp slt i64 %indvars.iv14, %19
  br i1 %cmp43, label %for.inc55, label %for.cond58.preheader

for.cond58.preheader:                             ; preds = %for.cond41
  %Weights63 = getelementptr inbounds %struct.signature_t, %struct.signature_t* %Signature2, i64 0, i32 2
  br label %for.cond58

for.inc55:                                        ; preds = %for.cond41
  %20 = load float*, float** %Weights, align 8
  %arrayidx46 = getelementptr inbounds float, float* %20, i64 %indvars.iv14
  %21 = load float, float* %arrayidx46, align 4
  %conv = fpext float %21 to double
  %arrayidx48 = getelementptr inbounds [257 x double], [257 x double]* %S, i64 0, i64 %indvars.iv14
  store double %conv, double* %arrayidx48, align 8
  %arrayidx54 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %indvars.iv14
  store %struct.emd_node2_t* null, %struct.emd_node2_t** %arrayidx54, align 8
  %add = fadd double %sSum.0, %conv
  %indvars.iv.next15 = add nuw i64 %indvars.iv14, 1
  %.pre1 = load i32, i32* %n1, align 8
  br label %for.cond41

for.cond58:                                       ; preds = %for.cond58.preheader, %for.inc76
  %indvars.iv12 = phi i64 [ 0, %for.cond58.preheader ], [ %indvars.iv.next13, %for.inc76 ]
  %dSum.0 = phi double [ 0.000000e+00, %for.cond58.preheader ], [ %add73, %for.inc76 ]
  %22 = load i32, i32* %n23, align 4
  %23 = sext i32 %22 to i64
  %cmp60 = icmp slt i64 %indvars.iv12, %23
  br i1 %cmp60, label %for.inc76, label %for.end78

for.inc76:                                        ; preds = %for.cond58
  %24 = load float*, float** %Weights63, align 8
  %arrayidx65 = getelementptr inbounds float, float* %24, i64 %indvars.iv12
  %25 = load float, float* %arrayidx65, align 4
  %conv66 = fpext float %25 to double
  %arrayidx68 = getelementptr inbounds [257 x double], [257 x double]* %D, i64 0, i64 %indvars.iv12
  store double %conv66, double* %arrayidx68, align 8
  %arrayidx75 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %indvars.iv12
  store %struct.emd_node2_t* null, %struct.emd_node2_t** %arrayidx75, align 8
  %add73 = fadd double %dSum.0, %conv66
  %indvars.iv.next13 = add nuw i64 %indvars.iv12, 1
  br label %for.cond58

for.end78:                                        ; preds = %for.cond58
  %sub = fsub double %sSum.0, %dSum.0
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @542, i32 0, i32 0))
  %call79 = call double @fabs(double %sub) #12
  %mul = fmul double %sSum.0, 1.000000e-06
  %cmp80 = fcmp ult double %call79, %mul
  br i1 %cmp80, label %for.cond135, label %if.then82

if.then82:                                        ; preds = %for.end78
  %cmp83 = fcmp olt double %sub, 0.000000e+00
  br i1 %cmp83, label %for.cond86, label %for.cond110

for.cond86:                                       ; preds = %if.then82, %for.inc97
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc97 ], [ 0, %if.then82 ]
  %26 = phi i32 [ %.pre2, %for.inc97 ], [ %22, %if.then82 ]
  %27 = sext i32 %26 to i64
  %cmp88 = icmp slt i64 %indvars.iv8, %27
  br i1 %cmp88, label %for.inc97, label %for.end99

for.inc97:                                        ; preds = %for.cond86
  %28 = load float**, float*** %C, align 8
  %29 = load i32, i32* %n1, align 8
  %idxprom93 = sext i32 %29 to i64
  %arrayidx94 = getelementptr inbounds float*, float** %28, i64 %idxprom93
  %30 = load float*, float** %arrayidx94, align 8
  %arrayidx96 = getelementptr inbounds float, float* %30, i64 %indvars.iv8
  store float 0.000000e+00, float* %arrayidx96, align 4
  %indvars.iv.next9 = add nuw i64 %indvars.iv8, 1
  %.pre2 = load i32, i32* %n23, align 4
  br label %for.cond86

for.end99:                                        ; preds = %for.cond86
  %sub100 = fsub double -0.000000e+00, %sub
  %31 = load i32, i32* %n1, align 8
  %idxprom102 = sext i32 %31 to i64
  %arrayidx103 = getelementptr inbounds [257 x double], [257 x double]* %S, i64 0, i64 %idxprom102
  store double %sub100, double* %arrayidx103, align 8
  %arrayidx107 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %idxprom102
  store %struct.emd_node2_t* null, %struct.emd_node2_t** %arrayidx107, align 8
  %32 = load i32, i32* %n1, align 8
  %inc109 = add nsw i32 %32, 1
  store i32 %inc109, i32* %n1, align 8
  br label %for.cond135

for.cond110:                                      ; preds = %if.then82, %for.inc121
  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %for.inc121 ], [ 0, %if.then82 ]
  %33 = load i32, i32* %n1, align 8
  %34 = sext i32 %33 to i64
  %cmp112 = icmp slt i64 %indvars.iv10, %34
  br i1 %cmp112, label %for.inc121, label %for.end123

for.inc121:                                       ; preds = %for.cond110
  %35 = load float**, float*** %C, align 8
  %arrayidx117 = getelementptr inbounds float*, float** %35, i64 %indvars.iv10
  %36 = load float*, float** %arrayidx117, align 8
  %37 = load i32, i32* %n23, align 4
  %idxprom119 = sext i32 %37 to i64
  %arrayidx120 = getelementptr inbounds float, float* %36, i64 %idxprom119
  store float 0.000000e+00, float* %arrayidx120, align 4
  %indvars.iv.next11 = add nuw i64 %indvars.iv10, 1
  br label %for.cond110

for.end123:                                       ; preds = %for.cond110
  %38 = load i32, i32* %n23, align 4
  %idxprom125 = sext i32 %38 to i64
  %arrayidx126 = getelementptr inbounds [257 x double], [257 x double]* %D, i64 0, i64 %idxprom125
  store double %sub, double* %arrayidx126, align 8
  %arrayidx130 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %idxprom125
  store %struct.emd_node2_t* null, %struct.emd_node2_t** %arrayidx130, align 8
  %39 = load i32, i32* %n23, align 4
  %inc132 = add nsw i32 %39, 1
  store i32 %inc132, i32* %n23, align 4
  br label %for.cond135

for.cond135:                                      ; preds = %for.end78, %for.end123, %for.end99, %for.inc152
  %indvars.iv6 = phi i64 [ %indvars.iv.next7, %for.inc152 ], [ 0, %for.end99 ], [ 0, %for.end123 ], [ 0, %for.end78 ]
  %40 = load i32, i32* %n1, align 8
  %41 = sext i32 %40 to i64
  %cmp137 = icmp slt i64 %indvars.iv6, %41
  br i1 %cmp137, label %for.cond140, label %for.end154

for.cond140:                                      ; preds = %for.cond135, %for.inc149
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc149 ], [ 0, %for.cond135 ]
  %42 = load i32, i32* %n23, align 4
  %43 = sext i32 %42 to i64
  %cmp142 = icmp slt i64 %indvars.iv, %43
  br i1 %cmp142, label %for.inc149, label %for.inc152

for.inc149:                                       ; preds = %for.cond140
  %arrayidx148 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %indvars.iv6, i64 %indvars.iv
  store i8 0, i8* %arrayidx148, align 1
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond140

for.inc152:                                       ; preds = %for.cond140
  %indvars.iv.next7 = add nuw i64 %indvars.iv6, 1
  br label %for.cond135

for.end154:                                       ; preds = %for.cond135
  %arraydecay = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 3, i64 0
  %EndX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 4
  store %struct.emd_node2_t* %arraydecay, %struct.emd_node2_t** %EndX, align 8
  %cmp155 = fcmp ogt double %sSum.0, %dSum.0
  %cond = select i1 %cmp155, double %sSum.0, double %dSum.0
  %maxW = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 9
  store double %cond, double* %maxW, align 8
  %arraydecay157 = getelementptr inbounds [257 x double], [257 x double]* %S, i64 0, i64 0
  %arraydecay158 = getelementptr inbounds [257 x double], [257 x double]* %D, i64 0, i64 0
  call fastcc void @russel(%struct.emd_state_t* %state, double* %arraydecay157, double* %arraydecay158)
  %44 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %incdec.ptr = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %44, i64 1
  store %struct.emd_node2_t* %incdec.ptr, %struct.emd_node2_t** %EndX, align 8
  %EnterX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 5
  store %struct.emd_node2_t* %44, %struct.emd_node2_t** %EnterX, align 8
  %cond165 = select i1 %cmp155, double %dSum.0, double %sSum.0
  %conv166 = fptrunc double %cond165 to float
  br label %return

return:                                           ; preds = %for.end154, %do.end
  %retval.0 = phi float [ 0x4415AF1D80000000, %do.end ], [ %conv166, %for.end154 ]
  ret float %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @findBasicVariables(%struct.emd_state_t* nocapture readonly %state, %struct.emd_node1_t* %U, %struct.emd_node1_t* %V) unnamed_addr #0 {
entry:
  %u0Head = alloca %struct.emd_node1_t, align 8
  %v0Head = alloca %struct.emd_node1_t, align 8
  %Next = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %u0Head, i64 0, i32 2
  store %struct.emd_node1_t* %U, %struct.emd_node1_t** %Next, align 8
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %CurU.0 = phi %struct.emd_node1_t* [ %U, %entry ], [ %add.ptr, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %0 = load i32, i32* %n1, align 8
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %i1 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 0, i32 0
  store i32 %i.0, i32* %i1, align 8
  %add.ptr = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 1
  %Next2 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 0, i32 2
  store %struct.emd_node1_t* %add.ptr, %struct.emd_node1_t** %Next2, align 8
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %Next4 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 -1, i32 2
  store %struct.emd_node1_t* null, %struct.emd_node1_t** %Next4, align 8
  %n2 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 1
  %1 = load i32, i32* %n2, align 4
  %cmp7 = icmp sgt i32 %1, 1
  %add.ptr8 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V, i64 1
  %add.ptr8. = select i1 %cmp7, %struct.emd_node1_t* %add.ptr8, %struct.emd_node1_t* null
  %Next9 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %v0Head, i64 0, i32 2
  store %struct.emd_node1_t* %add.ptr8., %struct.emd_node1_t** %Next9, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc18, %for.end
  %2 = phi i32 [ %1, %for.end ], [ %.pre, %for.inc18 ]
  %j.0 = phi i32 [ 1, %for.end ], [ %inc19, %for.inc18 ]
  %V.pn = phi %struct.emd_node1_t* [ %V, %for.end ], [ %CurV.0, %for.inc18 ]
  %CurV.0 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V.pn, i64 1
  %cmp12 = icmp slt i32 %j.0, %2
  br i1 %cmp12, label %for.inc18, label %for.end20

for.inc18:                                        ; preds = %for.cond10
  %i14 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 0, i32 0
  store i32 %j.0, i32* %i14, align 8
  %add.ptr15 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V.pn, i64 2
  %Next16 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V.pn, i64 1, i32 2
  store %struct.emd_node1_t* %add.ptr15, %struct.emd_node1_t** %Next16, align 8
  %inc19 = add nuw nsw i32 %j.0, 1
  %.pre = load i32, i32* %n2, align 4
  br label %for.cond10

for.end20:                                        ; preds = %for.cond10
  %Next22 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V.pn, i64 0, i32 2
  store %struct.emd_node1_t* null, %struct.emd_node1_t** %Next22, align 8
  %i24 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V, i64 0, i32 0
  store i32 0, i32* %i24, align 8
  %val = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V, i64 0, i32 1
  %3 = ptrtoint %struct.emd_node1_t* %V to i64
  %C = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 2
  %4 = bitcast double* %val to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 16, i32 8, i1 false)
  br label %while.cond

while.cond:                                       ; preds = %if.end132, %for.end20
  %u1Head.sroa.0.0 = phi i64 [ 0, %for.end20 ], [ %u1Head.sroa.0.6, %if.end132 ]
  %v1Head.sroa.0.0 = phi i64 [ %3, %for.end20 ], [ %v1Head.sroa.0.6, %if.end132 ]
  %VfoundNum.0 = phi i32 [ 0, %for.end20 ], [ %VfoundNum.2, %if.end132 ]
  %UfoundNum.0 = phi i32 [ 0, %for.end20 ], [ %UfoundNum.2, %if.end132 ]
  %5 = load i32, i32* %n1, align 8
  %cmp30 = icmp slt i32 %UfoundNum.0, %5
  %.pre5 = load i32, i32* %n2, align 4
  %cmp32 = icmp slt i32 %VfoundNum.0, %.pre5
  %or.cond = or i1 %cmp30, %cmp32
  br i1 %or.cond, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %cmp34 = icmp slt i32 %VfoundNum.0, %.pre5
  br i1 %cmp34, label %for.cond36, label %if.end76

for.cond36:                                       ; preds = %while.body, %for.inc73
  %u1Head.sroa.0.1 = phi i64 [ %u1Head.sroa.0.2, %for.inc73 ], [ %u1Head.sroa.0.0, %while.body ]
  %v1Head.sroa.0.1 = phi i64 [ %21, %for.inc73 ], [ %v1Head.sroa.0.0, %while.body ]
  %VfoundNum.1 = phi i32 [ %inc72, %for.inc73 ], [ %VfoundNum.0, %while.body ]
  %found.0 = phi i32 [ 1, %for.inc73 ], [ 0, %while.body ]
  %CurV.1 = inttoptr i64 %v1Head.sroa.0.1 to %struct.emd_node1_t*
  %cmp37 = icmp eq i64 %v1Head.sroa.0.1, 0
  br i1 %cmp37, label %if.end76.loopexit, label %for.body38

for.body38:                                       ; preds = %for.cond36
  %i39 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.1, i64 0, i32 0
  %6 = load i32, i32* %i39, align 8
  %7 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next, align 8
  %idxprom46 = sext i32 %6 to i64
  %val53 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.1, i64 0, i32 1
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc67, %for.body38
  %u1Head.sroa.0.2 = phi i64 [ %u1Head.sroa.0.1, %for.body38 ], [ %u1Head.sroa.0.3, %for.inc67 ]
  %CurU.1 = phi %struct.emd_node1_t* [ %7, %for.body38 ], [ %19, %for.inc67 ]
  %PrevU.0 = phi %struct.emd_node1_t* [ %u0Head, %for.body38 ], [ %CurU.2, %for.inc67 ]
  %cmp42 = icmp eq %struct.emd_node1_t* %CurU.1, null
  br i1 %cmp42, label %for.inc73, label %for.body43

for.body43:                                       ; preds = %for.cond41
  %i44 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.1, i64 0, i32 0
  %8 = load i32, i32* %i44, align 8
  %idxprom = sext i32 %8 to i64
  %arrayidx47 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %idxprom, i64 %idxprom46
  %9 = load i8, i8* %arrayidx47, align 1
  %tobool = icmp eq i8 %9, 0
  br i1 %tobool, label %for.inc67, label %if.then48

if.then48:                                        ; preds = %for.body43
  %10 = load float**, float*** %C, align 8
  %arrayidx50 = getelementptr inbounds float*, float** %10, i64 %idxprom
  %11 = load float*, float** %arrayidx50, align 8
  %arrayidx52 = getelementptr inbounds float, float* %11, i64 %idxprom46
  %12 = load float, float* %arrayidx52, align 4
  %conv = fpext float %12 to double
  %13 = load double, double* %val53, align 8
  %sub = fsub double %conv, %13
  %val54 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.1, i64 0, i32 1
  store double %sub, double* %val54, align 8
  %Next55 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.1, i64 0, i32 2
  %14 = bitcast %struct.emd_node1_t** %Next55 to i64*
  %15 = load i64, i64* %14, align 8
  %Next56 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %PrevU.0, i64 0, i32 2
  %16 = bitcast %struct.emd_node1_t** %Next56 to i64*
  store i64 %15, i64* %16, align 8
  %17 = inttoptr i64 %u1Head.sroa.0.2 to %struct.emd_node1_t*
  store %struct.emd_node1_t* %17, %struct.emd_node1_t** %Next55, align 8
  %18 = ptrtoint %struct.emd_node1_t* %CurU.1 to i64
  br label %for.inc67

for.inc67:                                        ; preds = %if.then48, %for.body43
  %u1Head.sroa.0.3 = phi i64 [ %u1Head.sroa.0.2, %for.body43 ], [ %18, %if.then48 ]
  %CurU.2 = phi %struct.emd_node1_t* [ %CurU.1, %for.body43 ], [ %PrevU.0, %if.then48 ]
  %Next68 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.2, i64 0, i32 2
  %19 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next68, align 8
  br label %for.cond41

for.inc73:                                        ; preds = %for.cond41
  %Next70 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.1, i64 0, i32 2
  %20 = bitcast %struct.emd_node1_t** %Next70 to i64*
  %21 = load i64, i64* %20, align 8
  %inc72 = add nsw i32 %VfoundNum.1, 1
  br label %for.cond36

if.end76.loopexit:                                ; preds = %for.cond36
  %.pre6 = load i32, i32* %n1, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.end76.loopexit, %while.body
  %22 = phi i32 [ %5, %while.body ], [ %.pre6, %if.end76.loopexit ]
  %u1Head.sroa.0.4 = phi i64 [ %u1Head.sroa.0.0, %while.body ], [ %u1Head.sroa.0.1, %if.end76.loopexit ]
  %v1Head.sroa.0.2 = phi i64 [ %v1Head.sroa.0.0, %while.body ], [ %v1Head.sroa.0.1, %if.end76.loopexit ]
  %VfoundNum.2 = phi i32 [ %VfoundNum.0, %while.body ], [ %VfoundNum.1, %if.end76.loopexit ]
  %found.1 = phi i32 [ 0, %while.body ], [ %found.0, %if.end76.loopexit ]
  %cmp78 = icmp slt i32 %UfoundNum.0, %22
  br i1 %cmp78, label %for.cond82, label %if.end132

for.cond82:                                       ; preds = %if.end76, %for.inc129
  %u1Head.sroa.0.5 = phi i64 [ %38, %for.inc129 ], [ %u1Head.sroa.0.4, %if.end76 ]
  %v1Head.sroa.0.3 = phi i64 [ %v1Head.sroa.0.4, %for.inc129 ], [ %v1Head.sroa.0.2, %if.end76 ]
  %UfoundNum.1 = phi i32 [ %inc128, %for.inc129 ], [ %UfoundNum.0, %if.end76 ]
  %found.2 = phi i32 [ 1, %for.inc129 ], [ %found.1, %if.end76 ]
  %CurU.3 = inttoptr i64 %u1Head.sroa.0.5 to %struct.emd_node1_t*
  %cmp83 = icmp eq i64 %u1Head.sroa.0.5, 0
  br i1 %cmp83, label %if.end132, label %for.body85

for.body85:                                       ; preds = %for.cond82
  %i86 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.3, i64 0, i32 0
  %23 = load i32, i32* %i86, align 8
  %24 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next9, align 8
  %idxprom94 = sext i32 %23 to i64
  %val106 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.3, i64 0, i32 1
  br label %for.cond88

for.cond88:                                       ; preds = %for.inc123, %for.body85
  %v1Head.sroa.0.4 = phi i64 [ %v1Head.sroa.0.3, %for.body85 ], [ %v1Head.sroa.0.5, %for.inc123 ]
  %CurV.2 = phi %struct.emd_node1_t* [ %24, %for.body85 ], [ %36, %for.inc123 ]
  %PrevV.0 = phi %struct.emd_node1_t* [ %v0Head, %for.body85 ], [ %CurV.3, %for.inc123 ]
  %cmp89 = icmp eq %struct.emd_node1_t* %CurV.2, null
  br i1 %cmp89, label %for.inc129, label %for.body91

for.body91:                                       ; preds = %for.cond88
  %i92 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 0
  %25 = load i32, i32* %i92, align 8
  %idxprom96 = sext i32 %25 to i64
  %arrayidx97 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %idxprom94, i64 %idxprom96
  %26 = load i8, i8* %arrayidx97, align 1
  %tobool98 = icmp eq i8 %26, 0
  br i1 %tobool98, label %for.inc123, label %if.then99

if.then99:                                        ; preds = %for.body91
  %27 = load float**, float*** %C, align 8
  %arrayidx102 = getelementptr inbounds float*, float** %27, i64 %idxprom94
  %28 = load float*, float** %arrayidx102, align 8
  %arrayidx104 = getelementptr inbounds float, float* %28, i64 %idxprom96
  %29 = load float, float* %arrayidx104, align 4
  %conv105 = fpext float %29 to double
  %30 = load double, double* %val106, align 8
  %sub107 = fsub double %conv105, %30
  %val108 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 1
  store double %sub107, double* %val108, align 8
  %Next109 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 2
  %31 = bitcast %struct.emd_node1_t** %Next109 to i64*
  %32 = load i64, i64* %31, align 8
  %Next110 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %PrevV.0, i64 0, i32 2
  %33 = bitcast %struct.emd_node1_t** %Next110 to i64*
  store i64 %32, i64* %33, align 8
  %34 = inttoptr i64 %v1Head.sroa.0.4 to %struct.emd_node1_t*
  store %struct.emd_node1_t* %34, %struct.emd_node1_t** %Next109, align 8
  %35 = ptrtoint %struct.emd_node1_t* %CurV.2 to i64
  br label %for.inc123

for.inc123:                                       ; preds = %if.then99, %for.body91
  %v1Head.sroa.0.5 = phi i64 [ %v1Head.sroa.0.4, %for.body91 ], [ %35, %if.then99 ]
  %CurV.3 = phi %struct.emd_node1_t* [ %CurV.2, %for.body91 ], [ %PrevV.0, %if.then99 ]
  %Next124 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.3, i64 0, i32 2
  %36 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next124, align 8
  br label %for.cond88

for.inc129:                                       ; preds = %for.cond88
  %Next126 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.3, i64 0, i32 2
  %37 = bitcast %struct.emd_node1_t** %Next126 to i64*
  %38 = load i64, i64* %37, align 8
  %inc128 = add nsw i32 %UfoundNum.1, 1
  br label %for.cond82

if.end132:                                        ; preds = %for.cond82, %if.end76
  %u1Head.sroa.0.6 = phi i64 [ %u1Head.sroa.0.4, %if.end76 ], [ %u1Head.sroa.0.5, %for.cond82 ]
  %v1Head.sroa.0.6 = phi i64 [ %v1Head.sroa.0.2, %if.end76 ], [ %v1Head.sroa.0.3, %for.cond82 ]
  %UfoundNum.2 = phi i32 [ %UfoundNum.0, %if.end76 ], [ %UfoundNum.1, %for.cond82 ]
  %found.3 = phi i32 [ %found.1, %if.end76 ], [ %found.2, %for.cond82 ]
  %tobool133 = icmp eq i32 %found.3, 0
  br i1 %tobool133, label %do.body141, label %while.cond

do.body141:                                       ; preds = %if.end132
  %39 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @543, i32 0, i32 0))
  %40 = call i64 @fwrite(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.2.573, i64 0, i64 0), i64 45, i64 1, %struct._IO_FILE* %39) #14
  %41 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @544, i32 0, i32 0))
  %42 = call i64 @fwrite(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.3.574, i64 0, i64 0), i64 51, i64 1, %struct._IO_FILE* %41) #14
  %43 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @545, i32 0, i32 0))
  %44 = call i64 @fwrite(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.4.575, i64 0, i64 0), i64 49, i64 1, %struct._IO_FILE* %43) #14
  %45 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @546, i32 0, i32 0))
  %46 = call i64 @fwrite(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.5.576, i64 0, i64 0), i64 31, i64 1, %struct._IO_FILE* %45) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @547, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @isOptimal(%struct.emd_state_t* nocapture readonly %state, %struct.emd_node1_t* nocapture readonly %U, %struct.emd_node1_t* nocapture readonly %V) unnamed_addr #0 {
entry:
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 0
  %0 = load i32, i32* %n1, align 8
  %n2 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 1
  %C = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 2
  %1 = sext i32 %0 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc20, %entry
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc20 ], [ 0, %entry ]
  %deltaMin.0 = phi double [ %deltaMin.1, %for.inc20 ], [ 1.000000e+20, %entry ]
  %minI.0 = phi i32 [ %minI.1, %for.inc20 ], [ 0, %entry ]
  %minJ.0 = phi i32 [ %minJ.1, %for.inc20 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv1, %1
  br i1 %cmp, label %for.cond1.preheader, label %for.end22

for.cond1.preheader:                              ; preds = %for.cond
  %2 = load i32, i32* %n2, align 4
  %val = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %U, i64 %indvars.iv1, i32 1
  %3 = sext i32 %2 to i64
  %4 = trunc i64 %indvars.iv1 to i32
  br label %for.cond1

for.cond1:                                        ; preds = %for.cond1.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]
  %deltaMin.1 = phi double [ %deltaMin.0, %for.cond1.preheader ], [ %deltaMin.3, %for.inc ]
  %minI.1 = phi i32 [ %minI.0, %for.cond1.preheader ], [ %minI.3, %for.inc ]
  %minJ.1 = phi i32 [ %minJ.0, %for.cond1.preheader ], [ %minJ.3, %for.inc ]
  %cmp2 = icmp slt i64 %indvars.iv, %3
  br i1 %cmp2, label %for.body3, label %for.inc20

for.body3:                                        ; preds = %for.cond1
  %arrayidx5 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %indvars.iv1, i64 %indvars.iv
  %5 = load i8, i8* %arrayidx5, align 1
  %tobool = icmp eq i8 %5, 0
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body3
  %6 = load float**, float*** %C, align 8
  %arrayidx7 = getelementptr inbounds float*, float** %6, i64 %indvars.iv1
  %7 = load float*, float** %arrayidx7, align 8
  %arrayidx9 = getelementptr inbounds float, float* %7, i64 %indvars.iv
  %8 = load float, float* %arrayidx9, align 4
  %conv = fpext float %8 to double
  %9 = load double, double* %val, align 8
  %sub = fsub double %conv, %9
  %val14 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %V, i64 %indvars.iv, i32 1
  %10 = load double, double* %val14, align 8
  %sub15 = fsub double %sub, %10
  %cmp16 = fcmp ogt double %deltaMin.1, %sub15
  br i1 %cmp16, label %if.then18, label %for.inc

if.then18:                                        ; preds = %if.then
  %11 = trunc i64 %indvars.iv to i32
  br label %for.inc

for.inc:                                          ; preds = %for.body3, %if.then18, %if.then
  %deltaMin.3 = phi double [ %deltaMin.1, %for.body3 ], [ %sub15, %if.then18 ], [ %deltaMin.1, %if.then ]
  %minI.3 = phi i32 [ %minI.1, %for.body3 ], [ %4, %if.then18 ], [ %minI.1, %if.then ]
  %minJ.3 = phi i32 [ %minJ.1, %for.body3 ], [ %11, %if.then18 ], [ %minJ.1, %if.then ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond1

for.inc20:                                        ; preds = %for.cond1
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond

for.end22:                                        ; preds = %for.cond
  %cmp23 = fcmp oeq double %deltaMin.0, 1.000000e+20
  br i1 %cmp23, label %do.body26, label %if.end29

do.body26:                                        ; preds = %for.end22
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @548, i32 0, i32 0))
  %13 = call i64 @fwrite(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.6.571, i64 0, i64 0), i64 36, i64 1, %struct._IO_FILE* %12) #14
  %14 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @549, i32 0, i32 0))
  %15 = call i64 @fwrite(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.7.572, i64 0, i64 0), i64 23, i64 1, %struct._IO_FILE* %14) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @550, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end29:                                         ; preds = %for.end22
  %EnterX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 5
  %16 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %i30 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %16, i64 0, i32 0
  store i32 %minI.0, i32* %i30, align 8
  %17 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %j32 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %17, i64 0, i32 1
  store i32 %minJ.0, i32* %j32, align 4
  %maxC = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 10
  %18 = load float, float* %maxC, align 8
  %conv33 = fpext float %18 to double
  %mul = fmul double %conv33, -1.000000e-06
  %cmp34 = fcmp oge double %deltaMin.0, %mul
  %conv35 = zext i1 %cmp34 to i32
  ret i32 %conv35
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @newSol(%struct.emd_state_t* %state) unnamed_addr #0 {
entry:
  %Loop = alloca [514 x %struct.emd_node2_t*], align 16
  %EnterX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 5
  %0 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %i1 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %0, i64 0, i32 0
  %1 = load i32, i32* %i1, align 8
  %j3 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %0, i64 0, i32 1
  %2 = load i32, i32* %j3, align 4
  %idxprom = sext i32 %1 to i64
  %idxprom4 = sext i32 %2 to i64
  %arrayidx5 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %idxprom, i64 %idxprom4
  store i8 1, i8* %arrayidx5, align 1
  %arrayidx7 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %idxprom
  %3 = bitcast %struct.emd_node2_t** %arrayidx7 to i64*
  %4 = load i64, i64* %3, align 8
  %5 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %NextC = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %5, i64 0, i32 3
  %6 = bitcast %struct.emd_node2_t** %NextC to i64*
  store i64 %4, i64* %6, align 8
  %arrayidx10 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %idxprom4
  %7 = bitcast %struct.emd_node2_t** %arrayidx10 to i64*
  %8 = load i64, i64* %7, align 8
  %9 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %NextR = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %9, i64 0, i32 4
  %10 = bitcast %struct.emd_node2_t** %NextR to i64*
  store i64 %8, i64* %10, align 8
  %11 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %val = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %11, i64 0, i32 2
  store double 0.000000e+00, double* %val, align 8
  %12 = bitcast %struct.emd_node2_t** %EnterX to i64*
  %13 = load i64, i64* %12, align 8
  store i64 %13, i64* %3, align 8
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %7, align 8
  %arraydecay = getelementptr inbounds [514 x %struct.emd_node2_t*], [514 x %struct.emd_node2_t*]* %Loop, i64 0, i64 0
  %call = call fastcc i32 @findLoop(%struct.emd_state_t* %state, %struct.emd_node2_t** %arraydecay)
  %15 = sext i32 %call to i64
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %for.body ], [ 1, %entry ]
  %xMin.0 = phi double [ %xMin.1, %for.body ], [ 1.000000e+20, %entry ]
  %LeaveX.0 = phi %struct.emd_node2_t* [ %LeaveX.1, %for.body ], [ null, %entry ]
  %cmp = icmp slt i64 %indvars.iv9, %15
  br i1 %cmp, label %for.body, label %for.cond30.preheader

for.cond30.preheader:                             ; preds = %for.cond
  %16 = sext i32 %call to i64
  br label %for.cond30

for.body:                                         ; preds = %for.cond
  %arrayidx22 = getelementptr inbounds [514 x %struct.emd_node2_t*], [514 x %struct.emd_node2_t*]* %Loop, i64 0, i64 %indvars.iv9
  %17 = load %struct.emd_node2_t*, %struct.emd_node2_t** %arrayidx22, align 8
  %val23 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %17, i64 0, i32 2
  %18 = load double, double* %val23, align 8
  %cmp24 = fcmp olt double %18, %xMin.0
  %xMin.1 = select i1 %cmp24, double %18, double %xMin.0
  %LeaveX.1 = select i1 %cmp24, %struct.emd_node2_t* %17, %struct.emd_node2_t* %LeaveX.0
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 2
  br label %for.cond

for.cond30:                                       ; preds = %for.cond30.preheader, %for.inc41
  %indvars.iv = phi i64 [ 0, %for.cond30.preheader ], [ %indvars.iv.next, %for.inc41 ]
  %cmp31 = icmp slt i64 %indvars.iv, %16
  br i1 %cmp31, label %for.inc41, label %for.end43

for.inc41:                                        ; preds = %for.cond30
  %arrayidx34 = getelementptr inbounds [514 x %struct.emd_node2_t*], [514 x %struct.emd_node2_t*]* %Loop, i64 0, i64 %indvars.iv
  %19 = load %struct.emd_node2_t*, %struct.emd_node2_t** %arrayidx34, align 16
  %val35 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %19, i64 0, i32 2
  %20 = load double, double* %val35, align 8
  %add36 = fadd double %20, %xMin.0
  store double %add36, double* %val35, align 8
  %21 = or i64 %indvars.iv, 1
  %arrayidx39 = getelementptr inbounds [514 x %struct.emd_node2_t*], [514 x %struct.emd_node2_t*]* %Loop, i64 0, i64 %21
  %22 = load %struct.emd_node2_t*, %struct.emd_node2_t** %arrayidx39, align 8
  %val40 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %22, i64 0, i32 2
  %23 = load double, double* %val40, align 8
  %sub = fsub double %23, %xMin.0
  store double %sub, double* %val40, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 2
  br label %for.cond30

for.end43:                                        ; preds = %for.cond30
  %i44 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %LeaveX.0, i64 0, i32 0
  %24 = load i32, i32* %i44, align 8
  %j45 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %LeaveX.0, i64 0, i32 1
  %25 = load i32, i32* %j45, align 4
  %idxprom47 = sext i32 %24 to i64
  %idxprom49 = sext i32 %25 to i64
  %arrayidx50 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %idxprom47, i64 %idxprom49
  store i8 0, i8* %arrayidx50, align 1
  %arrayidx53 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %idxprom47
  %26 = load %struct.emd_node2_t*, %struct.emd_node2_t** %arrayidx53, align 8
  %cmp54 = icmp eq %struct.emd_node2_t* %26, %LeaveX.0
  br i1 %cmp54, label %if.end76.sink.split, label %for.cond63

for.cond63:                                       ; preds = %for.body65, %for.end43
  %CurX.0 = phi %struct.emd_node2_t* [ %26, %for.end43 ], [ %27, %for.body65 ]
  %cmp64 = icmp eq %struct.emd_node2_t* %CurX.0, null
  br i1 %cmp64, label %if.end76, label %for.body65

for.body65:                                       ; preds = %for.cond63
  %NextC66 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %CurX.0, i64 0, i32 3
  %27 = load %struct.emd_node2_t*, %struct.emd_node2_t** %NextC66, align 8
  %cmp67 = icmp eq %struct.emd_node2_t* %27, %LeaveX.0
  br i1 %cmp67, label %if.end76.sink.split, label %for.cond63

if.end76.sink.split:                              ; preds = %for.end43, %for.body65
  %NextC66.sink = phi %struct.emd_node2_t** [ %NextC66, %for.body65 ], [ %arrayidx53, %for.end43 ]
  %NextC70 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %LeaveX.0, i64 0, i32 3
  %28 = bitcast %struct.emd_node2_t** %NextC70 to i64*
  %29 = load i64, i64* %28, align 8
  %30 = bitcast %struct.emd_node2_t** %NextC66.sink to i64*
  store i64 %29, i64* %30, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.end76.sink.split, %for.cond63
  %arrayidx79 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %idxprom49
  %31 = load %struct.emd_node2_t*, %struct.emd_node2_t** %arrayidx79, align 8
  %cmp80 = icmp eq %struct.emd_node2_t* %31, %LeaveX.0
  br i1 %cmp80, label %if.end103.sink.split, label %for.cond90

for.cond90:                                       ; preds = %for.body92, %if.end76
  %CurX.1 = phi %struct.emd_node2_t* [ %31, %if.end76 ], [ %32, %for.body92 ]
  %cmp91 = icmp eq %struct.emd_node2_t* %CurX.1, null
  br i1 %cmp91, label %if.end103, label %for.body92

for.body92:                                       ; preds = %for.cond90
  %NextR93 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %CurX.1, i64 0, i32 4
  %32 = load %struct.emd_node2_t*, %struct.emd_node2_t** %NextR93, align 8
  %cmp94 = icmp eq %struct.emd_node2_t* %32, %LeaveX.0
  br i1 %cmp94, label %if.end103.sink.split, label %for.cond90

if.end103.sink.split:                             ; preds = %if.end76, %for.body92
  %NextR93.sink = phi %struct.emd_node2_t** [ %NextR93, %for.body92 ], [ %arrayidx79, %if.end76 ]
  %NextR97 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %LeaveX.0, i64 0, i32 4
  %33 = bitcast %struct.emd_node2_t** %NextR97 to i64*
  %34 = load i64, i64* %33, align 8
  %35 = bitcast %struct.emd_node2_t** %NextR93.sink to i64*
  store i64 %34, i64* %35, align 8
  br label %if.end103

if.end103:                                        ; preds = %if.end103.sink.split, %for.cond90
  store %struct.emd_node2_t* %LeaveX.0, %struct.emd_node2_t** %EnterX, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @findLoop(%struct.emd_state_t* %state, %struct.emd_node2_t** %Loop) unnamed_addr #0 {
entry:
  %IsUsed = alloca [514 x i8], align 16
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 0
  %0 = load i32, i32* %n1, align 8
  %n2 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 1
  %1 = load i32, i32* %n2, align 4
  %add = add nsw i32 %0, %1
  %2 = sext i32 %add to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv, %2
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %indvars.iv
  store i8 0, i8* %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %EnterX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 5
  %3 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  store %struct.emd_node2_t* %3, %struct.emd_node2_t** %Loop, align 8
  %4 = bitcast %struct.emd_node2_t** %EnterX to i64*
  %5 = load i64, i64* %4, align 8
  %arraydecay = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 3, i64 0
  %sub.ptr.rhs.cast = ptrtoint %struct.emd_node2_t* %arraydecay to i64
  %sub.ptr.sub = sub i64 %5, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 5
  %arrayidx2 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div
  store i8 1, i8* %arrayidx2, align 1
  br label %do.body

do.body:                                          ; preds = %do.cond111, %for.end
  %steps.0 = phi i32 [ 1, %for.end ], [ %steps.3, %do.cond111 ]
  %CurX.0 = phi %struct.emd_node2_t** [ %Loop, %for.end ], [ %CurX.3, %do.cond111 ]
  %NewX.0 = phi %struct.emd_node2_t* [ %3, %for.end ], [ %NewX.6, %do.cond111 ]
  %rem = srem i32 %steps.0, 2
  %cmp3 = icmp eq i32 %rem, 1
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %i4 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.0, i64 0, i32 0
  %6 = load i32, i32* %i4, align 8
  %idxprom5 = sext i32 %6 to i64
  %arrayidx6 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %idxprom5
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %NewX.1.in = phi %struct.emd_node2_t** [ %arrayidx6, %if.then ], [ %NextC, %while.body ]
  %NewX.1 = load %struct.emd_node2_t*, %struct.emd_node2_t** %NewX.1.in, align 8
  %cmp7 = icmp eq %struct.emd_node2_t* %NewX.1, null
  br i1 %cmp7, label %do.body53, label %land.end

land.end:                                         ; preds = %while.cond
  %sub.ptr.lhs.cast10 = ptrtoint %struct.emd_node2_t* %NewX.1 to i64
  %sub.ptr.sub12 = sub i64 %sub.ptr.lhs.cast10, %sub.ptr.rhs.cast
  %sub.ptr.div13 = ashr exact i64 %sub.ptr.sub12, 5
  %arrayidx14 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div13
  %7 = load i8, i8* %arrayidx14, align 1
  %tobool = icmp eq i8 %7, 0
  br i1 %tobool, label %if.then43, label %while.body

while.body:                                       ; preds = %land.end
  %NextC = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.1, i64 0, i32 3
  br label %while.cond

if.else:                                          ; preds = %do.body
  %j = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.0, i64 0, i32 1
  %8 = load i32, i32* %j, align 4
  %idxprom15 = sext i32 %8 to i64
  %arrayidx16 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %idxprom15
  br label %while.cond17

while.cond17:                                     ; preds = %while.body34, %if.else
  %NewX.2.in = phi %struct.emd_node2_t** [ %arrayidx16, %if.else ], [ %NextR, %while.body34 ]
  %NewX.2 = load %struct.emd_node2_t*, %struct.emd_node2_t** %NewX.2.in, align 8
  %cmp18 = icmp eq %struct.emd_node2_t* %NewX.2, null
  br i1 %cmp18, label %while.end35, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.cond17
  %sub.ptr.lhs.cast22 = ptrtoint %struct.emd_node2_t* %NewX.2 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast
  %sub.ptr.div25 = ashr exact i64 %sub.ptr.sub24, 5
  %arrayidx26 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div25
  %9 = load i8, i8* %arrayidx26, align 1
  %tobool28 = icmp eq i8 %9, 0
  br i1 %tobool28, label %while.end35, label %land.end33

land.end33:                                       ; preds = %land.lhs.true
  %10 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %cmp31 = icmp eq %struct.emd_node2_t* %NewX.2, %10
  br i1 %cmp31, label %while.end35, label %while.body34

while.body34:                                     ; preds = %land.end33
  %NextR = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.2, i64 0, i32 4
  br label %while.cond17

while.end35:                                      ; preds = %land.end33, %while.cond17, %land.lhs.true
  %NewX.2.lcssa = phi %struct.emd_node2_t* [ null, %while.cond17 ], [ %NewX.2, %land.lhs.true ], [ %NewX.2, %land.end33 ]
  %11 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EnterX, align 8
  %cmp37 = icmp eq %struct.emd_node2_t* %NewX.2.lcssa, %11
  br i1 %cmp37, label %do.end114, label %if.end40

if.end40:                                         ; preds = %while.end35
  %cmp41 = icmp eq %struct.emd_node2_t* %NewX.2.lcssa, null
  br i1 %cmp41, label %do.body53, label %if.then43

if.then43:                                        ; preds = %land.end, %if.end40
  %NewX.34 = phi %struct.emd_node2_t* [ %NewX.2.lcssa, %if.end40 ], [ %NewX.1, %land.end ]
  %incdec.ptr = getelementptr inbounds %struct.emd_node2_t*, %struct.emd_node2_t** %CurX.0, i64 1
  store %struct.emd_node2_t* %NewX.34, %struct.emd_node2_t** %incdec.ptr, align 8
  %sub.ptr.lhs.cast46 = ptrtoint %struct.emd_node2_t* %NewX.34 to i64
  %sub.ptr.sub48 = sub i64 %sub.ptr.lhs.cast46, %sub.ptr.rhs.cast
  %sub.ptr.div49 = ashr exact i64 %sub.ptr.sub48, 5
  %arrayidx50 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div49
  store i8 1, i8* %arrayidx50, align 1
  %inc51 = add nsw i32 %steps.0, 1
  br label %do.cond111

do.body53:                                        ; preds = %if.end40, %while.cond, %land.end94
  %steps.1 = phi i32 [ %dec, %land.end94 ], [ %steps.0, %while.cond ], [ %steps.0, %if.end40 ]
  %CurX.1 = phi %struct.emd_node2_t** [ %incdec.ptr86, %land.end94 ], [ %CurX.0, %while.cond ], [ %CurX.0, %if.end40 ]
  %12 = load %struct.emd_node2_t*, %struct.emd_node2_t** %CurX.1, align 8
  %rem55 = srem i32 %steps.1, 2
  %cmp56 = icmp eq i32 %rem55, 1
  %13 = ptrtoint %struct.emd_node2_t* %12 to i64
  br label %do.body54

do.body54:                                        ; preds = %land.end75, %do.body53
  %NewX.4 = phi %struct.emd_node2_t* [ %12, %do.body53 ], [ %NewX.5, %land.end75 ]
  %NextR59 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.4, i64 0, i32 4
  %NextC61 = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %NewX.4, i64 0, i32 3
  %NewX.5.in = select i1 %cmp56, %struct.emd_node2_t** %NextR59, %struct.emd_node2_t** %NextC61
  %NewX.5 = load %struct.emd_node2_t*, %struct.emd_node2_t** %NewX.5.in, align 8
  %cmp63 = icmp eq %struct.emd_node2_t* %NewX.5, null
  br i1 %cmp63, label %land.end94, label %land.end75

land.end75:                                       ; preds = %do.body54
  %sub.ptr.lhs.cast68 = ptrtoint %struct.emd_node2_t* %NewX.5 to i64
  %sub.ptr.sub70 = sub i64 %sub.ptr.lhs.cast68, %sub.ptr.rhs.cast
  %sub.ptr.div71 = ashr exact i64 %sub.ptr.sub70, 5
  %arrayidx72 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div71
  %14 = load i8, i8* %arrayidx72, align 1
  %tobool74 = icmp eq i8 %14, 0
  br i1 %tobool74, label %do.end95, label %do.body54

land.end94:                                       ; preds = %do.body54
  %sub.ptr.sub83 = sub i64 %13, %sub.ptr.rhs.cast
  %sub.ptr.div84 = ashr exact i64 %sub.ptr.sub83, 5
  %arrayidx85 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div84
  store i8 0, i8* %arrayidx85, align 1
  %incdec.ptr86 = getelementptr inbounds %struct.emd_node2_t*, %struct.emd_node2_t** %CurX.1, i64 -1
  %dec = add nsw i32 %steps.1, -1
  %cmp92 = icmp ult %struct.emd_node2_t** %incdec.ptr86, %Loop
  br i1 %cmp92, label %do.end95.loopexit13, label %do.body53

do.end95.loopexit13:                              ; preds = %land.end94
  %.phi.trans.insert = bitcast %struct.emd_node2_t** %incdec.ptr86 to i64*
  %.pre = load i64, i64* %.phi.trans.insert, align 8
  br label %do.end95

do.end95:                                         ; preds = %land.end75, %do.end95.loopexit13
  %15 = phi i64 [ %.pre, %do.end95.loopexit13 ], [ %13, %land.end75 ]
  %NewX.516 = phi %struct.emd_node2_t* [ null, %do.end95.loopexit13 ], [ %NewX.5, %land.end75 ]
  %steps.2712 = phi i32 [ %dec, %do.end95.loopexit13 ], [ %steps.1, %land.end75 ]
  %CurX.21011 = phi %struct.emd_node2_t** [ %incdec.ptr86, %do.end95.loopexit13 ], [ %CurX.1, %land.end75 ]
  %sub.ptr.sub100 = sub i64 %15, %sub.ptr.rhs.cast
  %sub.ptr.div101 = ashr exact i64 %sub.ptr.sub100, 5
  %arrayidx102 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div101
  store i8 0, i8* %arrayidx102, align 1
  store %struct.emd_node2_t* %NewX.516, %struct.emd_node2_t** %CurX.21011, align 8
  %sub.ptr.lhs.cast105 = ptrtoint %struct.emd_node2_t* %NewX.516 to i64
  %sub.ptr.sub107 = sub i64 %sub.ptr.lhs.cast105, %sub.ptr.rhs.cast
  %sub.ptr.div108 = ashr exact i64 %sub.ptr.sub107, 5
  %arrayidx109 = getelementptr inbounds [514 x i8], [514 x i8]* %IsUsed, i64 0, i64 %sub.ptr.div108
  store i8 1, i8* %arrayidx109, align 1
  br label %do.cond111

do.cond111:                                       ; preds = %if.then43, %do.end95
  %steps.3 = phi i32 [ %inc51, %if.then43 ], [ %steps.2712, %do.end95 ]
  %CurX.3 = phi %struct.emd_node2_t** [ %incdec.ptr, %if.then43 ], [ %CurX.21011, %do.end95 ]
  %NewX.6 = phi %struct.emd_node2_t* [ %NewX.34, %if.then43 ], [ %NewX.516, %do.end95 ]
  %cmp112 = icmp ult %struct.emd_node2_t** %CurX.3, %Loop
  br i1 %cmp112, label %do.end114, label %do.body

do.end114:                                        ; preds = %while.end35, %do.cond111
  %steps.4 = phi i32 [ %steps.3, %do.cond111 ], [ %steps.0, %while.end35 ]
  %CurX.4 = phi %struct.emd_node2_t** [ %CurX.3, %do.cond111 ], [ %CurX.0, %while.end35 ]
  %cmp115 = icmp eq %struct.emd_node2_t** %CurX.4, %Loop
  br i1 %cmp115, label %do.body121, label %if.end125

do.body121:                                       ; preds = %do.end114
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @551, i32 0, i32 0))
  %17 = call i64 @fwrite(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.8.569, i64 0, i64 0), i64 35, i64 1, %struct._IO_FILE* %16) #14
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @552, i32 0, i32 0))
  %19 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.9.570, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %18) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @553, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end125:                                        ; preds = %do.end114
  ret i32 %steps.4
}

; Function Attrs: nounwind readnone
declare double @fabs(double) local_unnamed_addr #13

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @russel(%struct.emd_state_t* nocapture %state, double* nocapture %S, double* nocapture %D) unnamed_addr #0 {
entry:
  %Delta = alloca [257 x [257 x double]], align 16
  %Ur = alloca [257 x %struct.emd_node1_t], align 16
  %Vr = alloca [257 x %struct.emd_node1_t], align 16
  %uHead = alloca %struct.emd_node1_t, align 8
  %vHead = alloca %struct.emd_node1_t, align 8
  %arraydecay = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Ur, i64 0, i64 0
  %Next = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %uHead, i64 0, i32 2
  store %struct.emd_node1_t* %arraydecay, %struct.emd_node1_t** %Next, align 8
  %n1 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %CurU.0 = phi %struct.emd_node1_t* [ %arraydecay, %entry ], [ %add.ptr, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %0 = load i32, i32* %n1, align 8
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %i1 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 0, i32 0
  store i32 %i.0, i32* %i1, align 8
  %val = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 0, i32 1
  store double -1.000000e+20, double* %val, align 8
  %add.ptr = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 1
  %Next2 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 0, i32 2
  store %struct.emd_node1_t* %add.ptr, %struct.emd_node1_t** %Next2, align 8
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %Next4 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.0, i64 -1, i32 2
  store %struct.emd_node1_t* null, %struct.emd_node1_t** %Next4, align 8
  %arraydecay5 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Vr, i64 0, i64 0
  %Next6 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %vHead, i64 0, i32 2
  store %struct.emd_node1_t* %arraydecay5, %struct.emd_node1_t** %Next6, align 8
  %n2 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 1
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc15, %for.end
  %CurV.0 = phi %struct.emd_node1_t* [ %arraydecay5, %for.end ], [ %add.ptr12, %for.inc15 ]
  %j.0 = phi i32 [ 0, %for.end ], [ %inc16, %for.inc15 ]
  %1 = load i32, i32* %n2, align 4
  %cmp8 = icmp slt i32 %j.0, %1
  br i1 %cmp8, label %for.inc15, label %for.end17

for.inc15:                                        ; preds = %for.cond7
  %i10 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 0, i32 0
  store i32 %j.0, i32* %i10, align 8
  %val11 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 0, i32 1
  store double -1.000000e+20, double* %val11, align 8
  %add.ptr12 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 1
  %Next13 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 0, i32 2
  store %struct.emd_node1_t* %add.ptr12, %struct.emd_node1_t** %Next13, align 8
  %inc16 = add nuw nsw i32 %j.0, 1
  br label %for.cond7

for.end17:                                        ; preds = %for.cond7
  %Next19 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.0, i64 -1, i32 2
  store %struct.emd_node1_t* null, %struct.emd_node1_t** %Next19, align 8
  %C = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 2
  %.pre = load i32, i32* %n1, align 8
  %2 = sext i32 %.pre to i64
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc54, %for.end17
  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %for.inc54 ], [ 0, %for.end17 ]
  %cmp22 = icmp slt i64 %indvars.iv9, %2
  br i1 %cmp22, label %for.cond24.preheader, label %for.cond57.preheader

for.cond24.preheader:                             ; preds = %for.cond20
  %val32 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Ur, i64 0, i64 %indvars.iv9, i32 1
  %.pre3 = load i32, i32* %n2, align 4
  %3 = sext i32 %.pre3 to i64
  br label %for.cond24

for.cond57.preheader:                             ; preds = %for.cond20
  %4 = sext i32 %.pre to i64
  br label %for.cond57

for.cond24:                                       ; preds = %for.cond24.preheader, %for.inc51
  %indvars.iv7 = phi i64 [ 0, %for.cond24.preheader ], [ %indvars.iv.next8, %for.inc51 ]
  %cmp26 = icmp slt i64 %indvars.iv7, %3
  br i1 %cmp26, label %for.body27, label %for.inc54

for.body27:                                       ; preds = %for.cond24
  %5 = load float**, float*** %C, align 8
  %arrayidx = getelementptr inbounds float*, float** %5, i64 %indvars.iv9
  %6 = load float*, float** %arrayidx, align 8
  %arrayidx29 = getelementptr inbounds float, float* %6, i64 %indvars.iv7
  %7 = load float, float* %arrayidx29, align 4
  %8 = load double, double* %val32, align 8
  %conv = fpext float %7 to double
  %cmp33 = fcmp ugt double %8, %conv
  br i1 %cmp33, label %if.end, label %if.then

if.then:                                          ; preds = %for.body27
  store double %conv, double* %val32, align 8
  br label %if.end

if.end:                                           ; preds = %for.body27, %if.then
  %val41 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Vr, i64 0, i64 %indvars.iv7, i32 1
  %9 = load double, double* %val41, align 8
  %cmp43 = fcmp ugt double %9, %conv
  br i1 %cmp43, label %for.inc51, label %if.then45

if.then45:                                        ; preds = %if.end
  store double %conv, double* %val41, align 8
  br label %for.inc51

for.inc51:                                        ; preds = %if.then45, %if.end
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  br label %for.cond24

for.inc54:                                        ; preds = %for.cond24
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  br label %for.cond20

for.cond57:                                       ; preds = %for.cond57.preheader, %for.inc87
  %indvars.iv5 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next6, %for.inc87 ]
  %cmp59 = icmp slt i64 %indvars.iv5, %4
  br i1 %cmp59, label %for.cond62.preheader, label %do.body.preheader

for.cond62.preheader:                             ; preds = %for.cond57
  %10 = load i32, i32* %n2, align 4
  %val75 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Ur, i64 0, i64 %indvars.iv5, i32 1
  %11 = sext i32 %10 to i64
  br label %for.cond62

do.body.preheader:                                ; preds = %for.cond57
  %maxC = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 10
  %.pre2 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next, align 8
  br label %do.body

for.cond62:                                       ; preds = %for.cond62.preheader, %for.inc84
  %indvars.iv = phi i64 [ 0, %for.cond62.preheader ], [ %indvars.iv.next, %for.inc84 ]
  %cmp64 = icmp slt i64 %indvars.iv, %11
  br i1 %cmp64, label %for.inc84, label %for.inc87

for.inc84:                                        ; preds = %for.cond62
  %12 = load float**, float*** %C, align 8
  %arrayidx69 = getelementptr inbounds float*, float** %12, i64 %indvars.iv5
  %13 = load float*, float** %arrayidx69, align 8
  %arrayidx71 = getelementptr inbounds float, float* %13, i64 %indvars.iv
  %14 = load float, float* %arrayidx71, align 4
  %conv72 = fpext float %14 to double
  %15 = load double, double* %val75, align 8
  %sub = fsub double %conv72, %15
  %val78 = getelementptr inbounds [257 x %struct.emd_node1_t], [257 x %struct.emd_node1_t]* %Vr, i64 0, i64 %indvars.iv, i32 1
  %16 = load double, double* %val78, align 8
  %sub79 = fsub double %sub, %16
  %arrayidx83 = getelementptr inbounds [257 x [257 x double]], [257 x [257 x double]]* %Delta, i64 0, i64 %indvars.iv5, i64 %indvars.iv
  store double %sub79, double* %arrayidx83, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond62

for.inc87:                                        ; preds = %for.cond62
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  br label %for.cond57

do.body:                                          ; preds = %do.cond, %do.body.preheader
  %17 = phi %struct.emd_node1_t* [ %.pre2, %do.body.preheader ], [ %67, %do.cond ]
  %PrevUMinI.0 = phi %struct.emd_node1_t* [ null, %do.body.preheader ], [ %PrevUMinI.1, %do.cond ]
  %PrevVMinJ.0 = phi %struct.emd_node1_t* [ null, %do.body.preheader ], [ %PrevVMinJ.1, %do.cond ]
  %tobool = icmp eq %struct.emd_node1_t* %17, null
  br i1 %tobool, label %cond.end, label %cond.true

cond.true:                                        ; preds = %do.body
  %i92 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %17, i64 0, i32 0
  %18 = load i32, i32* %i92, align 8
  br label %cond.end

cond.end:                                         ; preds = %do.body, %cond.true
  %cond = phi i32 [ %18, %cond.true ], [ 0, %do.body ]
  %19 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next6, align 8
  %tobool94 = icmp eq %struct.emd_node1_t* %19, null
  br i1 %tobool94, label %for.cond102, label %cond.true95

cond.true95:                                      ; preds = %cond.end
  %i97 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %19, i64 0, i32 0
  %20 = load i32, i32* %i97, align 8
  br label %for.cond102

for.cond102:                                      ; preds = %cond.true95, %cond.end, %for.inc130
  %PrevU.0 = phi %struct.emd_node1_t* [ %CurU.1, %for.inc130 ], [ %uHead, %cond.end ], [ %uHead, %cond.true95 ]
  %CurU.1 = phi %struct.emd_node1_t* [ %25, %for.inc130 ], [ %17, %cond.end ], [ %17, %cond.true95 ]
  %deltaMin.0 = phi double [ %deltaMin.1, %for.inc130 ], [ 1.000000e+20, %cond.end ], [ 1.000000e+20, %cond.true95 ]
  %minJ.0 = phi i32 [ %minJ.1, %for.inc130 ], [ 0, %cond.end ], [ %20, %cond.true95 ]
  %minI.0 = phi i32 [ %minI.1, %for.inc130 ], [ %cond, %cond.end ], [ %cond, %cond.true95 ]
  %found.0 = phi i32 [ %found.1, %for.inc130 ], [ 0, %cond.end ], [ 0, %cond.true95 ]
  %PrevUMinI.1 = phi %struct.emd_node1_t* [ %PrevUMinI.2, %for.inc130 ], [ %PrevUMinI.0, %cond.end ], [ %PrevUMinI.0, %cond.true95 ]
  %PrevVMinJ.1 = phi %struct.emd_node1_t* [ %PrevVMinJ.2, %for.inc130 ], [ %PrevVMinJ.0, %cond.end ], [ %PrevVMinJ.0, %cond.true95 ]
  %cmp103 = icmp eq %struct.emd_node1_t* %CurU.1, null
  br i1 %cmp103, label %for.end132, label %for.body105

for.body105:                                      ; preds = %for.cond102
  %i107 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.1, i64 0, i32 0
  %21 = load i32, i32* %i107, align 8
  %idxprom115 = sext i32 %21 to i64
  br label %for.cond109

for.cond109:                                      ; preds = %for.inc127, %for.body105
  %CurV.1 = phi %struct.emd_node1_t* [ %19, %for.body105 ], [ %24, %for.inc127 ]
  %deltaMin.1 = phi double [ %deltaMin.0, %for.body105 ], [ %deltaMin.2, %for.inc127 ]
  %minJ.1 = phi i32 [ %minJ.0, %for.body105 ], [ %minJ.2, %for.inc127 ]
  %minI.1 = phi i32 [ %minI.0, %for.body105 ], [ %minI.2, %for.inc127 ]
  %found.1 = phi i32 [ %found.0, %for.body105 ], [ %found.2, %for.inc127 ]
  %PrevV.0 = phi %struct.emd_node1_t* [ %vHead, %for.body105 ], [ %CurV.1, %for.inc127 ]
  %PrevUMinI.2 = phi %struct.emd_node1_t* [ %PrevUMinI.1, %for.body105 ], [ %PrevUMinI.3, %for.inc127 ]
  %PrevVMinJ.2 = phi %struct.emd_node1_t* [ %PrevVMinJ.1, %for.body105 ], [ %PrevVMinJ.3, %for.inc127 ]
  %cmp110 = icmp eq %struct.emd_node1_t* %CurV.1, null
  br i1 %cmp110, label %for.inc130, label %for.body112

for.body112:                                      ; preds = %for.cond109
  %i114 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.1, i64 0, i32 0
  %22 = load i32, i32* %i114, align 8
  %idxprom117 = sext i32 %22 to i64
  %arrayidx118 = getelementptr inbounds [257 x [257 x double]], [257 x [257 x double]]* %Delta, i64 0, i64 %idxprom115, i64 %idxprom117
  %23 = load double, double* %arrayidx118, align 8
  %cmp119 = fcmp ogt double %deltaMin.1, %23
  br i1 %cmp119, label %if.then121, label %for.inc127

if.then121:                                       ; preds = %for.body112
  br label %for.inc127

for.inc127:                                       ; preds = %for.body112, %if.then121
  %deltaMin.2 = phi double [ %23, %if.then121 ], [ %deltaMin.1, %for.body112 ]
  %minJ.2 = phi i32 [ %22, %if.then121 ], [ %minJ.1, %for.body112 ]
  %minI.2 = phi i32 [ %21, %if.then121 ], [ %minI.1, %for.body112 ]
  %found.2 = phi i32 [ 1, %if.then121 ], [ %found.1, %for.body112 ]
  %PrevUMinI.3 = phi %struct.emd_node1_t* [ %PrevU.0, %if.then121 ], [ %PrevUMinI.2, %for.body112 ]
  %PrevVMinJ.3 = phi %struct.emd_node1_t* [ %PrevV.0, %if.then121 ], [ %PrevVMinJ.2, %for.body112 ]
  %Next128 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.1, i64 0, i32 2
  %24 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next128, align 8
  br label %for.cond109

for.inc130:                                       ; preds = %for.cond109
  %Next131 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.1, i64 0, i32 2
  %25 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next131, align 8
  br label %for.cond102

for.end132:                                       ; preds = %for.cond102
  %tobool133 = icmp eq i32 %found.0, 0
  br i1 %tobool133, label %do.end, label %if.end135

if.end135:                                        ; preds = %for.end132
  %Next136 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %PrevUMinI.1, i64 0, i32 2
  %26 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next136, align 8
  call fastcc void @addBasicVariable(%struct.emd_state_t* %state, i32 %minI.0, i32 %minJ.0, double* %S, double* %D, %struct.emd_node1_t* %PrevUMinI.1, %struct.emd_node1_t* %PrevVMinJ.1, %struct.emd_node1_t* nonnull %uHead)
  %27 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next136, align 8
  %cmp138 = icmp eq %struct.emd_node1_t* %26, %27
  br i1 %cmp138, label %if.then140, label %if.else

if.then140:                                       ; preds = %if.end135
  %28 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next6, align 8
  %idxprom150 = sext i32 %minI.0 to i64
  %29 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next, align 8
  br label %for.cond142

for.cond142:                                      ; preds = %for.inc209, %if.then140
  %CurV.2 = phi %struct.emd_node1_t* [ %28, %if.then140 ], [ %46, %for.inc209 ]
  %cmp143 = icmp eq %struct.emd_node1_t* %CurV.2, null
  br i1 %cmp143, label %do.cond, label %for.body145

for.body145:                                      ; preds = %for.cond142
  %i147 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 0
  %30 = load i32, i32* %i147, align 8
  %val148 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 1
  %31 = load double, double* %val148, align 8
  %32 = load float**, float*** %C, align 8
  %arrayidx151 = getelementptr inbounds float*, float** %32, i64 %idxprom150
  %33 = load float*, float** %arrayidx151, align 8
  %idxprom152 = sext i32 %30 to i64
  %arrayidx153 = getelementptr inbounds float, float* %33, i64 %idxprom152
  %34 = load float, float* %arrayidx153, align 4
  %conv154 = fpext float %34 to double
  %cmp155 = fcmp oeq double %31, %conv154
  br i1 %cmp155, label %if.then157, label %for.inc209

if.then157:                                       ; preds = %for.body145
  store double -1.000000e+20, double* %val148, align 8
  br label %for.cond161

for.cond161:                                      ; preds = %for.inc185, %if.then157
  %35 = phi double [ -1.000000e+20, %if.then157 ], [ %40, %for.inc185 ]
  %CurU.2 = phi %struct.emd_node1_t* [ %29, %if.then157 ], [ %41, %for.inc185 ]
  %cmp162 = icmp eq %struct.emd_node1_t* %CurU.2, null
  br i1 %cmp162, label %for.end187, label %for.body164

for.body164:                                      ; preds = %for.cond161
  %i166 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.2, i64 0, i32 0
  %36 = load i32, i32* %i166, align 8
  %37 = load float**, float*** %C, align 8
  %idxprom169 = sext i32 %36 to i64
  %arrayidx170 = getelementptr inbounds float*, float** %37, i64 %idxprom169
  %38 = load float*, float** %arrayidx170, align 8
  %arrayidx172 = getelementptr inbounds float, float* %38, i64 %idxprom152
  %39 = load float, float* %arrayidx172, align 4
  %conv173 = fpext float %39 to double
  %cmp174 = fcmp ugt double %35, %conv173
  br i1 %cmp174, label %for.inc185, label %if.then176

if.then176:                                       ; preds = %for.body164
  store double %conv173, double* %val148, align 8
  br label %for.inc185

for.inc185:                                       ; preds = %if.then176, %for.body164
  %40 = phi double [ %conv173, %if.then176 ], [ %35, %for.body164 ]
  %Next186 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.2, i64 0, i32 2
  %41 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next186, align 8
  br label %for.cond161

for.end187:                                       ; preds = %for.cond161
  %sub189 = fsub double %31, %35
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @554, i32 0, i32 0))
  %call = call double @fabs(double %sub189) #12
  %42 = load float, float* %maxC, align 8
  %conv190 = fpext float %42 to double
  %mul = fmul double %conv190, 1.000000e-06
  %cmp191 = fcmp olt double %call, %mul
  br i1 %cmp191, label %for.cond195, label %for.inc209

for.cond195:                                      ; preds = %for.end187, %for.inc204
  %CurU.3 = phi %struct.emd_node1_t* [ %45, %for.inc204 ], [ %29, %for.end187 ]
  %cmp196 = icmp eq %struct.emd_node1_t* %CurU.3, null
  br i1 %cmp196, label %for.inc209, label %for.inc204

for.inc204:                                       ; preds = %for.cond195
  %i199 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.3, i64 0, i32 0
  %43 = load i32, i32* %i199, align 8
  %idxprom200 = sext i32 %43 to i64
  %arrayidx203 = getelementptr inbounds [257 x [257 x double]], [257 x [257 x double]]* %Delta, i64 0, i64 %idxprom200, i64 %idxprom152
  %44 = load double, double* %arrayidx203, align 8
  %add = fadd double %44, %sub189
  store double %add, double* %arrayidx203, align 8
  %Next205 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.3, i64 0, i32 2
  %45 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next205, align 8
  br label %for.cond195

for.inc209:                                       ; preds = %for.cond195, %for.body145, %for.end187
  %Next210 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.2, i64 0, i32 2
  %46 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next210, align 8
  br label %for.cond142

if.else:                                          ; preds = %if.end135
  %47 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next, align 8
  %idxprom223 = sext i32 %minJ.0 to i64
  %48 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next6, align 8
  br label %for.cond213

for.cond213:                                      ; preds = %for.inc284, %if.else
  %CurU.4 = phi %struct.emd_node1_t* [ %47, %if.else ], [ %65, %for.inc284 ]
  %cmp214 = icmp eq %struct.emd_node1_t* %CurU.4, null
  br i1 %cmp214, label %do.cond, label %for.body216

for.body216:                                      ; preds = %for.cond213
  %i218 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.4, i64 0, i32 0
  %49 = load i32, i32* %i218, align 8
  %val219 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.4, i64 0, i32 1
  %50 = load double, double* %val219, align 8
  %51 = load float**, float*** %C, align 8
  %idxprom221 = sext i32 %49 to i64
  %arrayidx222 = getelementptr inbounds float*, float** %51, i64 %idxprom221
  %52 = load float*, float** %arrayidx222, align 8
  %arrayidx224 = getelementptr inbounds float, float* %52, i64 %idxprom223
  %53 = load float, float* %arrayidx224, align 4
  %conv225 = fpext float %53 to double
  %cmp226 = fcmp oeq double %50, %conv225
  br i1 %cmp226, label %if.then228, label %for.inc284

if.then228:                                       ; preds = %for.body216
  store double -1.000000e+20, double* %val219, align 8
  br label %for.cond232

for.cond232:                                      ; preds = %for.inc256, %if.then228
  %54 = phi double [ -1.000000e+20, %if.then228 ], [ %59, %for.inc256 ]
  %CurV.3 = phi %struct.emd_node1_t* [ %48, %if.then228 ], [ %60, %for.inc256 ]
  %cmp233 = icmp eq %struct.emd_node1_t* %CurV.3, null
  br i1 %cmp233, label %for.end258, label %for.body235

for.body235:                                      ; preds = %for.cond232
  %i237 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.3, i64 0, i32 0
  %55 = load i32, i32* %i237, align 8
  %56 = load float**, float*** %C, align 8
  %arrayidx241 = getelementptr inbounds float*, float** %56, i64 %idxprom221
  %57 = load float*, float** %arrayidx241, align 8
  %idxprom242 = sext i32 %55 to i64
  %arrayidx243 = getelementptr inbounds float, float* %57, i64 %idxprom242
  %58 = load float, float* %arrayidx243, align 4
  %conv244 = fpext float %58 to double
  %cmp245 = fcmp ugt double %54, %conv244
  br i1 %cmp245, label %for.inc256, label %if.then247

if.then247:                                       ; preds = %for.body235
  store double %conv244, double* %val219, align 8
  br label %for.inc256

for.inc256:                                       ; preds = %if.then247, %for.body235
  %59 = phi double [ %conv244, %if.then247 ], [ %54, %for.body235 ]
  %Next257 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.3, i64 0, i32 2
  %60 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next257, align 8
  br label %for.cond232

for.end258:                                       ; preds = %for.cond232
  %sub260 = fsub double %50, %54
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @555, i32 0, i32 0))
  %call261 = call double @fabs(double %sub260) #12
  %61 = load float, float* %maxC, align 8
  %conv263 = fpext float %61 to double
  %mul264 = fmul double %conv263, 1.000000e-06
  %cmp265 = fcmp olt double %call261, %mul264
  br i1 %cmp265, label %for.cond269, label %for.inc284

for.cond269:                                      ; preds = %for.end258, %for.inc279
  %CurV.4 = phi %struct.emd_node1_t* [ %64, %for.inc279 ], [ %48, %for.end258 ]
  %cmp270 = icmp eq %struct.emd_node1_t* %CurV.4, null
  br i1 %cmp270, label %for.inc284, label %for.inc279

for.inc279:                                       ; preds = %for.cond269
  %i275 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.4, i64 0, i32 0
  %62 = load i32, i32* %i275, align 8
  %idxprom276 = sext i32 %62 to i64
  %arrayidx277 = getelementptr inbounds [257 x [257 x double]], [257 x [257 x double]]* %Delta, i64 0, i64 %idxprom221, i64 %idxprom276
  %63 = load double, double* %arrayidx277, align 8
  %add278 = fadd double %63, %sub260
  store double %add278, double* %arrayidx277, align 8
  %Next280 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurV.4, i64 0, i32 2
  %64 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next280, align 8
  br label %for.cond269

for.inc284:                                       ; preds = %for.cond269, %for.body216, %for.end258
  %Next285 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %CurU.4, i64 0, i32 2
  %65 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next285, align 8
  br label %for.cond213

do.cond:                                          ; preds = %for.cond213, %for.cond142
  %66 = phi %struct.emd_node1_t* [ %28, %for.cond142 ], [ %48, %for.cond213 ]
  %67 = phi %struct.emd_node1_t* [ %29, %for.cond142 ], [ %47, %for.cond213 ]
  %cmp289 = icmp ne %struct.emd_node1_t* %67, null
  %cmp292 = icmp ne %struct.emd_node1_t* %66, null
  %or.cond = or i1 %cmp289, %cmp292
  br i1 %or.cond, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %for.end132
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @addBasicVariable(%struct.emd_state_t* nocapture %state, i32 %minI, i32 %minJ, double* nocapture %S, double* nocapture %D, %struct.emd_node1_t* nocapture %PrevUMinI, %struct.emd_node1_t* nocapture %PrevVMinJ, %struct.emd_node1_t* nocapture readonly %UHead) unnamed_addr #0 {
entry:
  %idxprom = sext i32 %minI to i64
  %arrayidx = getelementptr inbounds double, double* %S, i64 %idxprom
  %0 = load double, double* %arrayidx, align 8
  %idxprom1 = sext i32 %minJ to i64
  %arrayidx2 = getelementptr inbounds double, double* %D, i64 %idxprom1
  %1 = load double, double* %arrayidx2, align 8
  %sub = fsub double %0, %1
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @556, i32 0, i32 0))
  %call = call double @fabs(double %sub) #12
  %maxW = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 9
  %2 = load double, double* %maxW, align 8
  %mul = fmul double %2, 1.000000e-06
  %cmp = fcmp ugt double %call, %mul
  br i1 %cmp, label %if.else, label %if.end31

if.else:                                          ; preds = %entry
  %cmp14 = fcmp olt double %0, %1
  %arrayidx.arrayidx2 = select i1 %cmp14, double* %arrayidx, double* %arrayidx2
  %arrayidx2.arrayidx = select i1 %cmp14, double* %arrayidx2, double* %arrayidx
  %. = select i1 %cmp14, double %0, double %1
  br label %if.end31

if.end31:                                         ; preds = %entry, %if.else
  %arrayidx.sink = phi double* [ %arrayidx.arrayidx2, %if.else ], [ %arrayidx, %entry ]
  %arrayidx2.sink2 = phi double* [ %arrayidx2.arrayidx, %if.else ], [ %arrayidx2, %entry ]
  %.sink1 = phi double [ %., %if.else ], [ %0, %entry ]
  store double 0.000000e+00, double* %arrayidx.sink, align 8
  %3 = load double, double* %arrayidx2.sink2, align 8
  %sub22 = fsub double %3, %.sink1
  store double %sub22, double* %arrayidx2.sink2, align 8
  %arrayidx35 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 6, i64 %idxprom, i64 %idxprom1
  store i8 1, i8* %arrayidx35, align 1
  %EndX = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 4
  %4 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %val = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %4, i64 0, i32 2
  store double %.sink1, double* %val, align 8
  %5 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %i = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %5, i64 0, i32 0
  store i32 %minI, i32* %i, align 8
  %6 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %j = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %6, i64 0, i32 1
  store i32 %minJ, i32* %j, align 4
  %arrayidx39 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 7, i64 %idxprom
  %7 = bitcast %struct.emd_node2_t** %arrayidx39 to i64*
  %8 = load i64, i64* %7, align 8
  %9 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %NextC = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %9, i64 0, i32 3
  %10 = bitcast %struct.emd_node2_t** %NextC to i64*
  store i64 %8, i64* %10, align 8
  %arrayidx42 = getelementptr inbounds %struct.emd_state_t, %struct.emd_state_t* %state, i64 0, i32 8, i64 %idxprom1
  %11 = bitcast %struct.emd_node2_t** %arrayidx42 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %NextR = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %13, i64 0, i32 4
  %14 = bitcast %struct.emd_node2_t** %NextR to i64*
  store i64 %12, i64* %14, align 8
  %15 = bitcast %struct.emd_node2_t** %EndX to i64*
  %16 = load i64, i64* %15, align 8
  store i64 %16, i64* %7, align 8
  %17 = load i64, i64* %15, align 8
  store i64 %17, i64* %11, align 8
  %18 = load %struct.emd_node2_t*, %struct.emd_node2_t** %EndX, align 8
  %incdec.ptr = getelementptr inbounds %struct.emd_node2_t, %struct.emd_node2_t* %18, i64 1
  store %struct.emd_node2_t* %incdec.ptr, %struct.emd_node2_t** %EndX, align 8
  %19 = load double, double* %arrayidx, align 8
  %cmp55 = fcmp oeq double %19, 0.000000e+00
  br i1 %cmp55, label %land.lhs.true, label %if.end66

land.lhs.true:                                    ; preds = %if.end31
  %Next = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %UHead, i64 0, i32 2
  %20 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next, align 8
  %Next56 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %20, i64 0, i32 2
  %21 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next56, align 8
  %cmp57 = icmp eq %struct.emd_node1_t* %21, null
  %PrevVMinJ.PrevUMinI = select i1 %cmp57, %struct.emd_node1_t* %PrevVMinJ, %struct.emd_node1_t* %PrevUMinI
  br label %if.end66

if.end66:                                         ; preds = %land.lhs.true, %if.end31
  %PrevVMinJ.sink = phi %struct.emd_node1_t* [ %PrevVMinJ, %if.end31 ], [ %PrevVMinJ.PrevUMinI, %land.lhs.true ]
  %Next63 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %PrevVMinJ.sink, i64 0, i32 2
  %22 = load %struct.emd_node1_t*, %struct.emd_node1_t** %Next63, align 8
  %Next64 = getelementptr inbounds %struct.emd_node1_t, %struct.emd_node1_t* %22, i64 0, i32 2
  %23 = bitcast %struct.emd_node1_t** %Next64 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = bitcast %struct.emd_node1_t** %Next63 to i64*
  store i64 %24, i64* %25, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @horizontal(i8* nocapture readonly %image, i32 %orig_width, i32 %orig_height, i8* nocapture %resize_image, i32 %width) unnamed_addr #0 {
entry:
  %conv = sitofp i32 %width to float
  %conv1 = sitofp i32 %orig_width to float
  %div = fdiv float %conv, %conv1
  %conv2 = fpext float %div to double
  %div3 = fdiv double 1.000000e+00, %conv2
  %call = call fastcc double @Max(double %div3, double 1.000000e+00)
  %conv4 = fptrunc double %call to float
  %mul = fmul float %conv4, 3.000000e+00
  %cmp = fcmp olt float %mul, 5.000000e-01
  %support.0 = select i1 %cmp, float 5.000000e-01, float %mul
  %conv7 = fpext float %support.0 to double
  %mul8 = fmul double %conv7, 2.000000e+00
  %add = fadd double %mul8, 3.000000e+00
  %conv9 = fptoui double %add to i64
  %mul10 = shl i64 %conv9, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @557, i32 0, i32 0))
  %call11 = call noalias i8* @malloc(i64 %mul10) #11
  %0 = bitcast i8* %call11 to float*
  %cmp12 = icmp eq i8* %call11, null
  br i1 %cmp12, label %do.body, label %if.end16

do.body:                                          ; preds = %entry
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @558, i32 0, i32 0))
  %2 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.578, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %1) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @559, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end16:                                         ; preds = %entry
  %conv4.op = fdiv float 1.000000e+00, %conv4
  %conv20 = sext i32 %width to i64
  %conv34 = sitofp i32 %orig_width to double
  %3 = fpext float %conv4.op to double
  %conv43 = select i1 %cmp, double 1.000000e+00, double %3
  %conv64 = sext i32 %orig_height to i64
  %conv68 = sext i32 %orig_width to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc108, %if.end16
  %x.0 = phi i64 [ 0, %if.end16 ], [ %inc109, %for.inc108 ]
  %cmp21 = icmp slt i64 %x.0, %conv20
  br i1 %cmp21, label %for.body, label %for.end110

for.body:                                         ; preds = %for.cond
  %conv23 = sitofp i64 %x.0 to double
  %add24 = fadd double %conv23, 5.000000e-01
  %conv25 = fptrunc double %add24 to float
  %div26 = fdiv float %conv25, %div
  %sub = fsub float %div26, %support.0
  %sub27 = fadd float %sub, 0xBEB0C6F7A0000000
  %conv28 = fpext float %sub27 to double
  %call29 = call fastcc double @Max(double %conv28, double 0.000000e+00)
  %add30 = fadd double %call29, 5.000000e-01
  %conv31 = fptosi double %add30 to i64
  %add32 = fadd float %div26, %support.0
  %conv33 = fpext float %add32 to double
  %call35 = call fastcc double @Min(double %conv33, double %conv34)
  %add36 = fadd double %call35, 5.000000e-01
  %conv37 = fptosi double %add36 to i64
  %sub39 = sub nsw i64 %conv37, %conv31
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc, %for.body
  %n.0 = phi i64 [ 0, %for.body ], [ %inc, %for.inc ]
  %density.0 = phi float [ 0.000000e+00, %for.body ], [ %add53, %for.inc ]
  %cmp40 = icmp slt i64 %n.0, %sub39
  br i1 %cmp40, label %for.inc, label %for.cond54

for.inc:                                          ; preds = %for.cond38
  %add44 = add nsw i64 %conv31, %n.0
  %conv45 = sitofp i64 %add44 to float
  %sub46 = fsub float %conv45, %div26
  %conv47 = fpext float %sub46 to double
  %add48 = fadd double %conv47, 5.000000e-01
  %mul49 = fmul double %conv43, %add48
  %conv50 = fptrunc double %mul49 to float
  %call51 = call fastcc float @weight(float %conv50)
  %arrayidx = getelementptr inbounds float, float* %0, i64 %n.0
  store float %call51, float* %arrayidx, align 4
  %add53 = fadd float %density.0, %call51
  %inc = add nuw nsw i64 %n.0, 1
  br label %for.cond38

for.cond54:                                       ; preds = %for.cond38, %for.inc60
  %i.0 = phi i64 [ %inc61, %for.inc60 ], [ 0, %for.cond38 ]
  %cmp55 = icmp slt i64 %i.0, %n.0
  br i1 %cmp55, label %for.inc60, label %for.cond63

for.inc60:                                        ; preds = %for.cond54
  %arrayidx58 = getelementptr inbounds float, float* %0, i64 %i.0
  %4 = load float, float* %arrayidx58, align 4
  %div59 = fdiv float %4, %density.0
  store float %div59, float* %arrayidx58, align 4
  %inc61 = add nuw nsw i64 %i.0, 1
  br label %for.cond54

for.cond63:                                       ; preds = %for.cond54, %for.inc105
  %y.0 = phi i64 [ %inc106, %for.inc105 ], [ 0, %for.cond54 ]
  %cmp65 = icmp slt i64 %y.0, %conv64
  br i1 %cmp65, label %for.body67, label %for.inc108

for.body67:                                       ; preds = %for.cond63
  %mul69 = mul nsw i64 %y.0, %conv68
  %add70 = add nsw i64 %mul69, %conv31
  %mul71 = mul nsw i64 %add70, 3
  %add.ptr = getelementptr inbounds i8, i8* %image, i64 %mul71
  %mul73 = mul nsw i64 %y.0, %conv20
  %add74 = add nsw i64 %mul73, %x.0
  %mul75 = mul nsw i64 %add74, 3
  br label %for.cond77

for.cond77:                                       ; preds = %for.inc96, %for.body67
  %i.1 = phi i64 [ 0, %for.body67 ], [ %inc97, %for.inc96 ]
  %p.0 = phi i8* [ %add.ptr, %for.body67 ], [ %incdec.ptr91, %for.inc96 ]
  %r.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add85, %for.inc96 ]
  %g.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add90, %for.inc96 ]
  %b.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add95, %for.inc96 ]
  %cmp78 = icmp slt i64 %i.1, %n.0
  br i1 %cmp78, label %for.inc96, label %for.inc105

for.inc96:                                        ; preds = %for.cond77
  %arrayidx81 = getelementptr inbounds float, float* %0, i64 %i.1
  %5 = load float, float* %arrayidx81, align 4
  %incdec.ptr86 = getelementptr inbounds i8, i8* %p.0, i64 2
  %6 = load i8, i8* %incdec.ptr86, align 1
  %conv93 = uitofp i8 %6 to float
  %mul94 = fmul float %5, %conv93
  %add95 = fadd float %b.0, %mul94
  %incdec.ptr91 = getelementptr inbounds i8, i8* %p.0, i64 3
  %incdec.ptr = getelementptr inbounds i8, i8* %p.0, i64 1
  %7 = load i8, i8* %incdec.ptr, align 1
  %conv88 = uitofp i8 %7 to float
  %mul89 = fmul float %5, %conv88
  %add90 = fadd float %g.0, %mul89
  %8 = load i8, i8* %p.0, align 1
  %conv83 = uitofp i8 %8 to float
  %mul84 = fmul float %5, %conv83
  %add85 = fadd float %r.0, %mul84
  %inc97 = add nuw nsw i64 %i.1, 1
  br label %for.cond77

for.inc105:                                       ; preds = %for.cond77
  %add.ptr76 = getelementptr inbounds i8, i8* %resize_image, i64 %mul75
  %call99 = call fastcc zeroext i8 @myround(float %r.0)
  %incdec.ptr100 = getelementptr inbounds i8, i8* %add.ptr76, i64 1
  store i8 %call99, i8* %add.ptr76, align 1
  %call101 = call fastcc zeroext i8 @myround(float %g.0)
  %incdec.ptr102 = getelementptr inbounds i8, i8* %incdec.ptr100, i64 1
  store i8 %call101, i8* %incdec.ptr100, align 1
  %call103 = call fastcc zeroext i8 @myround(float %b.0)
  store i8 %call103, i8* %incdec.ptr102, align 1
  %inc106 = add nuw nsw i64 %y.0, 1
  br label %for.cond63

for.inc108:                                       ; preds = %for.cond63
  %inc109 = add nuw nsw i64 %x.0, 1
  br label %for.cond

for.end110:                                       ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @560, i32 0, i32 0))
  call void @free(i8* %call11) #11
  ret void
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc double @Max(double %x, double %y) unnamed_addr #7 {
entry:
  %cmp = fcmp ogt double %x, %y
  %cond = select i1 %cmp, double %x, double %y
  ret double %cond
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc double @Min(double %x, double %y) unnamed_addr #7 {
entry:
  %cmp = fcmp ogt double %y, %x
  %cond = select i1 %cmp, double %x, double %y
  ret double %cond
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @weight(float %x) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @561, i32 0, i32 0))
  %fabsf = call float @fabsf(float %x) #13
  %div = fdiv float %fabsf, 3.000000e+00
  %call2 = call fastcc float @sinc(float %div)
  %call3 = call fastcc float @sinc(float %fabsf)
  %mul = fmul float %call2, %call3
  ret float %mul
}

; Function Attrs: noinline norecurse nounwind readnone uwtable
define internal fastcc zeroext i8 @myround(float %v) unnamed_addr #7 {
entry:
  %cmp = fcmp ugt float %v, 0.000000e+00
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %cmp1 = fcmp ult float %v, 2.550000e+02
  br i1 %cmp1, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %conv = fpext float %v to double
  %add = fadd double %conv, 5.000000e-01
  %conv4 = fptoui double %add to i8
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i8 [ %conv4, %if.end3 ], [ 0, %entry ], [ -1, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc float @sinc(float %x) unnamed_addr #0 {
entry:
  %cmp = fcmp oeq float %x, 0.000000e+00
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv2 = fpext float %x to double
  %mul = fmul double %conv2, 0x400921FB54442D18
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @562, i32 0, i32 0))
  %call = call double @sin(double %mul) #11
  %div = fdiv double %call, %mul
  %conv5 = fptrunc double %div to float
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi float [ %conv5, %if.end ], [ 1.000000e+00, %entry ]
  ret float %retval.0
}

; Function Attrs: nounwind
declare double @sin(double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @vertical(i8* nocapture readonly %image, i32 %orig_width, i32 %orig_height, i8* nocapture %resize_image, i32 %height) unnamed_addr #0 {
entry:
  %conv = sitofp i32 %height to float
  %conv1 = sitofp i32 %orig_height to float
  %div = fdiv float %conv, %conv1
  %conv2 = fpext float %div to double
  %div3 = fdiv double 1.000000e+00, %conv2
  %call = call fastcc double @Max(double %div3, double 1.000000e+00)
  %conv4 = fptrunc double %call to float
  %mul = fmul float %conv4, 3.000000e+00
  %cmp = fcmp olt float %mul, 5.000000e-01
  %support.0 = select i1 %cmp, float 5.000000e-01, float %mul
  %conv7 = fpext float %support.0 to double
  %mul8 = fmul double %conv7, 2.000000e+00
  %add = fadd double %mul8, 3.000000e+00
  %conv9 = fptoui double %add to i64
  %mul10 = shl i64 %conv9, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @563, i32 0, i32 0))
  %call11 = call noalias i8* @malloc(i64 %mul10) #11
  %0 = bitcast i8* %call11 to float*
  %cmp12 = icmp eq i8* %call11, null
  br i1 %cmp12, label %do.body, label %if.end16

do.body:                                          ; preds = %entry
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @564, i32 0, i32 0))
  %2 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.578, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %1) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @565, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end16:                                         ; preds = %entry
  %conv4.op = fdiv float 1.000000e+00, %conv4
  %conv20 = sext i32 %height to i64
  %conv34 = sitofp i32 %orig_height to double
  %3 = fpext float %conv4.op to double
  %conv43 = select i1 %cmp, double 1.000000e+00, double %3
  %conv64 = sext i32 %orig_width to i64
  %mul96 = mul nsw i32 %orig_width, 3
  %idx.ext = sext i32 %mul96 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc109, %if.end16
  %y.0 = phi i64 [ 0, %if.end16 ], [ %inc110, %for.inc109 ]
  %cmp21 = icmp slt i64 %y.0, %conv20
  br i1 %cmp21, label %for.body, label %for.end111

for.body:                                         ; preds = %for.cond
  %conv23 = sitofp i64 %y.0 to double
  %add24 = fadd double %conv23, 5.000000e-01
  %conv25 = fptrunc double %add24 to float
  %div26 = fdiv float %conv25, %div
  %sub = fsub float %div26, %support.0
  %sub27 = fadd float %sub, 0xBEB0C6F7A0000000
  %conv28 = fpext float %sub27 to double
  %call29 = call fastcc double @Max(double %conv28, double 0.000000e+00)
  %add30 = fadd double %call29, 5.000000e-01
  %conv31 = fptosi double %add30 to i64
  %add32 = fadd float %div26, %support.0
  %conv33 = fpext float %add32 to double
  %call35 = call fastcc double @Min(double %conv33, double %conv34)
  %add36 = fadd double %call35, 5.000000e-01
  %conv37 = fptosi double %add36 to i64
  %sub39 = sub nsw i64 %conv37, %conv31
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc, %for.body
  %n.0 = phi i64 [ 0, %for.body ], [ %inc, %for.inc ]
  %density.0 = phi float [ 0.000000e+00, %for.body ], [ %add53, %for.inc ]
  %cmp40 = icmp slt i64 %n.0, %sub39
  br i1 %cmp40, label %for.inc, label %for.cond54

for.inc:                                          ; preds = %for.cond38
  %add44 = add nsw i64 %conv31, %n.0
  %conv45 = sitofp i64 %add44 to float
  %sub46 = fsub float %conv45, %div26
  %conv47 = fpext float %sub46 to double
  %add48 = fadd double %conv47, 5.000000e-01
  %mul49 = fmul double %conv43, %add48
  %conv50 = fptrunc double %mul49 to float
  %call51 = call fastcc float @weight(float %conv50)
  %arrayidx = getelementptr inbounds float, float* %0, i64 %n.0
  store float %call51, float* %arrayidx, align 4
  %add53 = fadd float %density.0, %call51
  %inc = add nuw nsw i64 %n.0, 1
  br label %for.cond38

for.cond54:                                       ; preds = %for.cond38, %for.inc60
  %i.0 = phi i64 [ %inc61, %for.inc60 ], [ 0, %for.cond38 ]
  %cmp55 = icmp slt i64 %i.0, %n.0
  br i1 %cmp55, label %for.inc60, label %for.cond63.preheader

for.cond63.preheader:                             ; preds = %for.cond54
  %mul69 = mul nsw i64 %conv31, %conv64
  %mul73 = mul nsw i64 %y.0, %conv64
  br label %for.cond63

for.inc60:                                        ; preds = %for.cond54
  %arrayidx58 = getelementptr inbounds float, float* %0, i64 %i.0
  %4 = load float, float* %arrayidx58, align 4
  %div59 = fdiv float %4, %density.0
  store float %div59, float* %arrayidx58, align 4
  %inc61 = add nuw nsw i64 %i.0, 1
  br label %for.cond54

for.cond63:                                       ; preds = %for.cond63.preheader, %for.inc106
  %x.0 = phi i64 [ %inc107, %for.inc106 ], [ 0, %for.cond63.preheader ]
  %cmp65 = icmp slt i64 %x.0, %conv64
  br i1 %cmp65, label %for.body67, label %for.inc109

for.body67:                                       ; preds = %for.cond63
  %add70 = add nsw i64 %mul69, %x.0
  %mul71 = mul nsw i64 %add70, 3
  %add.ptr = getelementptr inbounds i8, i8* %image, i64 %mul71
  %add74 = add nsw i64 %mul73, %x.0
  %mul75 = mul nsw i64 %add74, 3
  br label %for.cond77

for.cond77:                                       ; preds = %for.inc98, %for.body67
  %i.1 = phi i64 [ 0, %for.body67 ], [ %inc99, %for.inc98 ]
  %p.0 = phi i8* [ %add.ptr, %for.body67 ], [ %add.ptr97, %for.inc98 ]
  %r.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add85, %for.inc98 ]
  %g.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add90, %for.inc98 ]
  %b.0 = phi float [ 0.000000e+00, %for.body67 ], [ %add95, %for.inc98 ]
  %cmp78 = icmp slt i64 %i.1, %n.0
  br i1 %cmp78, label %for.inc98, label %for.inc106

for.inc98:                                        ; preds = %for.cond77
  %arrayidx81 = getelementptr inbounds float, float* %0, i64 %i.1
  %5 = load float, float* %arrayidx81, align 4
  %add.ptr97 = getelementptr inbounds i8, i8* %p.0, i64 %idx.ext
  %add.ptr91 = getelementptr inbounds i8, i8* %p.0, i64 2
  %6 = load i8, i8* %add.ptr91, align 1
  %conv93 = uitofp i8 %6 to float
  %mul94 = fmul float %5, %conv93
  %add95 = fadd float %b.0, %mul94
  %add.ptr86 = getelementptr inbounds i8, i8* %p.0, i64 1
  %7 = load i8, i8* %add.ptr86, align 1
  %conv88 = uitofp i8 %7 to float
  %mul89 = fmul float %5, %conv88
  %add90 = fadd float %g.0, %mul89
  %8 = load i8, i8* %p.0, align 1
  %conv83 = uitofp i8 %8 to float
  %mul84 = fmul float %5, %conv83
  %add85 = fadd float %r.0, %mul84
  %inc99 = add nuw nsw i64 %i.1, 1
  br label %for.cond77

for.inc106:                                       ; preds = %for.cond77
  %add.ptr76 = getelementptr inbounds i8, i8* %resize_image, i64 %mul75
  %call101 = call fastcc zeroext i8 @myround(float %r.0)
  %incdec.ptr = getelementptr inbounds i8, i8* %add.ptr76, i64 1
  store i8 %call101, i8* %add.ptr76, align 1
  %call102 = call fastcc zeroext i8 @myround(float %g.0)
  %incdec.ptr103 = getelementptr inbounds i8, i8* %incdec.ptr, i64 1
  store i8 %call102, i8* %incdec.ptr, align 1
  %call104 = call fastcc zeroext i8 @myround(float %b.0)
  store i8 %call104, i8* %incdec.ptr103, align 1
  %inc107 = add nuw nsw i64 %x.0, 1
  br label %for.cond63

for.inc109:                                       ; preds = %for.cond63
  %inc110 = add nuw nsw i64 %y.0, 1
  br label %for.cond

for.end111:                                       ; preds = %for.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @566, i32 0, i32 0))
  call void @free(i8* %call11) #11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias i8* @resize(i8* nocapture readonly %image, i32 %orig_width, i32 %orig_height) unnamed_addr #0 {
entry:
  %cmp = icmp sgt i32 %orig_height, %orig_width
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mul3 = mul nsw i32 %orig_height, 384
  %conv = sext i32 %mul3 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @567, i32 0, i32 0))
  %call = call noalias i8* @malloc(i64 %conv) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @568, i32 0, i32 0))
  %call7 = call noalias i8* @malloc(i64 49152) #11
  %cmp8 = icmp eq i8* %call, null
  %cmp10 = icmp eq i8* %call7, null
  %or.cond = or i1 %cmp8, %cmp10
  br i1 %or.cond, label %do.body, label %if.end

do.body:                                          ; preds = %if.then
  %0 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @569, i32 0, i32 0))
  %1 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.578, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %0) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @570, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end:                                           ; preds = %if.then
  call fastcc void @horizontal(i8* %image, i32 %orig_width, i32 %orig_height, i8* nonnull %call, i32 128)
  call fastcc void @vertical(i8* nonnull %call, i32 128, i32 %orig_height, i8* nonnull %call7, i32 128)
  br label %if.end36

if.else:                                          ; preds = %entry
  %mul17 = mul nsw i32 %orig_width, 384
  %conv18 = sext i32 %mul17 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @571, i32 0, i32 0))
  %call19 = call noalias i8* @malloc(i64 %conv18) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @572, i32 0, i32 0))
  %call23 = call noalias i8* @malloc(i64 49152) #11
  %cmp24 = icmp eq i8* %call19, null
  %cmp27 = icmp eq i8* %call23, null
  %or.cond1 = or i1 %cmp24, %cmp27
  br i1 %or.cond1, label %do.body30, label %if.end33

do.body30:                                        ; preds = %if.else
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @573, i32 0, i32 0))
  %3 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.578, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %2) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @574, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end33:                                         ; preds = %if.else
  call fastcc void @vertical(i8* %image, i32 %orig_width, i32 %orig_height, i8* nonnull %call19, i32 128)
  call fastcc void @horizontal(i8* nonnull %call19, i32 %orig_width, i32 128, i8* nonnull %call23, i32 128)
  br label %if.end36

if.end36:                                         ; preds = %if.end33, %if.end
  %filter_image.0 = phi i8* [ %call, %if.end ], [ %call19, %if.end33 ]
  %resize_image.0 = phi i8* [ %call7, %if.end ], [ %call23, %if.end33 ]
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @575, i32 0, i32 0))
  call void @free(i8* %filter_image.0) #11
  ret i8* %resize_image.0
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @pixel_rgb2hsv(i8 %rgb.val, i8 %rgb.1.val, i8 %rgb.2.val, i8* nocapture %hsv) unnamed_addr #8 {
entry:
  %arrayidx3 = getelementptr inbounds i8, i8* %hsv, i64 2
  store i8 0, i8* %arrayidx3, align 1
  %arrayidx4 = getelementptr inbounds i8, i8* %hsv, i64 1
  store i8 0, i8* %arrayidx4, align 1
  store i8 0, i8* %hsv, align 1
  %cmp = icmp ugt i8 %rgb.1.val, %rgb.val
  %rgb.1.val.rgb.val = select i1 %cmp, i8 %rgb.1.val, i8 %rgb.val
  %cmp10 = icmp ult i8 %rgb.1.val, %rgb.val
  %mn.0 = select i1 %cmp10, i8 %rgb.1.val, i8 %rgb.val
  %cmp16 = icmp ult i8 %rgb.1.val.rgb.val, %rgb.2.val
  %rgb.2.val.rgb.1.val.rgb.val = select i1 %cmp16, i8 %rgb.2.val, i8 %rgb.1.val.rgb.val
  %cmp22 = icmp ugt i8 %mn.0, %rgb.2.val
  %mn.1 = select i1 %cmp22, i8 %rgb.2.val, i8 %mn.0
  %sub = sub i8 %rgb.2.val.rgb.1.val.rgb.val, %mn.1
  store i8 %rgb.2.val.rgb.1.val.rgb.val, i8* %arrayidx3, align 1
  %cmp31 = icmp eq i8 %rgb.2.val.rgb.1.val.rgb.val, 0
  br i1 %cmp31, label %return, label %if.end34

if.end34:                                         ; preds = %entry
  %conv35 = zext i8 %sub to i32
  %mul = mul nuw nsw i32 %conv35, 255
  %conv36 = zext i8 %rgb.2.val.rgb.1.val.rgb.val to i32
  %div = udiv i32 %mul, %conv36
  %conv37 = trunc i32 %div to i8
  store i8 %conv37, i8* %arrayidx4, align 1
  %cmp40 = icmp eq i8 %sub, 0
  br i1 %cmp40, label %return, label %if.end43

if.end43:                                         ; preds = %if.end34
  %cmp46 = icmp eq i8 %rgb.2.val.rgb.1.val.rgb.val, %rgb.val
  br i1 %cmp46, label %if.then48, label %if.else

if.then48:                                        ; preds = %if.end43
  %conv49 = uitofp i8 %rgb.1.val to float
  %conv50 = uitofp i8 %rgb.2.val to float
  %sub51 = fsub float %conv49, %conv50
  %conv52 = uitofp i8 %sub to float
  %div53 = fdiv float %sub51, %conv52
  br label %if.end76

if.else:                                          ; preds = %if.end43
  %cmp56 = icmp eq i8 %rgb.2.val.rgb.1.val.rgb.val, %rgb.1.val
  br i1 %cmp56, label %if.then58, label %if.else66

if.then58:                                        ; preds = %if.else
  %conv59 = uitofp i8 %rgb.2.val to float
  %conv60 = uitofp i8 %rgb.val to float
  %sub61 = fsub float %conv59, %conv60
  %conv62 = uitofp i8 %sub to float
  %div63 = fdiv float %sub61, %conv62
  %conv65 = fadd float %div63, 2.000000e+00
  br label %if.end76

if.else66:                                        ; preds = %if.else
  %conv67 = uitofp i8 %rgb.val to float
  %conv68 = uitofp i8 %rgb.1.val to float
  %sub69 = fsub float %conv67, %conv68
  %conv70 = uitofp i8 %sub to float
  %div71 = fdiv float %sub69, %conv70
  %conv74 = fadd float %div71, 4.000000e+00
  br label %if.end76

if.end76:                                         ; preds = %if.then58, %if.else66, %if.then48
  %hue.1 = phi float [ %div53, %if.then48 ], [ %conv65, %if.then58 ], [ %conv74, %if.else66 ]
  %cmp77 = fcmp olt float %hue.1, 0.000000e+00
  %conv82 = fadd float %hue.1, 6.000000e+00
  %hue.2 = select i1 %cmp77, float %conv82, float %hue.1
  %mul84 = fmul float %hue.2, 2.550000e+02
  %conv85 = fpext float %mul84 to double
  %div86 = fdiv double %conv85, 6.000000e+00
  %conv87 = fptoui double %div86 to i8
  store i8 %conv87, i8* %hsv, align 1
  br label %return

return:                                           ; preds = %if.end34, %entry, %if.end76
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @rgb2hsv(i8* nocapture readonly %rgb, i8* nocapture %hsv) unnamed_addr #8 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %hsv.addr.0 = phi i8* [ %hsv, %entry ], [ %add.ptr1, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rgb.addr.0 = phi i8* [ %rgb, %entry ], [ %add.ptr, %for.inc ]
  %exitcond = icmp eq i32 %i.0, 16384
  br i1 %exitcond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  %rgb.addr.0.val = load i8, i8* %rgb.addr.0, align 1
  %rgb.addr.0.idx = getelementptr i8, i8* %rgb.addr.0, i64 1
  %rgb.addr.0.idx.val = load i8, i8* %rgb.addr.0.idx, align 1
  %rgb.addr.0.idx1 = getelementptr i8, i8* %rgb.addr.0, i64 2
  %rgb.addr.0.idx1.val = load i8, i8* %rgb.addr.0.idx1, align 1
  call fastcc void @pixel_rgb2hsv(i8 %rgb.addr.0.val, i8 %rgb.addr.0.idx.val, i8 %rgb.addr.0.idx1.val, i8* %hsv.addr.0)
  %add.ptr1 = getelementptr inbounds i8, i8* %hsv.addr.0, i64 3
  %add.ptr = getelementptr inbounds i8, i8* %rgb.addr.0, i64 3
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc i32 @image_read_rgb_hsv(i8* %filename, i32* nocapture %width, i32* nocapture %height, i8** nocapture %data_rgb, i8** nocapture %data_hsv) unnamed_addr #0 {
entry:
  %cinfo = alloca %struct.jpeg_decompress_struct, align 8
  %jerr = alloca %struct.jpeg_error_mgr, align 8
  %row_pointer = alloca [1 x i8*], align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @576, i32 0, i32 0))
  %call = call %struct._IO_FILE* @fopen(i8* %filename, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1.585, i64 0, i64 0))
  %cmp = icmp eq %struct._IO_FILE* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @577, i32 0, i32 0))
  %call1 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.2.586, i64 0, i64 0), i8* %filename) #14
  br label %return

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @578, i32 0, i32 0))
  %call2 = call %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr* nonnull %jerr) #11
  %err = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 0
  store %struct.jpeg_error_mgr* %call2, %struct.jpeg_error_mgr** %err, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @579, i32 0, i32 0))
  call void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct* nonnull %cinfo, i32 80, i64 656) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @580, i32 0, i32 0))
  call void @jpeg_stdio_src(%struct.jpeg_decompress_struct* nonnull %cinfo, %struct._IO_FILE* nonnull %call) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @581, i32 0, i32 0))
  %call3 = call i32 @jpeg_read_header(%struct.jpeg_decompress_struct* nonnull %cinfo, i32 1) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @582, i32 0, i32 0))
  %call4 = call i32 @jpeg_start_decompress(%struct.jpeg_decompress_struct* nonnull %cinfo) #11
  %output_width = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 27
  %1 = load i32, i32* %output_width, align 8
  %output_components = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 30
  %2 = load i32, i32* %output_components, align 4
  %output_height = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 28
  %3 = load i32, i32* %output_height, align 4
  %mul6 = mul i32 %1, %3
  %mul8 = mul i32 %mul6, %2
  %conv = zext i32 %mul8 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @583, i32 0, i32 0))
  %call9 = call noalias i8* @malloc(i64 %conv) #11
  %cmp10 = icmp eq i8* %call9, null
  br i1 %cmp10, label %do.body, label %if.end14

do.body:                                          ; preds = %if.end
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @584, i32 0, i32 0))
  %5 = call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.578, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %4) #14
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @585, i32 0, i32 0))
  call void @exit(i32 -1) #16
  unreachable

if.end14:                                         ; preds = %if.end
  %mul = mul i32 %1, %2
  %arrayidx = getelementptr inbounds [1 x i8*], [1 x i8*]* %row_pointer, i64 0, i64 0
  store i8* %call9, i8** %arrayidx, align 8
  %output_scanline = getelementptr inbounds %struct.jpeg_decompress_struct, %struct.jpeg_decompress_struct* %cinfo, i64 0, i32 34
  %idx.ext = sext i32 %mul to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end14
  %6 = phi i32 [ %.pre, %while.body ], [ %3, %if.end14 ]
  %7 = load i32, i32* %output_scanline, align 8
  %cmp16 = icmp ult i32 %7, %6
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @586, i32 0, i32 0))
  %call18 = call i32 @jpeg_read_scanlines(%struct.jpeg_decompress_struct* nonnull %cinfo, i8** %arrayidx, i32 1) #11
  %8 = load i8*, i8** %arrayidx, align 8
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 %idx.ext
  store i8* %add.ptr, i8** %arrayidx, align 8
  %.pre = load i32, i32* %output_height, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @587, i32 0, i32 0))
  %call20 = call i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct* nonnull %cinfo) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @588, i32 0, i32 0))
  call void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct* nonnull %cinfo) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @589, i32 0, i32 0))
  %call21 = call i32 @fclose(%struct._IO_FILE* nonnull %call)
  %9 = load i32, i32* %output_width, align 8
  %10 = load i32, i32* %output_height, align 4
  %call24 = call fastcc i8* @resize(i8* nonnull %call9, i32 %9, i32 %10)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @590, i32 0, i32 0))
  %call25 = call noalias i8* @malloc(i64 49152) #11
  call fastcc void @rgb2hsv(i8* %call24, i8* %call25)
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @591, i32 0, i32 0))
  call void @free(i8* %call9) #11
  store i32 128, i32* %width, align 4
  store i32 128, i32* %height, align 4
  store i8* %call24, i8** %data_rgb, align 8
  store i8* %call25, i8** %data_hsv, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %while.end ]
  ret i32 %retval.0
}

declare %struct.jpeg_error_mgr* @jpeg_std_error(%struct.jpeg_error_mgr*) local_unnamed_addr #2

declare void @jpeg_CreateDecompress(%struct.jpeg_decompress_struct*, i32, i64) local_unnamed_addr #2

declare void @jpeg_stdio_src(%struct.jpeg_decompress_struct*, %struct._IO_FILE*) local_unnamed_addr #2

declare i32 @jpeg_read_header(%struct.jpeg_decompress_struct*, i32) local_unnamed_addr #2

declare i32 @jpeg_start_decompress(%struct.jpeg_decompress_struct*) local_unnamed_addr #2

declare i32 @jpeg_read_scanlines(%struct.jpeg_decompress_struct*, i8**, i32) local_unnamed_addr #2

declare i32 @jpeg_finish_decompress(%struct.jpeg_decompress_struct*) local_unnamed_addr #2

declare void @jpeg_destroy_decompress(%struct.jpeg_decompress_struct*) local_unnamed_addr #2

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @apply_weight(%struct.cass_dataset_t* nocapture readonly %ds) unnamed_addr #8 {
entry:
  %vec1 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %0 = bitcast i8** %vec1 to %struct._cass_vec_t**
  %1 = load %struct._cass_vec_t*, %struct._cass_vec_t** %0, align 8
  %2 = bitcast %struct._cass_vec_t* %1 to i8*
  %num_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  %vec_dim = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 3
  %vec_size = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc7, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc7 ]
  %3 = phi i8* [ %2, %entry ], [ %add.ptr, %for.inc7 ]
  %vec.0 = phi %struct._cass_vec_t* [ %1, %entry ], [ %9, %for.inc7 ]
  %4 = load i32, i32* %num_vec, align 4
  %cmp = icmp ult i32 %i.0, %4
  br i1 %cmp, label %for.cond2.preheader, label %for.end9

for.cond2.preheader:                              ; preds = %for.cond
  %u = getelementptr inbounds %struct._cass_vec_t, %struct._cass_vec_t* %vec.0, i64 0, i32 2
  %float_data = bitcast %union.anon.33* %u to [1 x float]*
  br label %for.cond2

for.cond2:                                        ; preds = %for.cond2.preheader, %for.inc
  %j.0 = phi i32 [ %inc, %for.inc ], [ 0, %for.cond2.preheader ]
  %5 = load i32, i32* %vec_dim, align 4
  %cmp3 = icmp ult i32 %j.0, %5
  br i1 %cmp3, label %for.inc, label %for.inc7

for.inc:                                          ; preds = %for.cond2
  %idxprom = zext i32 %j.0 to i64
  %arrayidx = getelementptr inbounds [14 x float], [14 x float]* @dw, i64 0, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %arrayidx6 = getelementptr inbounds [1 x float], [1 x float]* %float_data, i64 0, i64 %idxprom
  %7 = load float, float* %arrayidx6, align 4
  %mul = fmul float %7, %6
  store float %mul, float* %arrayidx6, align 4
  %inc = add i32 %j.0, 1
  br label %for.cond2

for.inc7:                                         ; preds = %for.cond2
  %8 = load i32, i32* %vec_size, align 8
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr i8, i8* %3, i64 %idx.ext
  %9 = bitcast i8* %add.ptr to %struct._cass_vec_t*
  %inc8 = add i32 %i.0, 1
  br label %for.cond

for.end9:                                         ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.box_t* @box_new(i32 %x, i32 %y) unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @592, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 48, i64 1) #11
  %0 = bitcast i8* %call to %struct.box_t*
  %a1 = bitcast i8* %call to i32*
  store i32 %x, i32* %a1, align 4
  %b1 = getelementptr inbounds i8, i8* %call, i64 4
  %1 = bitcast i8* %b1 to i32*
  store i32 %y, i32* %1, align 4
  %add = add nsw i32 %x, 1
  %a2 = getelementptr inbounds i8, i8* %call, i64 8
  %2 = bitcast i8* %a2 to i32*
  store i32 %add, i32* %2, align 4
  %add1 = add nsw i32 %y, 1
  %b2 = getelementptr inbounds i8, i8* %call, i64 12
  %3 = bitcast i8* %b2 to i32*
  store i32 %add1, i32* %3, align 4
  %cx = getelementptr inbounds i8, i8* %call, i64 32
  %4 = bitcast i8* %cx to i32*
  store i32 %x, i32* %4, align 4
  %cy = getelementptr inbounds i8, i8* %call, i64 36
  %5 = bitcast i8* %cy to i32*
  store i32 %y, i32* %5, align 4
  %p1 = getelementptr inbounds i8, i8* %call, i64 40
  %6 = bitcast i8* %p1 to i32*
  store i32 1, i32* %6, align 4
  ret %struct.box_t* %0
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @box_combine(%struct.box_t* %box) unnamed_addr #8 {
entry:
  %p2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 11
  %0 = load i32, i32* %p2, align 4
  %tobool = icmp eq i32 %0, 0
  %a120 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 0
  %1 = load i32, i32* %a120, align 4
  %u121 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 4
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %u121, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  store i32 %1, i32* %u121, align 4
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %b1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 1
  %3 = load i32, i32* %b1, align 4
  %v1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 5
  %4 = load i32, i32* %v1, align 4
  %cmp4 = icmp slt i32 %3, %4
  br i1 %cmp4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  store i32 %3, i32* %v1, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  %a2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 2
  %5 = load i32, i32* %a2, align 4
  %u2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 6
  %6 = load i32, i32* %u2, align 4
  %cmp9 = icmp sgt i32 %5, %6
  br i1 %cmp9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end8
  store i32 %5, i32* %u2, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end8
  %b2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 3
  %7 = load i32, i32* %b2, align 4
  %v2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 7
  %8 = load i32, i32* %v2, align 4
  %cmp14 = icmp sgt i32 %7, %8
  br i1 %cmp14, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end13
  store i32 %7, i32* %v2, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end13
  %p1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 10
  %9 = load i32, i32* %p1, align 4
  %add = add nsw i32 %0, %9
  br label %if.end30

if.else:                                          ; preds = %entry
  store i32 %1, i32* %u121, align 4
  %b122 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 1
  %10 = load i32, i32* %b122, align 4
  %v123 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 5
  store i32 %10, i32* %v123, align 4
  %a224 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 2
  %11 = load i32, i32* %a224, align 4
  %u225 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 6
  store i32 %11, i32* %u225, align 4
  %b226 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 3
  %12 = load i32, i32* %b226, align 4
  %v227 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 7
  store i32 %12, i32* %v227, align 4
  %p128 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 10
  %13 = load i32, i32* %p128, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.else, %if.end18
  %storemerge = phi i32 [ %add, %if.end18 ], [ %13, %if.else ]
  %p131.pre-phi = phi i32* [ %p1, %if.end18 ], [ %p128, %if.else ]
  store i32 %storemerge, i32* %p2, align 4
  store i32 0, i32* %p131.pre-phi, align 4
  ret void
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc void @box_insert_pxl(%struct.box_t* %box, i32 %x, i32 %y) unnamed_addr #8 {
lor.lhs.false:
  %a2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 2
  %0 = load i32, i32* %a2, align 4
  %a1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 0
  %1 = load i32, i32* %a1, align 4
  %b2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 3
  %2 = load i32, i32* %b2, align 4
  %b1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 1
  %3 = load i32, i32* %b1, align 4
  %p1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 10
  %4 = load i32, i32* %p1, align 4
  %cx = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 8
  %5 = load i32, i32* %cx, align 4
  %add = add nsw i32 %5, %x
  store i32 %add, i32* %cx, align 4
  %cy = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 9
  %6 = load i32, i32* %cy, align 4
  %add3 = add nsw i32 %6, %y
  store i32 %add3, i32* %cy, align 4
  %conv = sitofp i32 %4 to float
  %sub = sub nsw i32 %0, %1
  %sub1 = sub nsw i32 %2, %3
  %mul = mul nsw i32 %sub, %sub1
  %conv2 = sitofp i32 %mul to float
  %div = fdiv float %conv, %conv2
  %conv4 = fpext float %div to double
  %cmp = fcmp ogt double %conv4, 1.500000e-01
  br i1 %cmp, label %if.then, label %if.else33

if.then:                                          ; preds = %lor.lhs.false
  %cmp7 = icmp sgt i32 %1, %x
  br i1 %cmp7, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  store i32 %x, i32* %a1, align 4
  br label %if.end17

if.else:                                          ; preds = %if.then
  %cmp12 = icmp sgt i32 %0, %x
  br i1 %cmp12, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.else
  %add15 = add nsw i32 %x, 1
  store i32 %add15, i32* %a2, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.else, %if.then9
  %cmp19 = icmp sgt i32 %3, %y
  br i1 %cmp19, label %if.then21, label %if.else23

if.then21:                                        ; preds = %if.end17
  store i32 %y, i32* %b1, align 4
  br label %if.end31

if.else23:                                        ; preds = %if.end17
  %cmp25 = icmp sgt i32 %2, %y
  br i1 %cmp25, label %if.end31, label %if.then27

if.then27:                                        ; preds = %if.else23
  %add28 = add nsw i32 %y, 1
  store i32 %add28, i32* %b2, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then27, %if.else23, %if.then21
  %inc = add nsw i32 %4, 1
  br label %if.end41

if.else33:                                        ; preds = %lor.lhs.false
  call fastcc void @box_combine(%struct.box_t* %box)
  store i32 %x, i32* %a1, align 4
  store i32 %y, i32* %b1, align 4
  %add36 = add nsw i32 %x, 1
  store i32 %add36, i32* %a2, align 4
  %add38 = add nsw i32 %y, 1
  store i32 %add38, i32* %b2, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.else33, %if.end31
  %storemerge = phi i32 [ 1, %if.else33 ], [ %inc, %if.end31 ]
  store i32 %storemerge, i32* %p1, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @box_to_vec(%struct.box_t* %box, float* nocapture %vec, i32 %offset) unnamed_addr #0 {
entry:
  %p1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 10
  %0 = load i32, i32* %p1, align 4
  %p2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 11
  %1 = load i32, i32* %p2, align 4
  %add = add nsw i32 %0, %1
  %conv = sitofp i32 %1 to float
  %conv2 = sitofp i32 %add to float
  %div = fdiv float %conv, %conv2
  %cx = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 8
  %2 = load i32, i32* %cx, align 4
  %div6 = sdiv i32 %2, %add
  store i32 %div6, i32* %cx, align 4
  %cy = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 9
  %3 = load i32, i32* %cy, align 4
  %div7 = sdiv i32 %3, %add
  store i32 %div7, i32* %cy, align 4
  %conv8 = fpext float %div to double
  %cmp = fcmp olt double %conv8, 1.000000e-01
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %a2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 2
  %4 = load i32, i32* %a2, align 4
  %a1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 0
  %5 = load i32, i32* %a1, align 4
  %sub = sub nsw i32 %4, %5
  %b2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 3
  %b1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 1
  br label %if.end

if.else:                                          ; preds = %entry
  call fastcc void @box_combine(%struct.box_t* %box)
  %u2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 6
  %6 = load i32, i32* %u2, align 4
  %u1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 4
  %7 = load i32, i32* %u1, align 4
  %sub12 = sub nsw i32 %6, %7
  %v2 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 7
  %v1 = getelementptr inbounds %struct.box_t, %struct.box_t* %box, i64 0, i32 5
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %v1.sink = phi i32* [ %v1, %if.else ], [ %b1, %if.then ]
  %.sink.in = phi i32* [ %v2, %if.else ], [ %b2, %if.then ]
  %rp.0 = phi i32 [ %add, %if.else ], [ %0, %if.then ]
  %dx.0 = phi i32 [ %sub12, %if.else ], [ %sub, %if.then ]
  %.sink = load i32, i32* %.sink.in, align 4
  %8 = load i32, i32* %v1.sink, align 4
  %sub13 = sub nsw i32 %.sink, %8
  %mul = mul nsw i32 %dx.0, %sub13
  %conv14 = sitofp i32 %sub13 to float
  %conv15 = sitofp i32 %dx.0 to float
  %div16 = fdiv float %conv14, %conv15
  %conv17 = fpext float %div16 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @593, i32 0, i32 0))
  %call = call double @log(double %conv17) #11
  %conv18 = fptrunc double %call to float
  %idxprom = sext i32 %offset to i64
  %arrayidx = getelementptr inbounds float, float* %vec, i64 %idxprom
  store float %conv18, float* %arrayidx, align 4
  %conv19 = sitofp i32 %rp.0 to float
  %conv20 = sitofp i32 %mul to float
  %div21 = fdiv float %conv19, %conv20
  %add22 = add nsw i32 %offset, 1
  %idxprom23 = sext i32 %add22 to i64
  %arrayidx24 = getelementptr inbounds float, float* %vec, i64 %idxprom23
  store float %div21, float* %arrayidx24, align 4
  %conv25 = sitofp i32 %mul to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @594, i32 0, i32 0))
  %call26 = call double @log(double %conv25) #11
  %conv27 = fptrunc double %call26 to float
  %add28 = add nsw i32 %offset, 2
  %idxprom29 = sext i32 %add28 to i64
  %arrayidx30 = getelementptr inbounds float, float* %vec, i64 %idxprom29
  store float %conv27, float* %arrayidx30, align 4
  %9 = load i32, i32* %cx, align 4
  %conv32 = sitofp i32 %9 to float
  %add33 = add nsw i32 %offset, 3
  %idxprom34 = sext i32 %add33 to i64
  %arrayidx35 = getelementptr inbounds float, float* %vec, i64 %idxprom34
  store float %conv32, float* %arrayidx35, align 4
  %10 = load i32, i32* %cy, align 4
  %conv37 = sitofp i32 %10 to float
  %add38 = add nsw i32 %offset, 4
  %idxprom39 = sext i32 %add38 to i64
  %arrayidx40 = getelementptr inbounds float, float* %vec, i64 %idxprom39
  store float %conv37, float* %arrayidx40, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.box_set_t* @box_set_new() unnamed_addr #0 {
entry:
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @595, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 16, i64 1) #11
  %0 = bitcast i8* %call to %struct.box_set_t*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @596, i32 0, i32 0))
  %call1 = call noalias i8* @calloc(i64 8, i64 256) #11
  %boxes = getelementptr inbounds i8, i8* %call, i64 8
  %1 = bitcast i8* %boxes to i8**
  store i8* %call1, i8** %1, align 8
  %size = getelementptr inbounds i8, i8* %call, i64 4
  %2 = bitcast i8* %size to i32*
  store i32 256, i32* %2, align 4
  ret %struct.box_set_t* %0
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @box_set_free(%struct.box_set_t** nocapture %box_set) unnamed_addr #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %0 = load %struct.box_set_t*, %struct.box_set_t** %box_set, align 8
  %nbox = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %0, i64 0, i32 0
  %1 = load i32, i32* %nbox, align 8
  %2 = sext i32 %1 to i64
  %cmp = icmp slt i64 %indvars.iv, %2
  %boxes = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %0, i64 0, i32 2
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %3 = load %struct.box_t**, %struct.box_t*** %boxes, align 8
  %arrayidx = getelementptr inbounds %struct.box_t*, %struct.box_t** %3, i64 %indvars.iv
  %4 = bitcast %struct.box_t** %arrayidx to i8**
  %5 = load i8*, i8** %4, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @597, i32 0, i32 0))
  call void @free(i8* %5) #11
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.box_t*** %boxes to i8**
  %7 = load i8*, i8** %6, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @598, i32 0, i32 0))
  call void @free(i8* %7) #11
  %8 = bitcast %struct.box_set_t** %box_set to i8**
  %9 = load i8*, i8** %8, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @599, i32 0, i32 0))
  call void @free(i8* %9) #11
  store %struct.box_set_t* null, %struct.box_set_t** %box_set, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @box_set_insert_pxl(%struct.box_set_t* nocapture %box_set, i32 %r, i32 %x, i32 %y) unnamed_addr #0 {
entry:
  %size1 = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %box_set, i64 0, i32 1
  %0 = load i32, i32* %size1, align 4
  %cmp = icmp sgt i32 %0, %r
  br i1 %cmp, label %entry.if.end_crit_edge, label %if.then

entry.if.end_crit_edge:                           ; preds = %entry
  %boxes11.phi.trans.insert = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %box_set, i64 0, i32 2
  %.pre = load %struct.box_t**, %struct.box_t*** %boxes11.phi.trans.insert, align 8
  br label %if.end

if.then:                                          ; preds = %entry
  %mul = shl nsw i32 %0, 1
  %conv = sext i32 %mul to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @600, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 %conv, i64 8) #11
  %1 = bitcast i8* %call to %struct.box_t**
  %boxes = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %box_set, i64 0, i32 2
  %2 = sext i32 %0 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.then ]
  %cmp4 = icmp slt i64 %indvars.iv, %2
  br i1 %cmp4, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %3 = load %struct.box_t**, %struct.box_t*** %boxes, align 8
  %arrayidx = getelementptr inbounds %struct.box_t*, %struct.box_t** %3, i64 %indvars.iv
  %4 = bitcast %struct.box_t** %arrayidx to i64*
  %5 = load i64, i64* %4, align 8
  %arrayidx7 = getelementptr inbounds %struct.box_t*, %struct.box_t** %1, i64 %indvars.iv
  %6 = bitcast %struct.box_t** %arrayidx7 to i64*
  store i64 %5, i64* %6, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = bitcast %struct.box_t*** %boxes to i8**
  %8 = load i8*, i8** %7, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @601, i32 0, i32 0))
  call void @free(i8* %8) #11
  store i8* %call, i8** %7, align 8
  store i32 %mul, i32* %size1, align 4
  %9 = bitcast i8* %call to %struct.box_t**
  br label %if.end

if.end:                                           ; preds = %entry.if.end_crit_edge, %for.end
  %boxes11.pre-phi = phi %struct.box_t*** [ %boxes11.phi.trans.insert, %entry.if.end_crit_edge ], [ %boxes, %for.end ]
  %10 = phi %struct.box_t** [ %.pre, %entry.if.end_crit_edge ], [ %9, %for.end ]
  %idxprom12 = sext i32 %r to i64
  %arrayidx13 = getelementptr inbounds %struct.box_t*, %struct.box_t** %10, i64 %idxprom12
  %11 = load %struct.box_t*, %struct.box_t** %arrayidx13, align 8
  %tobool = icmp eq %struct.box_t* %11, null
  br i1 %tobool, label %if.else, label %if.then14

if.then14:                                        ; preds = %if.end
  %arrayidx17 = getelementptr inbounds %struct.box_t*, %struct.box_t** %10, i64 %idxprom12
  %12 = load %struct.box_t*, %struct.box_t** %arrayidx17, align 8
  call fastcc void @box_insert_pxl(%struct.box_t* %12, i32 %x, i32 %y)
  br label %if.end23

if.else:                                          ; preds = %if.end
  %call18 = call fastcc %struct.box_t* @box_new(i32 %x, i32 %y)
  %13 = load %struct.box_t**, %struct.box_t*** %boxes11.pre-phi, align 8
  %arrayidx21 = getelementptr inbounds %struct.box_t*, %struct.box_t** %13, i64 %idxprom12
  store %struct.box_t* %call18, %struct.box_t** %arrayidx21, align 8
  %nbox = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %box_set, i64 0, i32 0
  %14 = load i32, i32* %nbox, align 8
  %inc22 = add nsw i32 %14, 1
  store i32 %inc22, i32* %nbox, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then14
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @img_map_to_seg(%struct.img_map_t* nocapture readonly %map, %struct.cass_dataset_t* nocapture %ds) unnamed_addr #0 {
entry:
  call fastcc void @cass_dataset_init(%struct.cass_dataset_t* %ds, i32 68, i32 14)
  %nrgn = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 2
  %0 = load i32, i32* %nrgn, align 8
  call fastcc void @cass_dataset_grow(%struct.cass_dataset_t* %ds, i32 %0)
  %rgn_sz = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %for.inc ], [ 0, %entry ]
  %w.0 = phi double [ %phitmp, %for.inc ], [ 0.000000e+00, %entry ]
  %1 = load i32, i32* %nrgn, align 8
  %2 = sext i32 %1 to i64
  %cmp = icmp slt i64 %indvars.iv10, %2
  br i1 %cmp, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %3 = load i32*, i32** %rgn_sz, align 8
  %arrayidx = getelementptr inbounds i32, i32* %3, i64 %indvars.iv10
  %4 = load i32, i32* %arrayidx, align 4
  %conv5 = sitofp i32 %4 to float
  %conv6 = fpext float %conv5 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @602, i32 0, i32 0))
  %call7 = call double @sqrt(double %conv6) #11
  %add9 = fadd double %w.0, %call7
  %conv10 = fptrunc double %add9 to float
  %indvars.iv.next11 = add nuw i64 %indvars.iv10, 1
  %phitmp = fpext float %conv10 to double
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %div = fdiv double 1.000000e+00, %w.0
  %conv12 = fptrunc double %div to float
  %vec13 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 6
  %5 = bitcast i8** %vec13 to %struct._cass_vec_t**
  %6 = load %struct._cass_vec_t*, %struct._cass_vec_t** %5, align 8
  %7 = bitcast %struct._cass_vec_t* %6 to i8*
  %conv25 = fpext float %conv12 to double
  %box_set = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 5
  %vec_size55 = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 2
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc56, %for.end
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc56 ], [ 0, %for.end ]
  %8 = phi i32 [ %.pre, %for.inc56 ], [ %1, %for.end ]
  %9 = phi i8* [ %add.ptr, %for.inc56 ], [ %7, %for.end ]
  %vec.0 = phi %struct._cass_vec_t* [ %21, %for.inc56 ], [ %6, %for.end ]
  %10 = sext i32 %8 to i64
  %cmp16 = icmp slt i64 %indvars.iv8, %10
  br i1 %cmp16, label %for.body18, label %for.end58

for.body18:                                       ; preds = %for.cond14
  %parent = getelementptr inbounds %struct._cass_vec_t, %struct._cass_vec_t* %vec.0, i64 0, i32 1
  store i32 0, i32* %parent, align 4
  %11 = load i32*, i32** %rgn_sz, align 8
  %arrayidx21 = getelementptr inbounds i32, i32* %11, i64 %indvars.iv8
  %12 = load i32, i32* %arrayidx21, align 4
  %conv22 = sitofp i32 %12 to float
  %conv23 = fpext float %conv22 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @603, i32 0, i32 0))
  %call24 = call double @sqrt(double %conv23) #11
  %mul26 = fmul double %call24, %conv25
  %conv27 = fptrunc double %mul26 to float
  %weight = getelementptr inbounds %struct._cass_vec_t, %struct._cass_vec_t* %vec.0, i64 0, i32 0
  store float %conv27, float* %weight, align 4
  %u = getelementptr inbounds %struct._cass_vec_t, %struct._cass_vec_t* %vec.0, i64 0, i32 2
  %float_data = bitcast %union.anon.33* %u to [1 x float]*
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc48, %for.body18
  %indvars.iv5 = phi i64 [ %indvars.iv.next6, %for.inc48 ], [ 0, %for.body18 ]
  %indvars.iv3 = phi i64 [ %indvars.iv.next4, %for.inc48 ], [ 0, %for.body18 ]
  %exitcond7 = icmp eq i64 %indvars.iv3, 3
  br i1 %exitcond7, label %for.inc56, label %for.cond32

for.cond32:                                       ; preds = %for.cond28, %for.inc45
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc45 ], [ %indvars.iv5, %for.cond28 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc45 ], [ 0, %for.cond28 ]
  %exitcond = icmp eq i64 %indvars.iv, 3
  br i1 %exitcond, label %for.inc48, label %for.inc45

for.inc45:                                        ; preds = %for.cond32
  %arrayidx39 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv3, i64 %indvars.iv
  %13 = load float*, float** %arrayidx39, align 8
  %arrayidx41 = getelementptr inbounds float, float* %13, i64 %indvars.iv8
  %14 = bitcast float* %arrayidx41 to i32*
  %15 = load i32, i32* %14, align 4
  %arrayidx43 = getelementptr inbounds [1 x float], [1 x float]* %float_data, i64 0, i64 %indvars.iv1
  %16 = bitcast float* %arrayidx43 to i32*
  store i32 %15, i32* %16, align 4
  %indvars.iv.next2 = add nsw i64 %indvars.iv1, 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond32

for.inc48:                                        ; preds = %for.cond32
  %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 3
  br label %for.cond28

for.inc56:                                        ; preds = %for.cond28
  %17 = load %struct.box_set_t*, %struct.box_set_t** %box_set, align 8
  %boxes = getelementptr inbounds %struct.box_set_t, %struct.box_set_t* %17, i64 0, i32 2
  %18 = load %struct.box_t**, %struct.box_t*** %boxes, align 8
  %arrayidx52 = getelementptr inbounds %struct.box_t*, %struct.box_t** %18, i64 %indvars.iv8
  %19 = load %struct.box_t*, %struct.box_t** %arrayidx52, align 8
  %arraydecay = bitcast %union.anon.33* %u to float*
  call fastcc void @box_to_vec(%struct.box_t* %19, float* %arraydecay, i32 9)
  %20 = load i32, i32* %vec_size55, align 8
  %idx.ext = zext i32 %20 to i64
  %add.ptr = getelementptr i8, i8* %9, i64 %idx.ext
  %21 = bitcast i8* %add.ptr to %struct._cass_vec_t*
  %indvars.iv.next9 = add nuw i64 %indvars.iv8, 1
  %.pre = load i32, i32* %nrgn, align 8
  br label %for.cond14

for.end58:                                        ; preds = %for.cond14
  %loaded = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 1
  store i32 1, i32* %loaded, align 4
  %num_vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 8
  store i32 1, i32* %num_vecset, align 4
  %22 = load i32, i32* %nrgn, align 8
  %num_vec = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 5
  store i32 %22, i32* %num_vec, align 4
  %23 = load i32, i32* %nrgn, align 8
  %vecset = getelementptr inbounds %struct.cass_dataset_t, %struct.cass_dataset_t* %ds, i64 0, i32 9
  %24 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %num_regions = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %24, i64 0, i32 0
  store i32 %23, i32* %num_regions, align 4
  %25 = load %struct._cass_vecset_t*, %struct._cass_vecset_t** %vecset, align 8
  %start_vecid = getelementptr inbounds %struct._cass_vecset_t, %struct._cass_vecset_t* %25, i64 0, i32 1
  store i32 0, i32* %start_vecid, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @image_extract_helper(i8* nocapture readonly %HSV, i8* %mask, i32 %width, i32 %height, i32 %nrgn, %struct.cass_dataset_t* nocapture %ds) unnamed_addr #0 {
entry:
  %map = alloca %struct.img_map_t, align 8
  %ncol = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 1
  store i32 %width, i32* %ncol, align 4
  %nrow = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 0
  store i32 %height, i32* %nrow, align 8
  %nrgn1 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 2
  store i32 %nrgn, i32* %nrgn1, align 8
  %call = call fastcc i8** @__array2matrix(i32 %height, i32 %width, i32 1, i8* %mask)
  %map4 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 4
  store i8** %call, i8*** %map4, align 8
  %0 = load i32, i32* %ncol, align 4
  %1 = load i32, i32* %nrow, align 8
  %mul = mul nsw i32 %0, %1
  %size = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 3
  store i32 %mul, i32* %size, align 4
  %2 = load i32, i32* %nrgn1, align 8
  %conv = sext i32 %2 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @604, i32 0, i32 0))
  %call8 = call noalias i8* @calloc(i64 %conv, i64 4) #11
  %rgn_sz = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 6
  %3 = bitcast i32** %rgn_sz to i8**
  store i8* %call8, i8** %3, align 8
  %call9 = call fastcc %struct.box_set_t* @box_set_new()
  %box_set = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 5
  store %struct.box_set_t* %call9, %struct.box_set_t** %box_set, align 8
  %4 = sext i32 %0 to i64
  %5 = sext i32 %1 to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc22, %entry
  %indvars.iv54 = phi i64 [ %indvars.iv.next55, %for.inc22 ], [ 0, %entry ]
  %cmp = icmp slt i64 %indvars.iv54, %5
  br i1 %cmp, label %for.cond12, label %for.cond25.preheader

for.cond25.preheader:                             ; preds = %for.cond
  %6 = bitcast i8* %call8 to i32*
  %7 = load i32, i32* %nrgn1, align 8
  %conv34 = sext i32 %7 to i64
  br label %for.cond25

for.cond12:                                       ; preds = %for.cond, %for.inc
  %indvars.iv52 = phi i64 [ %indvars.iv.next53, %for.inc ], [ 0, %for.cond ]
  %cmp14 = icmp slt i64 %indvars.iv52, %4
  br i1 %cmp14, label %for.inc, label %for.inc22

for.inc:                                          ; preds = %for.cond12
  %arrayidx = getelementptr inbounds i8*, i8** %call, i64 %indvars.iv54
  %8 = load i8*, i8** %arrayidx, align 8
  %arrayidx19 = getelementptr inbounds i8, i8* %8, i64 %indvars.iv52
  %9 = load i8, i8* %arrayidx19, align 1
  %conv20 = zext i8 %9 to i32
  %10 = trunc i64 %indvars.iv52 to i32
  %11 = trunc i64 %indvars.iv54 to i32
  call fastcc void @box_set_insert_pxl(%struct.box_set_t* %call9, i32 %conv20, i32 %11, i32 %10)
  %indvars.iv.next53 = add nuw nsw i64 %indvars.iv52, 1
  br label %for.cond12

for.inc22:                                        ; preds = %for.cond12
  %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1
  br label %for.cond

for.cond25:                                       ; preds = %for.cond25.preheader, %for.inc43
  %indvars.iv49 = phi i64 [ 0, %for.cond25.preheader ], [ %indvars.iv.next50, %for.inc43 ]
  %exitcond51 = icmp eq i64 %indvars.iv49, 3
  br i1 %exitcond51, label %for.cond46.preheader, label %for.cond29

for.cond46.preheader:                             ; preds = %for.cond25
  %12 = sext i32 %0 to i64
  %13 = sext i32 %1 to i64
  br label %for.cond46

for.cond29:                                       ; preds = %for.cond25, %for.inc40
  %indvars.iv46 = phi i64 [ %indvars.iv.next47, %for.inc40 ], [ 0, %for.cond25 ]
  %exitcond48 = icmp eq i64 %indvars.iv46, 3
  br i1 %exitcond48, label %for.inc43, label %for.inc40

for.inc40:                                        ; preds = %for.cond29
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @605, i32 0, i32 0))
  %call35 = call noalias i8* @calloc(i64 %conv34, i64 4) #11
  %arrayidx39 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv49, i64 %indvars.iv46
  %14 = bitcast float** %arrayidx39 to i8**
  store i8* %call35, i8** %14, align 8
  %indvars.iv.next47 = add nuw nsw i64 %indvars.iv46, 1
  br label %for.cond29

for.inc43:                                        ; preds = %for.cond29
  %indvars.iv.next50 = add nuw nsw i64 %indvars.iv49, 1
  br label %for.cond25

for.cond46:                                       ; preds = %for.cond46.preheader, %for.inc86
  %indvars.iv44 = phi i64 [ 0, %for.cond46.preheader ], [ %indvars.iv.next45, %for.inc86 ]
  %b.0 = phi i8* [ %HSV, %for.cond46.preheader ], [ %b.1, %for.inc86 ]
  %cmp48 = icmp slt i64 %indvars.iv44, %13
  br i1 %cmp48, label %for.cond51, label %for.cond89.preheader

for.cond89.preheader:                             ; preds = %for.cond46
  %15 = sext i32 %7 to i64
  br label %for.cond89

for.cond51:                                       ; preds = %for.cond46, %for.inc83
  %indvars.iv42 = phi i64 [ %indvars.iv.next43, %for.inc83 ], [ 0, %for.cond46 ]
  %b.1 = phi i8* [ %add.ptr, %for.inc83 ], [ %b.0, %for.cond46 ]
  %cmp53 = icmp slt i64 %indvars.iv42, %12
  br i1 %cmp53, label %for.body55, label %for.inc86

for.body55:                                       ; preds = %for.cond51
  %arrayidx58 = getelementptr inbounds i8*, i8** %call, i64 %indvars.iv44
  %16 = load i8*, i8** %arrayidx58, align 8
  %arrayidx60 = getelementptr inbounds i8, i8* %16, i64 %indvars.iv42
  %17 = load i8, i8* %arrayidx60, align 1
  %idxprom63 = zext i8 %17 to i64
  %arrayidx64 = getelementptr inbounds i32, i32* %6, i64 %idxprom63
  %18 = load i32, i32* %arrayidx64, align 4
  %inc65 = add nsw i32 %18, 1
  store i32 %inc65, i32* %arrayidx64, align 4
  br label %for.cond66

for.cond66:                                       ; preds = %for.inc80, %for.body55
  %indvars.iv39 = phi i64 [ %indvars.iv.next40, %for.inc80 ], [ 0, %for.body55 ]
  %exitcond41 = icmp eq i64 %indvars.iv39, 3
  br i1 %exitcond41, label %for.inc83, label %for.inc80

for.inc80:                                        ; preds = %for.cond66
  %arrayidx71 = getelementptr inbounds i8, i8* %b.1, i64 %indvars.iv39
  %19 = load i8, i8* %arrayidx71, align 1
  %conv73 = uitofp i8 %19 to float
  %arrayidx77 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv39, i64 0
  %20 = load float*, float** %arrayidx77, align 8
  %arrayidx79 = getelementptr inbounds float, float* %20, i64 %idxprom63
  %21 = load float, float* %arrayidx79, align 4
  %add = fadd float %21, %conv73
  store float %add, float* %arrayidx79, align 4
  %indvars.iv.next40 = add nuw nsw i64 %indvars.iv39, 1
  br label %for.cond66

for.inc83:                                        ; preds = %for.cond66
  %add.ptr = getelementptr inbounds i8, i8* %b.1, i64 3
  %indvars.iv.next43 = add nuw nsw i64 %indvars.iv42, 1
  br label %for.cond51

for.inc86:                                        ; preds = %for.cond51
  %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1
  br label %for.cond46

for.cond89:                                       ; preds = %for.cond89.preheader, %for.inc111
  %indvars.iv36 = phi i64 [ 0, %for.cond89.preheader ], [ %indvars.iv.next37, %for.inc111 ]
  %exitcond38 = icmp eq i64 %indvars.iv36, 3
  br i1 %exitcond38, label %for.cond114.preheader, label %for.cond93.preheader

for.cond93.preheader:                             ; preds = %for.cond89
  %arrayidx105 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv36, i64 0
  br label %for.cond93

for.cond114.preheader:                            ; preds = %for.cond89
  %22 = sext i32 %0 to i64
  br label %for.cond114

for.cond93:                                       ; preds = %for.cond93.preheader, %for.inc108
  %indvars.iv34 = phi i64 [ 0, %for.cond93.preheader ], [ %indvars.iv.next35, %for.inc108 ]
  %cmp95 = icmp slt i64 %indvars.iv34, %15
  br i1 %cmp95, label %for.inc108, label %for.inc111

for.inc108:                                       ; preds = %for.cond93
  %arrayidx100 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv34
  %23 = load i32, i32* %arrayidx100, align 4
  %conv101 = sitofp i32 %23 to float
  %24 = load float*, float** %arrayidx105, align 8
  %arrayidx107 = getelementptr inbounds float, float* %24, i64 %indvars.iv34
  %25 = load float, float* %arrayidx107, align 4
  %div = fdiv float %25, %conv101
  store float %div, float* %arrayidx107, align 4
  %indvars.iv.next35 = add nuw nsw i64 %indvars.iv34, 1
  br label %for.cond93

for.inc111:                                       ; preds = %for.cond93
  %indvars.iv.next37 = add nuw nsw i64 %indvars.iv36, 1
  br label %for.cond89

for.cond114:                                      ; preds = %for.cond114.preheader, %for.inc168
  %indvars.iv32 = phi i64 [ 0, %for.cond114.preheader ], [ %indvars.iv.next33, %for.inc168 ]
  %b.2 = phi i8* [ %HSV, %for.cond114.preheader ], [ %b.3, %for.inc168 ]
  %26 = load i32, i32* %nrow, align 8
  %27 = sext i32 %26 to i64
  %cmp116 = icmp slt i64 %indvars.iv32, %27
  br i1 %cmp116, label %for.cond119, label %for.cond171.preheader

for.cond171.preheader:                            ; preds = %for.cond114
  %28 = sext i32 %7 to i64
  br label %for.cond171

for.cond119:                                      ; preds = %for.cond114, %for.inc165
  %indvars.iv30 = phi i64 [ %indvars.iv.next31, %for.inc165 ], [ 0, %for.cond114 ]
  %b.3 = phi i8* [ %add.ptr164, %for.inc165 ], [ %b.2, %for.cond114 ]
  %cmp121 = icmp slt i64 %indvars.iv30, %22
  br i1 %cmp121, label %for.body123, label %for.inc168

for.body123:                                      ; preds = %for.cond119
  %arrayidx126 = getelementptr inbounds i8*, i8** %call, i64 %indvars.iv32
  %29 = load i8*, i8** %arrayidx126, align 8
  %arrayidx128 = getelementptr inbounds i8, i8* %29, i64 %indvars.iv30
  %30 = load i8, i8* %arrayidx128, align 1
  %idxprom142 = zext i8 %30 to i64
  br label %for.cond130

for.cond130:                                      ; preds = %for.inc161, %for.body123
  %indvars.iv27 = phi i64 [ %indvars.iv.next28, %for.inc161 ], [ 0, %for.body123 ]
  %exitcond29 = icmp eq i64 %indvars.iv27, 3
  br i1 %exitcond29, label %for.inc165, label %for.inc161

for.inc161:                                       ; preds = %for.cond130
  %arrayidx135 = getelementptr inbounds i8, i8* %b.3, i64 %indvars.iv27
  %31 = load i8, i8* %arrayidx135, align 1
  %conv137 = uitofp i8 %31 to float
  %arrayidx141 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv27, i64 0
  %32 = load float*, float** %arrayidx141, align 8
  %arrayidx143 = getelementptr inbounds float, float* %32, i64 %idxprom142
  %33 = load float, float* %arrayidx143, align 4
  %sub = fsub float %conv137, %33
  %mul144 = fmul float %sub, %sub
  %arrayidx148 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv27, i64 1
  %34 = load float*, float** %arrayidx148, align 8
  %arrayidx150 = getelementptr inbounds float, float* %34, i64 %idxprom142
  %35 = load float, float* %arrayidx150, align 4
  %add151 = fadd float %35, %mul144
  store float %add151, float* %arrayidx150, align 4
  %mul153 = fmul float %mul144, %sub
  %arrayidx157 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv27, i64 2
  %36 = load float*, float** %arrayidx157, align 8
  %arrayidx159 = getelementptr inbounds float, float* %36, i64 %idxprom142
  %37 = load float, float* %arrayidx159, align 4
  %add160 = fadd float %37, %mul153
  store float %add160, float* %arrayidx159, align 4
  %indvars.iv.next28 = add nuw nsw i64 %indvars.iv27, 1
  br label %for.cond130

for.inc165:                                       ; preds = %for.cond130
  %add.ptr164 = getelementptr inbounds i8, i8* %b.3, i64 3
  %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1
  br label %for.cond119

for.inc168:                                       ; preds = %for.cond119
  %indvars.iv.next33 = add nuw i64 %indvars.iv32, 1
  br label %for.cond114

for.cond171:                                      ; preds = %for.cond171.preheader, %for.inc234
  %indvars.iv24 = phi i64 [ 0, %for.cond171.preheader ], [ %indvars.iv.next25, %for.inc234 ]
  %exitcond26 = icmp eq i64 %indvars.iv24, 3
  br i1 %exitcond26, label %for.end236, label %for.cond175.preheader

for.cond175.preheader:                            ; preds = %for.cond171
  %arrayidx183 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv24, i64 0
  %arrayidx192 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv24, i64 1
  %arrayidx213 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv24, i64 2
  br label %for.cond175

for.cond175:                                      ; preds = %for.cond175.preheader, %for.inc231
  %indvars.iv22 = phi i64 [ 0, %for.cond175.preheader ], [ %indvars.iv.next23, %for.inc231 ]
  %cmp177 = icmp slt i64 %indvars.iv22, %28
  br i1 %cmp177, label %for.inc231, label %for.inc234

for.inc231:                                       ; preds = %for.cond175
  %38 = load float*, float** %arrayidx183, align 8
  %arrayidx185 = getelementptr inbounds float, float* %38, i64 %indvars.iv22
  %39 = load float, float* %arrayidx185, align 4
  %conv188 = fdiv float %39, 2.550000e+02
  store float %conv188, float* %arrayidx185, align 4
  %40 = load float*, float** %arrayidx192, align 8
  %arrayidx194 = getelementptr inbounds float, float* %40, i64 %indvars.iv22
  %41 = load float, float* %arrayidx194, align 4
  %arrayidx197 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv22
  %42 = load i32, i32* %arrayidx197, align 4
  %conv198 = sitofp i32 %42 to float
  %div199 = fdiv float %41, %conv198
  %conv200 = fpext float %div199 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @606, i32 0, i32 0))
  %call201 = call double @sqrt(double %conv200) #11
  %div202 = fdiv double %call201, 2.550000e+02
  %conv203 = fptrunc double %div202 to float
  store float %conv203, float* %arrayidx194, align 4
  %43 = load float*, float** %arrayidx213, align 8
  %arrayidx215 = getelementptr inbounds float, float* %43, i64 %indvars.iv22
  %44 = load float, float* %arrayidx215, align 4
  %arrayidx218 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv22
  %45 = load i32, i32* %arrayidx218, align 4
  %conv219 = sitofp i32 %45 to float
  %div220 = fdiv float %44, %conv219
  %conv221 = fpext float %div220 to double
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @607, i32 0, i32 0))
  %call222 = call double @cbrt(double %conv221) #11
  %div223 = fdiv double %call222, 2.550000e+02
  %conv224 = fptrunc double %div223 to float
  store float %conv224, float* %arrayidx215, align 4
  %indvars.iv.next23 = add nuw nsw i64 %indvars.iv22, 1
  br label %for.cond175

for.inc234:                                       ; preds = %for.cond175
  %indvars.iv.next25 = add nuw nsw i64 %indvars.iv24, 1
  br label %for.cond171

for.end236:                                       ; preds = %for.cond171
  call fastcc void @img_map_to_seg(%struct.img_map_t* nonnull %map, %struct.cass_dataset_t* %ds)
  call fastcc void @apply_weight(%struct.cass_dataset_t* %ds)
  %46 = bitcast i8*** %map4 to i8**
  %47 = load i8*, i8** %46, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @608, i32 0, i32 0))
  call void @free(i8* %47) #11
  %48 = load %struct.box_set_t*, %struct.box_set_t** %box_set, align 8
  %tobool = icmp eq %struct.box_set_t* %48, null
  br i1 %tobool, label %if.then244, label %if.then

if.then:                                          ; preds = %for.end236
  call fastcc void @box_set_free(%struct.box_set_t** %box_set)
  %.pre1 = load i8*, i8** %3, align 8
  br label %if.then244

if.then244:                                       ; preds = %if.then, %for.end236
  %49 = phi i8* [ %.pre1, %if.then ], [ %call8, %for.end236 ]
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @609, i32 0, i32 0))
  call void @free(i8* %49) #11
  br label %for.cond245

for.cond245:                                      ; preds = %for.inc261, %if.then244
  %indvars.iv19 = phi i64 [ %indvars.iv.next20, %for.inc261 ], [ 0, %if.then244 ]
  %exitcond21 = icmp eq i64 %indvars.iv19, 3
  br i1 %exitcond21, label %if.end264, label %for.cond249

for.cond249:                                      ; preds = %for.cond245, %for.inc258
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc258 ], [ 0, %for.cond245 ]
  %exitcond = icmp eq i64 %indvars.iv, 3
  br i1 %exitcond, label %for.inc261, label %for.inc258

for.inc258:                                       ; preds = %for.cond249
  %arrayidx257 = getelementptr inbounds %struct.img_map_t, %struct.img_map_t* %map, i64 0, i32 7, i64 %indvars.iv19, i64 %indvars.iv
  %50 = bitcast float** %arrayidx257 to i8**
  %51 = load i8*, i8** %50, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @610, i32 0, i32 0))
  call void @free(i8* %51) #11
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond249

for.inc261:                                       ; preds = %for.cond249
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  br label %for.cond245

if.end264:                                        ; preds = %for.cond245
  ret void
}

; Function Attrs: nounwind
declare double @cbrt(double) local_unnamed_addr #1

; Function Attrs: noinline nounwind uwtable
define internal fastcc void @image_segment(i8** nocapture %output, i32* nocapture %num_ccs, i8* %in_data_1d, i32 %num_cols, i32 %num_rows) unnamed_addr #0 {
if.end7:
  %mul = mul nsw i32 %num_rows, %num_cols
  %mul8 = mul nsw i32 %mul, 3
  %sub9 = add nsw i32 %num_rows, -1
  %sub10 = add nsw i32 %num_cols, -1
  %call11 = call fastcc i8** @__array2matrix(i32 %num_rows, i32 %num_cols, i32 3, i8* %in_data_1d)
  %conv = sitofp i32 %mul to double
  %mul12 = fmul double %conv, 6.000000e+00
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @611, i32 0, i32 0))
  %call13 = call double @log(double %mul12) #11
  %mul14 = fmul double %call13, 2.000000e+00
  %mul17 = fmul double %conv, 5.000000e-03
  %conv18 = fptosi double %mul17 to i32
  %conv19 = sext i32 %mul to i64
  %mul20 = shl nsw i64 %conv19, 3
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @612, i32 0, i32 0))
  %call21 = call noalias i8* @malloc(i64 %mul20) #11
  %0 = bitcast i8* %call21 to double*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @613, i32 0, i32 0))
  %call24 = call noalias i8* @malloc(i64 %mul20) #11
  %1 = bitcast i8* %call24 to double*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @614, i32 0, i32 0))
  %call27 = call noalias i8* @malloc(i64 %mul20) #11
  %2 = bitcast i8* %call27 to double*
  %mul29 = shl nsw i64 %conv19, 2
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @615, i32 0, i32 0))
  %call30 = call noalias i8* @malloc(i64 %mul29) #11
  %3 = bitcast i8* %call30 to i32*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @616, i32 0, i32 0))
  %call33 = call noalias i8* @malloc(i64 %mul29) #11
  %4 = bitcast i8* %call33 to i32*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @617, i32 0, i32 0))
  %call35 = call noalias i8* @calloc(i64 %conv19, i64 4) #11
  %5 = bitcast i8* %call35 to i32*
  %cmp36 = icmp eq i8* %call21, null
  %cmp39 = icmp eq i8* %call24, null
  %or.cond = or i1 %cmp36, %cmp39
  %cmp42 = icmp eq i8* %call27, null
  %or.cond168 = or i1 %or.cond, %cmp42
  %cmp45 = icmp eq i8* %call30, null
  %or.cond169 = or i1 %or.cond168, %cmp45
  %cmp48 = icmp eq i8* %call33, null
  %or.cond170 = or i1 %or.cond169, %cmp48
  %cmp51 = icmp eq i8* %call35, null
  %or.cond171 = or i1 %or.cond170, %cmp51
  br i1 %or.cond171, label %do.body54, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end7
  %6 = sext i32 %mul8 to i64
  br label %for.cond

do.body54:                                        ; preds = %if.end7
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @618, i32 0, i32 0))
  %call55 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %7, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.594, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @image_segment.func_name, i64 0, i64 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.3.595, i64 0, i64 0)) #14
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @619, i32 0, i32 0))
  %call56 = call i32 @fflush(%struct._IO_FILE* %8)
  br label %return

for.cond:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv166 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next167, %for.inc ]
  %indvars.iv162 = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next163, %for.inc ]
  %cmp59 = icmp slt i64 %indvars.iv162, %6
  br i1 %cmp59, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8, i8* %in_data_1d, i64 %indvars.iv162
  %9 = load i8, i8* %arrayidx, align 1
  %conv61 = uitofp i8 %9 to double
  %arrayidx63 = getelementptr inbounds double, double* %0, i64 %indvars.iv166
  store double %conv61, double* %arrayidx63, align 8
  %10 = add nuw nsw i64 %indvars.iv162, 1
  %arrayidx65 = getelementptr inbounds i8, i8* %in_data_1d, i64 %10
  %11 = load i8, i8* %arrayidx65, align 1
  %conv66 = uitofp i8 %11 to double
  %arrayidx68 = getelementptr inbounds double, double* %1, i64 %indvars.iv166
  store double %conv66, double* %arrayidx68, align 8
  %12 = add nuw nsw i64 %indvars.iv162, 2
  %arrayidx71 = getelementptr inbounds i8, i8* %in_data_1d, i64 %12
  %13 = load i8, i8* %arrayidx71, align 1
  %conv72 = uitofp i8 %13 to double
  %arrayidx74 = getelementptr inbounds double, double* %2, i64 %indvars.iv166
  store double %conv72, double* %arrayidx74, align 8
  %arrayidx76 = getelementptr inbounds i32, i32* %3, i64 %indvars.iv166
  store i32 1, i32* %arrayidx76, align 4
  %arrayidx78 = getelementptr inbounds i32, i32* %4, i64 %indvars.iv166
  %14 = trunc i64 %indvars.iv166 to i32
  store i32 %14, i32* %arrayidx78, align 4
  %indvars.iv.next167 = add nuw nsw i64 %indvars.iv166, 1
  %indvars.iv.next163 = add nuw nsw i64 %indvars.iv162, 3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %mul80 = shl nsw i32 %sub10, 1
  %mul81 = mul nsw i32 %mul80, %sub9
  %add82 = add nsw i32 %mul81, %sub9
  %add83 = add nsw i32 %add82, %sub10
  %conv84 = sext i32 %add83 to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @620, i32 0, i32 0))
  %call85 = call noalias i8* @calloc(i64 %conv84, i64 12) #11
  %15 = bitcast i8* %call85 to %struct.RegionPair*
  %cmp86 = icmp eq i8* %call85, null
  br i1 %cmp86, label %do.body89, label %for.cond94.preheader

for.cond94.preheader:                             ; preds = %for.end
  %16 = sext i32 %sub10 to i64
  %17 = sext i32 %sub9 to i64
  br label %for.cond94

do.body89:                                        ; preds = %for.end
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @621, i32 0, i32 0))
  %call90 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %18, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.594, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @image_segment.func_name, i64 0, i64 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.3.595, i64 0, i64 0)) #14
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @622, i32 0, i32 0))
  %call91 = call i32 @fflush(%struct._IO_FILE* %19)
  br label %return

for.cond94:                                       ; preds = %for.cond94.preheader, %for.inc358
  %indvars.iv160 = phi i64 [ 0, %for.cond94.preheader ], [ %indvars.iv.next161, %for.inc358 ]
  %cnt.1 = phi i32 [ 0, %for.cond94.preheader ], [ %inc357, %for.inc358 ]
  %idx.0 = phi i64 [ 0, %for.cond94.preheader ], [ %phitmp, %for.inc358 ]
  %cmp95 = icmp slt i64 %indvars.iv160, %17
  br i1 %cmp95, label %for.cond98.preheader, label %for.cond361.preheader

for.cond98.preheader:                             ; preds = %for.cond94
  %arrayidx10379 = getelementptr inbounds i8*, i8** %call11, i64 %indvars.iv160
  %arrayidx103 = bitcast i8** %arrayidx10379 to [3 x i8]**
  %indvars.iv.next161 = add nuw nsw i64 %indvars.iv160, 1
  %arrayidx243103 = getelementptr inbounds i8*, i8** %call11, i64 %indvars.iv.next161
  %arrayidx243 = bitcast i8** %arrayidx243103 to [3 x i8]**
  br label %for.cond98

for.cond361.preheader:                            ; preds = %for.cond94
  %idxprom375 = sext i32 %sub10 to i64
  %20 = sext i32 %sub9 to i64
  br label %for.cond361

for.cond98:                                       ; preds = %for.cond98.preheader, %for.body101
  %indvars.iv157 = phi i64 [ %idx.0, %for.cond98.preheader ], [ %indvars.iv.next158, %for.body101 ]
  %indvars.iv155 = phi i64 [ 0, %for.cond98.preheader ], [ %indvars.iv.next156, %for.body101 ]
  %cnt.2 = phi i32 [ %cnt.1, %for.cond98.preheader ], [ %add123, %for.body101 ]
  %cmp99 = icmp slt i64 %indvars.iv155, %16
  br i1 %cmp99, label %for.body101, label %for.inc358

for.body101:                                      ; preds = %for.cond98
  %21 = load [3 x i8]*, [3 x i8]** %arrayidx103, align 8
  %arrayidx106 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv155, i64 0
  %22 = load i8, i8* %arrayidx106, align 1
  %conv107 = zext i8 %22 to i32
  %arrayidx112 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv155, i64 1
  %23 = load i8, i8* %arrayidx112, align 1
  %conv113 = zext i8 %23 to i32
  %arrayidx118 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv155, i64 2
  %24 = load i8, i8* %arrayidx118, align 1
  %conv119 = zext i8 %24 to i32
  %reg1122 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv157, i32 0
  store i32 %cnt.2, i32* %reg1122, align 4
  %add123 = add nsw i32 %cnt.2, 1
  %reg2126 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv157, i32 1
  store i32 %add123, i32* %reg2126, align 4
  %indvars.iv.next156 = add nuw nsw i64 %indvars.iv155, 1
  %arrayidx132 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv.next156, i64 0
  %25 = load i8, i8* %arrayidx132, align 1
  %conv133 = zext i8 %25 to i32
  %sub134 = sub nsw i32 %conv133, %conv107
  %ispos83 = icmp sgt i32 %sub134, -1
  %neg84 = sub nsw i32 0, %sub134
  %26 = select i1 %ispos83, i32 %sub134, i32 %neg84
  %arrayidx141 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv.next156, i64 1
  %27 = load i8, i8* %arrayidx141, align 1
  %conv142 = zext i8 %27 to i32
  %sub143 = sub nsw i32 %conv142, %conv113
  %ispos86 = icmp sgt i32 %sub143, -1
  %neg87 = sub nsw i32 0, %sub143
  %28 = select i1 %ispos86, i32 %sub143, i32 %neg87
  %arrayidx150 = getelementptr inbounds [3 x i8], [3 x i8]* %21, i64 %indvars.iv.next156, i64 2
  %29 = load i8, i8* %arrayidx150, align 1
  %conv151 = zext i8 %29 to i32
  %sub152 = sub nsw i32 %conv151, %conv119
  %ispos89 = icmp sgt i32 %sub152, -1
  %neg90 = sub nsw i32 0, %sub152
  %30 = select i1 %ispos89, i32 %sub152, i32 %neg90
  %cmp154 = icmp sgt i32 %28, %30
  %. = select i1 %cmp154, i32 %28, i32 %30
  %cmp174 = icmp sgt i32 %26, %.
  %.172 = select i1 %cmp154, i32 %28, i32 %30
  %cond230 = select i1 %cmp174, i32 %26, i32 %.172
  %delta = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv157, i32 2
  store i32 %cond230, i32* %delta, align 4
  %31 = add nsw i64 %indvars.iv157, 1
  %reg1236 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %31, i32 0
  store i32 %cnt.2, i32* %reg1236, align 4
  %add237 = add nsw i32 %cnt.2, %num_cols
  %reg2240 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %31, i32 1
  store i32 %add237, i32* %reg2240, align 4
  %32 = load [3 x i8]*, [3 x i8]** %arrayidx243, align 8
  %arrayidx246 = getelementptr inbounds [3 x i8], [3 x i8]* %32, i64 %indvars.iv155, i64 0
  %33 = load i8, i8* %arrayidx246, align 1
  %conv247 = zext i8 %33 to i32
  %sub248 = sub nsw i32 %conv247, %conv107
  %ispos104 = icmp sgt i32 %sub248, -1
  %neg105 = sub nsw i32 0, %sub248
  %34 = select i1 %ispos104, i32 %sub248, i32 %neg105
  %arrayidx255 = getelementptr inbounds [3 x i8], [3 x i8]* %32, i64 %indvars.iv155, i64 1
  %35 = load i8, i8* %arrayidx255, align 1
  %conv256 = zext i8 %35 to i32
  %sub257 = sub nsw i32 %conv256, %conv113
  %ispos107 = icmp sgt i32 %sub257, -1
  %neg108 = sub nsw i32 0, %sub257
  %36 = select i1 %ispos107, i32 %sub257, i32 %neg108
  %arrayidx264 = getelementptr inbounds [3 x i8], [3 x i8]* %32, i64 %indvars.iv155, i64 2
  %37 = load i8, i8* %arrayidx264, align 1
  %conv265 = zext i8 %37 to i32
  %sub266 = sub nsw i32 %conv265, %conv119
  %ispos110 = icmp sgt i32 %sub266, -1
  %neg111 = sub nsw i32 0, %sub266
  %38 = select i1 %ispos110, i32 %sub266, i32 %neg111
  %cmp268 = icmp sgt i32 %36, %38
  %.173 = select i1 %cmp268, i32 %36, i32 %38
  %cmp292 = icmp sgt i32 %34, %.173
  %.174 = select i1 %cmp268, i32 %36, i32 %38
  %cond348 = select i1 %cmp292, i32 %34, i32 %.174
  %delta351 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %31, i32 2
  store i32 %cond348, i32* %delta351, align 4
  %indvars.iv.next158 = add nsw i64 %indvars.iv157, 2
  br label %for.cond98

for.inc358:                                       ; preds = %for.cond98
  %inc357 = add nsw i32 %cnt.2, 1
  %sext180 = shl i64 %indvars.iv157, 32
  %phitmp = ashr exact i64 %sext180, 32
  br label %for.cond94

for.cond361:                                      ; preds = %for.cond361.preheader, %for.body364
  %indvars.iv153 = phi i64 [ %idx.0, %for.cond361.preheader ], [ %indvars.iv.next154, %for.body364 ]
  %indvars.iv151 = phi i64 [ 0, %for.cond361.preheader ], [ %indvars.iv.next152, %for.body364 ]
  %cnt.3 = phi i32 [ %sub10, %for.cond361.preheader ], [ %add368, %for.body364 ]
  %cmp362 = icmp slt i64 %indvars.iv151, %20
  br i1 %cmp362, label %for.body364, label %for.end546

for.body364:                                      ; preds = %for.cond361
  %reg1367 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv153, i32 0
  store i32 %cnt.3, i32* %reg1367, align 4
  %add368 = add nsw i32 %cnt.3, %num_cols
  %reg2371 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv153, i32 1
  store i32 %add368, i32* %reg2371, align 4
  %indvars.iv.next152 = add nuw nsw i64 %indvars.iv151, 1
  %arrayidx37439 = getelementptr inbounds i8*, i8** %call11, i64 %indvars.iv.next152
  %arrayidx374 = bitcast i8** %arrayidx37439 to [3 x i8]**
  %39 = load [3 x i8]*, [3 x i8]** %arrayidx374, align 8
  %arrayidx377 = getelementptr inbounds [3 x i8], [3 x i8]* %39, i64 %idxprom375, i64 0
  %40 = load i8, i8* %arrayidx377, align 1
  %conv378 = zext i8 %40 to i32
  %arrayidx38040 = getelementptr inbounds i8*, i8** %call11, i64 %indvars.iv151
  %arrayidx380 = bitcast i8** %arrayidx38040 to [3 x i8]**
  %41 = load [3 x i8]*, [3 x i8]** %arrayidx380, align 8
  %arrayidx383 = getelementptr inbounds [3 x i8], [3 x i8]* %41, i64 %idxprom375, i64 0
  %42 = load i8, i8* %arrayidx383, align 1
  %conv384 = zext i8 %42 to i32
  %sub385 = sub nsw i32 %conv378, %conv384
  %ispos41 = icmp sgt i32 %sub385, -1
  %neg42 = sub nsw i32 0, %sub385
  %43 = select i1 %ispos41, i32 %sub385, i32 %neg42
  %arrayidx392 = getelementptr inbounds [3 x i8], [3 x i8]* %39, i64 %idxprom375, i64 1
  %44 = load i8, i8* %arrayidx392, align 1
  %conv393 = zext i8 %44 to i32
  %arrayidx398 = getelementptr inbounds [3 x i8], [3 x i8]* %41, i64 %idxprom375, i64 1
  %45 = load i8, i8* %arrayidx398, align 1
  %conv399 = zext i8 %45 to i32
  %sub400 = sub nsw i32 %conv393, %conv399
  %ispos45 = icmp sgt i32 %sub400, -1
  %neg46 = sub nsw i32 0, %sub400
  %46 = select i1 %ispos45, i32 %sub400, i32 %neg46
  %arrayidx407 = getelementptr inbounds [3 x i8], [3 x i8]* %39, i64 %idxprom375, i64 2
  %47 = load i8, i8* %arrayidx407, align 1
  %conv408 = zext i8 %47 to i32
  %arrayidx413 = getelementptr inbounds [3 x i8], [3 x i8]* %41, i64 %idxprom375, i64 2
  %48 = load i8, i8* %arrayidx413, align 1
  %conv414 = zext i8 %48 to i32
  %sub415 = sub nsw i32 %conv408, %conv414
  %ispos49 = icmp sgt i32 %sub415, -1
  %neg50 = sub nsw i32 0, %sub415
  %49 = select i1 %ispos49, i32 %sub415, i32 %neg50
  %cmp417 = icmp sgt i32 %46, %49
  %.175 = select i1 %cmp417, i32 %46, i32 %49
  %cmp453 = icmp sgt i32 %43, %.175
  %.176 = select i1 %cmp417, i32 %46, i32 %49
  %cond539 = select i1 %cmp453, i32 %43, i32 %.176
  %delta542 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv153, i32 2
  store i32 %cond539, i32* %delta542, align 4
  %indvars.iv.next154 = add nsw i64 %indvars.iv153, 1
  br label %for.cond361

for.end546:                                       ; preds = %for.cond361
  %mul547 = mul nsw i32 %sub9, %num_cols
  %idxprom559 = sext i32 %sub9 to i64
  %arrayidx5601 = getelementptr inbounds i8*, i8** %call11, i64 %idxprom559
  %arrayidx560 = bitcast i8** %arrayidx5601 to [3 x i8]**
  %50 = sext i32 %sub10 to i64
  %sext = shl i64 %indvars.iv153, 32
  %51 = ashr exact i64 %sext, 32
  br label %for.cond548

for.cond548:                                      ; preds = %for.body551, %for.end546
  %indvars.iv149 = phi i64 [ %indvars.iv.next150, %for.body551 ], [ %51, %for.end546 ]
  %indvars.iv147 = phi i64 [ %indvars.iv.next148, %for.body551 ], [ 0, %for.end546 ]
  %cnt.4 = phi i32 [ %inc555, %for.body551 ], [ %mul547, %for.end546 ]
  %cmp549 = icmp slt i64 %indvars.iv147, %50
  br i1 %cmp549, label %for.body551, label %for.end733

for.body551:                                      ; preds = %for.cond548
  %reg1554 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv149, i32 0
  store i32 %cnt.4, i32* %reg1554, align 4
  %inc555 = add nsw i32 %cnt.4, 1
  %reg2558 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv149, i32 1
  store i32 %inc555, i32* %reg2558, align 4
  %52 = load [3 x i8]*, [3 x i8]** %arrayidx560, align 8
  %indvars.iv.next148 = add nuw nsw i64 %indvars.iv147, 1
  %arrayidx564 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv.next148, i64 0
  %53 = load i8, i8* %arrayidx564, align 1
  %conv565 = zext i8 %53 to i32
  %arrayidx570 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv147, i64 0
  %54 = load i8, i8* %arrayidx570, align 1
  %conv571 = zext i8 %54 to i32
  %sub572 = sub nsw i32 %conv565, %conv571
  %ispos = icmp sgt i32 %sub572, -1
  %neg = sub nsw i32 0, %sub572
  %55 = select i1 %ispos, i32 %sub572, i32 %neg
  %arrayidx579 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv.next148, i64 1
  %56 = load i8, i8* %arrayidx579, align 1
  %conv580 = zext i8 %56 to i32
  %arrayidx585 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv147, i64 1
  %57 = load i8, i8* %arrayidx585, align 1
  %conv586 = zext i8 %57 to i32
  %sub587 = sub nsw i32 %conv580, %conv586
  %ispos5 = icmp sgt i32 %sub587, -1
  %neg6 = sub nsw i32 0, %sub587
  %58 = select i1 %ispos5, i32 %sub587, i32 %neg6
  %arrayidx594 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv.next148, i64 2
  %59 = load i8, i8* %arrayidx594, align 1
  %conv595 = zext i8 %59 to i32
  %arrayidx600 = getelementptr inbounds [3 x i8], [3 x i8]* %52, i64 %indvars.iv147, i64 2
  %60 = load i8, i8* %arrayidx600, align 1
  %conv601 = zext i8 %60 to i32
  %sub602 = sub nsw i32 %conv595, %conv601
  %ispos9 = icmp sgt i32 %sub602, -1
  %neg10 = sub nsw i32 0, %sub602
  %61 = select i1 %ispos9, i32 %sub602, i32 %neg10
  %cmp604 = icmp sgt i32 %58, %61
  %.177 = select i1 %cmp604, i32 %58, i32 %61
  %cmp640 = icmp sgt i32 %55, %.177
  %.178 = select i1 %cmp604, i32 %58, i32 %61
  %cond726 = select i1 %cmp640, i32 %55, i32 %.178
  %delta729 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %15, i64 %indvars.iv149, i32 2
  store i32 %cond726, i32* %delta729, align 4
  %indvars.iv.next150 = add nsw i64 %indvars.iv149, 1
  br label %for.cond548

for.end733:                                       ; preds = %for.cond548
  %call734 = call fastcc %struct.RegionPair* @bucket_sort(%struct.RegionPair* %15, i32 %add83)
  %62 = sext i32 %add83 to i64
  br label %for.cond735

for.cond735:                                      ; preds = %for.inc884, %for.end733
  %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.inc884 ], [ 0, %for.end733 ]
  %cmp736 = icmp slt i64 %indvars.iv145, %62
  br i1 %cmp736, label %for.body738, label %for.cond887

for.body738:                                      ; preds = %for.cond735
  %reg1741 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %call734, i64 %indvars.iv145, i32 0
  %63 = load i32, i32* %reg1741, align 4
  %call742 = call fastcc i32 @find_set(i32* %4, i32 %63)
  %reg2745 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %call734, i64 %indvars.iv145, i32 1
  %64 = load i32, i32* %reg2745, align 4
  %call746 = call fastcc i32 @find_set(i32* %4, i32 %64)
  %cmp747 = icmp eq i32 %call742, %call746
  br i1 %cmp747, label %for.inc884, label %if.then749

if.then749:                                       ; preds = %for.body738
  %idxprom750 = sext i32 %call742 to i64
  %arrayidx751 = getelementptr inbounds i32, i32* %3, i64 %idxprom750
  %65 = load i32, i32* %arrayidx751, align 4
  %cmp752 = icmp slt i32 %65, 256
  %.179 = select i1 %cmp752, i32 %65, i32 256
  %conv760 = sitofp i32 %.179 to double
  %conv763 = sitofp i32 %65 to double
  %add764 = fadd double %conv763, 1.000000e+00
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @623, i32 0, i32 0))
  %call765 = call double @log(double %add764) #11
  %mul766 = fmul double %conv760, %call765
  %add767 = fadd double %mul766, %mul14
  %div771 = fdiv double %add767, %conv763
  %idxprom772 = sext i32 %call746 to i64
  %arrayidx773 = getelementptr inbounds i32, i32* %3, i64 %idxprom772
  %66 = load i32, i32* %arrayidx773, align 4
  %cmp774 = icmp slt i32 %66, 256
  %cond781 = select i1 %cmp774, i32 %66, i32 256
  %conv782 = sitofp i32 %cond781 to double
  %conv785 = sitofp i32 %66 to double
  %add786 = fadd double %conv785, 1.000000e+00
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @624, i32 0, i32 0))
  %call787 = call double @log(double %add786) #11
  %mul788 = fmul double %conv782, %call787
  %add789 = fadd double %mul788, %mul14
  %div793 = fdiv double %add789, %conv785
  %add794 = fadd double %div771, %div793
  %mul795 = fmul double %add794, 2.560000e+02
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @625, i32 0, i32 0))
  %call796 = call double @sqrt(double %mul795) #11
  %arrayidx798 = getelementptr inbounds double, double* %0, i64 %idxprom750
  %67 = load double, double* %arrayidx798, align 8
  %arrayidx800 = getelementptr inbounds double, double* %0, i64 %idxprom772
  %68 = load double, double* %arrayidx800, align 8
  %sub801 = fsub double %67, %68
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @626, i32 0, i32 0))
  %call802 = call double @fabs(double %sub801) #12
  %cmp803 = fcmp olt double %call802, %call796
  br i1 %cmp803, label %land.lhs.true, label %for.inc884

land.lhs.true:                                    ; preds = %if.then749
  %arrayidx806 = getelementptr inbounds double, double* %1, i64 %idxprom750
  %69 = load double, double* %arrayidx806, align 8
  %arrayidx808 = getelementptr inbounds double, double* %1, i64 %idxprom772
  %70 = load double, double* %arrayidx808, align 8
  %sub809 = fsub double %69, %70
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @627, i32 0, i32 0))
  %call810 = call double @fabs(double %sub809) #12
  %cmp811 = fcmp olt double %call810, %call796
  br i1 %cmp811, label %land.lhs.true813, label %for.inc884

land.lhs.true813:                                 ; preds = %land.lhs.true
  %arrayidx815 = getelementptr inbounds double, double* %2, i64 %idxprom750
  %71 = load double, double* %arrayidx815, align 8
  %arrayidx817 = getelementptr inbounds double, double* %2, i64 %idxprom772
  %72 = load double, double* %arrayidx817, align 8
  %sub818 = fsub double %71, %72
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @628, i32 0, i32 0))
  %call819 = call double @fabs(double %sub818) #12
  %cmp820 = fcmp olt double %call819, %call796
  br i1 %cmp820, label %if.then822, label %for.inc884

if.then822:                                       ; preds = %land.lhs.true813
  %call823 = call fastcc i32 @union_set(i32 %call742, i32 %call746, i32* %4, i32* %5)
  %add828 = add nsw i32 %65, %66
  %mul834 = fmul double %conv763, %67
  %mul840 = fmul double %conv785, %68
  %add841 = fadd double %mul834, %mul840
  %conv842 = sitofp i32 %add828 to double
  %div843 = fdiv double %add841, %conv842
  %idxprom844 = sext i32 %call823 to i64
  %arrayidx845 = getelementptr inbounds double, double* %0, i64 %idxprom844
  store double %div843, double* %arrayidx845, align 8
  %mul851 = fmul double %conv763, %69
  %mul857 = fmul double %conv785, %70
  %add858 = fadd double %mul851, %mul857
  %div860 = fdiv double %add858, %conv842
  %arrayidx862 = getelementptr inbounds double, double* %1, i64 %idxprom844
  store double %div860, double* %arrayidx862, align 8
  %mul868 = fmul double %conv763, %71
  %mul874 = fmul double %conv785, %72
  %add875 = fadd double %mul868, %mul874
  %div877 = fdiv double %add875, %conv842
  %arrayidx879 = getelementptr inbounds double, double* %2, i64 %idxprom844
  store double %div877, double* %arrayidx879, align 8
  %arrayidx881 = getelementptr inbounds i32, i32* %3, i64 %idxprom844
  store i32 %add828, i32* %arrayidx881, align 4
  br label %for.inc884

for.inc884:                                       ; preds = %for.body738, %if.then822, %land.lhs.true813, %land.lhs.true, %if.then749
  %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1
  br label %for.cond735

for.cond887:                                      ; preds = %for.cond735, %for.inc976
  %ir.2 = phi i32 [ %inc977, %for.inc976 ], [ 0, %for.cond735 ]
  %cnt.5 = phi i32 [ %cnt.6, %for.inc976 ], [ 0, %for.cond735 ]
  %cmp888 = icmp slt i32 %ir.2, %num_rows
  br i1 %cmp888, label %for.cond892, label %for.end978

for.cond892:                                      ; preds = %for.cond887, %for.inc973
  %ic.2 = phi i32 [ %inc974, %for.inc973 ], [ 1, %for.cond887 ]
  %cnt.6.in = phi i32 [ %cnt.6, %for.inc973 ], [ %cnt.5, %for.cond887 ]
  %cnt.6 = add nsw i32 %cnt.6.in, 1
  %cmp893 = icmp slt i32 %ic.2, %num_cols
  br i1 %cmp893, label %for.body895, label %for.inc976

for.body895:                                      ; preds = %for.cond892
  %call896 = call fastcc i32 @find_set(i32* %4, i32 %cnt.6)
  %call898 = call fastcc i32 @find_set(i32* %4, i32 %cnt.6.in)
  %cmp899 = icmp eq i32 %call896, %call898
  br i1 %cmp899, label %for.inc973, label %land.lhs.true901

land.lhs.true901:                                 ; preds = %for.body895
  %idxprom902 = sext i32 %call898 to i64
  %arrayidx903 = getelementptr inbounds i32, i32* %3, i64 %idxprom902
  %73 = load i32, i32* %arrayidx903, align 4
  %cmp904 = icmp slt i32 %73, %conv18
  %.pre = sext i32 %call896 to i64
  %.pre142 = getelementptr inbounds i32, i32* %3, i64 %.pre
  br i1 %cmp904, label %if.then911, label %lor.lhs.false906

lor.lhs.false906:                                 ; preds = %land.lhs.true901
  %74 = load i32, i32* %.pre142, align 4
  %cmp909 = icmp slt i32 %74, %conv18
  br i1 %cmp909, label %if.then911, label %for.inc973

if.then911:                                       ; preds = %land.lhs.true901, %lor.lhs.false906
  %call912 = call fastcc i32 @union_set(i32 %call896, i32 %call898, i32* %4, i32* %5)
  %75 = load i32, i32* %.pre142, align 4
  %76 = load i32, i32* %arrayidx903, align 4
  %add917 = add nsw i32 %75, %76
  %conv920 = sitofp i32 %75 to double
  %arrayidx922 = getelementptr inbounds double, double* %0, i64 %.pre
  %77 = load double, double* %arrayidx922, align 8
  %mul923 = fmul double %conv920, %77
  %conv926 = sitofp i32 %76 to double
  %arrayidx928 = getelementptr inbounds double, double* %0, i64 %idxprom902
  %78 = load double, double* %arrayidx928, align 8
  %mul929 = fmul double %conv926, %78
  %add930 = fadd double %mul923, %mul929
  %conv931 = sitofp i32 %add917 to double
  %div932 = fdiv double %add930, %conv931
  %idxprom933 = sext i32 %call912 to i64
  %arrayidx934 = getelementptr inbounds double, double* %0, i64 %idxprom933
  store double %div932, double* %arrayidx934, align 8
  %arrayidx939 = getelementptr inbounds double, double* %1, i64 %.pre
  %79 = load double, double* %arrayidx939, align 8
  %mul940 = fmul double %conv920, %79
  %arrayidx945 = getelementptr inbounds double, double* %1, i64 %idxprom902
  %80 = load double, double* %arrayidx945, align 8
  %mul946 = fmul double %conv926, %80
  %add947 = fadd double %mul940, %mul946
  %div949 = fdiv double %add947, %conv931
  %arrayidx951 = getelementptr inbounds double, double* %1, i64 %idxprom933
  store double %div949, double* %arrayidx951, align 8
  %arrayidx956 = getelementptr inbounds double, double* %2, i64 %.pre
  %81 = load double, double* %arrayidx956, align 8
  %mul957 = fmul double %conv920, %81
  %arrayidx962 = getelementptr inbounds double, double* %2, i64 %idxprom902
  %82 = load double, double* %arrayidx962, align 8
  %mul963 = fmul double %conv926, %82
  %add964 = fadd double %mul957, %mul963
  %div966 = fdiv double %add964, %conv931
  %arrayidx968 = getelementptr inbounds double, double* %2, i64 %idxprom933
  store double %div966, double* %arrayidx968, align 8
  %arrayidx970 = getelementptr inbounds i32, i32* %3, i64 %idxprom933
  store i32 %add917, i32* %arrayidx970, align 4
  br label %for.inc973

for.inc973:                                       ; preds = %lor.lhs.false906, %if.then911, %for.body895
  %inc974 = add nuw nsw i32 %ic.2, 1
  br label %for.cond892

for.inc976:                                       ; preds = %for.cond892
  %inc977 = add nuw nsw i32 %ir.2, 1
  br label %for.cond887

for.end978:                                       ; preds = %for.cond887
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @629, i32 0, i32 0))
  %call980 = call noalias i8* @calloc(i64 1, i64 %conv19) #11
  %83 = sext i32 %mul to i64
  br label %for.cond981

for.cond981:                                      ; preds = %for.inc987, %for.end978
  %indvars.iv143 = phi i64 [ %indvars.iv.next144, %for.inc987 ], [ 0, %for.end978 ]
  %cmp982 = icmp slt i64 %indvars.iv143, %83
  br i1 %cmp982, label %for.inc987, label %for.cond990

for.inc987:                                       ; preds = %for.cond981
  %arrayidx986 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv143
  store i32 -1, i32* %arrayidx986, align 4
  %indvars.iv.next144 = add nuw nsw i64 %indvars.iv143, 1
  br label %for.cond981

for.cond990:                                      ; preds = %for.cond981, %for.inc1010
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc1010 ], [ 0, %for.cond981 ]
  %ik.3 = phi i32 [ %add1011, %for.inc1010 ], [ 0, %for.cond981 ]
  %num_region.0 = phi i32 [ %num_region.1, %for.inc1010 ], [ 0, %for.cond981 ]
  %cmp991 = icmp slt i32 %ik.3, %mul8
  br i1 %cmp991, label %for.body993, label %for.end1012

for.body993:                                      ; preds = %for.cond990
  %84 = trunc i64 %indvars.iv to i32
  %call994 = call fastcc i32 @find_set(i32* %4, i32 %84)
  %idxprom995 = sext i32 %call994 to i64
  %arrayidx996 = getelementptr inbounds i32, i32* %5, i64 %idxprom995
  %85 = load i32, i32* %arrayidx996, align 4
  %cmp997 = icmp slt i32 %85, 0
  br i1 %cmp997, label %if.then999, label %for.inc1010

if.then999:                                       ; preds = %for.body993
  store i32 %num_region.0, i32* %arrayidx996, align 4
  %inc1002 = add nsw i32 %num_region.0, 1
  br label %for.inc1010

for.inc1010:                                      ; preds = %for.body993, %if.then999
  %86 = phi i32 [ %num_region.0, %if.then999 ], [ %85, %for.body993 ]
  %num_region.1 = phi i32 [ %inc1002, %if.then999 ], [ %num_region.0, %for.body993 ]
  %conv1006 = trunc i32 %86 to i8
  %arrayidx1008 = getelementptr inbounds i8, i8* %call980, i64 %indvars.iv
  store i8 %conv1006, i8* %arrayidx1008, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %add1011 = add nuw nsw i32 %ik.3, 3
  br label %for.cond990

for.end1012:                                      ; preds = %for.cond990
  store i32 %num_region.0, i32* %num_ccs, align 4
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @630, i32 0, i32 0))
  call void @free(i8* %call21) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @631, i32 0, i32 0))
  call void @free(i8* %call24) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @632, i32 0, i32 0))
  call void @free(i8* %call27) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @633, i32 0, i32 0))
  call void @free(i8* %call30) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @634, i32 0, i32 0))
  call void @free(i8* %call33) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @635, i32 0, i32 0))
  call void @free(i8* %call35) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @636, i32 0, i32 0))
  call void @free(i8* %call85) #11
  %87 = bitcast %struct.RegionPair* %call734 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @637, i32 0, i32 0))
  call void @free(i8* %87) #11
  %88 = bitcast i8** %call11 to i8*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @638, i32 0, i32 0))
  call void @free(i8* %88) #11
  store i8* %call980, i8** %output, align 8
  br label %return

return:                                           ; preds = %for.end1012, %do.body89, %do.body54
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal fastcc noalias %struct.RegionPair* @bucket_sort(%struct.RegionPair* nocapture readonly %pair, i32 %num_elems) unnamed_addr #0 {
entry:
  %conv = sext i32 %num_elems to i64
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @639, i32 0, i32 0))
  %call = call noalias i8* @calloc(i64 %conv, i64 12) #11
  %0 = bitcast i8* %call to %struct.RegionPair*
  %cmp = icmp eq i8* %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @640, i32 0, i32 0))
  %call2 = call noalias i8* @calloc(i64 256, i64 4) #11
  %1 = bitcast i8* %call2 to i32*
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @641, i32 0, i32 0))
  %call3 = call noalias i8* @malloc(i64 1024) #11
  %2 = sext i32 %num_elems to i64
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %for.inc ], [ 0, %if.end ]
  %cmp4 = icmp slt i64 %indvars.iv4, %2
  br i1 %cmp4, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %delta = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %pair, i64 %indvars.iv4, i32 2
  %3 = load i32, i32* %delta, align 4
  %idxprom6 = sext i32 %3 to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %1, i64 %idxprom6
  %4 = load i32, i32* %arrayidx7, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %arrayidx7, align 4
  %indvars.iv.next5 = add nuw nsw i64 %indvars.iv4, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = bitcast i8* %call3 to i32*
  store i32 0, i32* %5, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc21, %for.end
  %indvars.iv1 = phi i64 [ %indvars.iv.next2, %for.inc21 ], [ 1, %for.end ]
  %6 = phi i32 [ %add, %for.inc21 ], [ 0, %for.end ]
  %exitcond = icmp eq i64 %indvars.iv1, 256
  br i1 %exitcond, label %for.cond24.preheader, label %for.inc21

for.cond24.preheader:                             ; preds = %for.cond10
  %7 = sext i32 %num_elems to i64
  br label %for.cond24

for.inc21:                                        ; preds = %for.cond10
  %8 = add nsw i64 %indvars.iv1, -1
  %arrayidx18 = getelementptr inbounds i32, i32* %1, i64 %8
  %9 = load i32, i32* %arrayidx18, align 4
  %add = add nsw i32 %6, %9
  %arrayidx20 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv1
  store i32 %add, i32* %arrayidx20, align 4
  %indvars.iv.next2 = add nuw nsw i64 %indvars.iv1, 1
  br label %for.cond10

for.cond24:                                       ; preds = %for.cond24.preheader, %for.inc38
  %indvars.iv = phi i64 [ 0, %for.cond24.preheader ], [ %indvars.iv.next, %for.inc38 ]
  %cmp25 = icmp slt i64 %indvars.iv, %7
  br i1 %cmp25, label %for.inc38, label %for.end40

for.inc38:                                        ; preds = %for.cond24
  %delta30 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %pair, i64 %indvars.iv, i32 2
  %10 = load i32, i32* %delta30, align 4
  %idxprom31 = sext i32 %10 to i64
  %arrayidx32 = getelementptr inbounds i32, i32* %5, i64 %idxprom31
  %11 = load i32, i32* %arrayidx32, align 4
  %inc33 = add nsw i32 %11, 1
  store i32 %inc33, i32* %arrayidx32, align 4
  %idxprom34 = sext i32 %11 to i64
  %arrayidx35 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %0, i64 %idxprom34
  %arrayidx37 = getelementptr inbounds %struct.RegionPair, %struct.RegionPair* %pair, i64 %indvars.iv
  %12 = bitcast %struct.RegionPair* %arrayidx35 to i8*
  %13 = bitcast %struct.RegionPair* %arrayidx37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 12, i32 4, i1 false)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond24

for.end40:                                        ; preds = %for.cond24
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @642, i32 0, i32 0))
  call void @free(i8* %call2) #11
  call void @__noinstrument_count_libcall(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @643, i32 0, i32 0))
  call void @free(i8* %call3) #11
  br label %return

return:                                           ; preds = %entry, %for.end40
  %retval.0 = phi %struct.RegionPair* [ %0, %for.end40 ], [ null, %entry ]
  ret %struct.RegionPair* %retval.0
}

; Function Attrs: noinline norecurse nounwind readonly uwtable
define internal fastcc i32 @find_set(i32* nocapture readonly %parent, i32 %i) unnamed_addr #6 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %i.addr.0 = phi i32 [ %i, %entry ], [ %0, %while.cond ]
  %idxprom = sext i32 %i.addr.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %parent, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4
  %cmp = icmp eq i32 %0, %i.addr.0
  br i1 %cmp, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  ret i32 %i.addr.0
}

; Function Attrs: noinline norecurse nounwind uwtable
define internal fastcc i32 @union_set(i32 %i, i32 %j, i32* nocapture %parent, i32* nocapture %rank) unnamed_addr #8 {
entry:
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds i32, i32* %rank, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %j to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %rank, i64 %idxprom1
  %1 = load i32, i32* %arrayidx2, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arrayidx4 = getelementptr inbounds i32, i32* %parent, i64 %idxprom1
  store i32 %i, i32* %arrayidx4, align 4
  br label %return

if.end:                                           ; preds = %entry
  %arrayidx6 = getelementptr inbounds i32, i32* %parent, i64 %idxprom
  store i32 %j, i32* %arrayidx6, align 4
  %2 = load i32, i32* %arrayidx, align 4
  %3 = load i32, i32* %arrayidx2, align 4
  %cmp11 = icmp eq i32 %2, %3
  br i1 %cmp11, label %if.then12, label %return

if.then12:                                        ; preds = %if.end
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %arrayidx2, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then12, %if.then
  %retval.0 = phi i32 [ %i, %if.then ], [ %j, %if.then12 ], [ %j, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) local_unnamed_addr #11

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #11

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture readonly) local_unnamed_addr #11

; Function Attrs: nounwind readnone
declare i32 @llvm.bswap.i32(i32) #12

declare float @floorf(float) local_unnamed_addr

declare float @sqrtf(float) local_unnamed_addr

declare float @fabsf(float) local_unnamed_addr

declare void @__noinstrument_count_libcall(i8*)

attributes #0 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { noinline norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noinline norecurse nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noinline norecurse nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { noinline nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { noinline noreturn nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { nounwind }
attributes #12 = { nounwind readnone }
attributes #13 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #14 = { cold }
attributes #15 = { nounwind readonly }
attributes #16 = { noreturn nounwind }
attributes #17 = { readnone }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}

!0 = !{!"clang version 4.0.0 (tags/RELEASE_400/final)"}
